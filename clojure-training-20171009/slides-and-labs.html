<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Intro to Clojure</title>
<!-- 2017-10-09 Mon 12:23 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Clojure/core" />
<link rel="stylesheet" type="text/css" href="slide-assets/goog-common.css" />
<link rel="stylesheet" type="text/css" href="slide-assets/common.css" />
<link rel="stylesheet" type="text/css" href="slide-assets/screen.css" media="screen" />
<link rel="stylesheet" type="text/css" href="slide-assets/projection.css" media="projection" />
<link rel="stylesheet" type="text/css" href="slide-assets/presenter.css" media="presenter" />
<link rel="stylesheet" type="text/css" href="slide-assets/print.css" media="print" />
</head>
<body>
<div id="content">
<h1 class="title">Intro to Clojure</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Intro to Clojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a>
<ul>
<li><a href="#sec-1-1">Overview of the Course&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-2">Clojure Overview &amp; REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-3">LAB: Exploring the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-4">Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-5">LAB: Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-6">Flow Control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-7">LAB: Flow Control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-8">Collections as Containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-9">Collections as Indexes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-10">LAB: Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-11">Collections as Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-12">LAB: Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-13">Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-1-14">LAB: Sums and Ciphers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
</ul>
</li>
<li><a href="#sec-2">Intermediate Topics</a>
<ul>
<li><a href="#sec-2-1">Transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-2-2">Polymorphism&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-2-3">LAB: Rock, Paper, Scissors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-2-4">Concurrency&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-2-5">LAB: Concurrent Surgery&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-2-6">Names and Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-2-7">LAB: Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-2-8">Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-2-9">LAB: Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
</ul>
</li>
<li><a href="#sec-3">Optional Topics</a>
<ul>
<li><a href="#sec-3-1">Testing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-3-2">LAB: Testing</a></li>
<li><a href="#sec-3-3">Life on the JVM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-3-4">LAB: Type Hints and Primitive Arithmetic&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-3-5">core.async&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-3-6">LAB: core.async&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-3-7">Web Development&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-3-8">LAB: Web Development&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#sec-3-9">Bonus Lab: Poker</a></li>
</ul>
</li>
<li><a href="#sec-4">The End</a></li>
</ul>
</div>
</div>
<p class="copyright">Copyright &copy; 2014 <a href="http://cognitect.com">Cognitect, Inc</a>. All rights reserved. Not for distribution.</p>
<p>This HTML document contains <strong>both</strong> lecture slides and lab exercises. Press <strong>T</strong> to toggle slide-show mode. The lab exercises are <strong>not</strong> visible in slide-show mode.</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Intro to Clojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Overview of the Course&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Intro Topics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>Clojure Overview &amp; REPL
</li>
<li>Functions
</li>
<li>Flow Control
</li>
<li>Collections
</li>
<li>Sequences
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Intermediate Topics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>Transducers
</li>
<li>Polymorphism
</li>
<li>Concurrency
</li>
<li>Names and Namespaces
</li>
<li>Macros
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">Optional Topics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>Testing
</li>
<li>Life on the JVM
</li>
<li>core.async
</li>
<li>Web Development
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Clojure Overview &amp; REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-2">
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Clojure Objectives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>Lisp: small core, code-as-data, abstraction
</li>
<li>Functional, emphasis on immutability
</li>
<li>Support concurrency &amp; managed state
</li>
<li>Expose and embrace host platforms
</li>
</ul>
</div>

<div id="outline-container-sec-1-2-1-1" class="outline-5">
<h5 id="sec-1-2-1-1">Why Another Lisp?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-1-1">
<ul class="org-ul">
<li>Limits to change post standardization
</li>
<li>Core data structures mutable, not extensible
</li>
<li>No concurrency in specs
</li>
<li>Standard Lisps are their own platforms
<ul class="org-ul">
<li>Already have ABCL, Kawa, and more on the JVM
</li>
<li>Impedance mismatch with the JVM as host platform
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-1-2" class="outline-5">
<h5 id="sec-1-2-1-2">Why the JVM?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-1-2">
<ul class="org-ul">
<li>VM, not OS, is target platform of the future
</li>
<li>Type system
</li>
<li>Dynamic enforcement and safety
</li>
<li>Garbage collection
</li>
<li>Libraries
</li>
<li>Bytecode, just-in-time compilation
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-1-3" class="outline-5">
<h5 id="sec-1-2-1-3">Why ClojureScript?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-1-3">
<ul class="org-ul">
<li>JavaScript has reach
<ul class="org-ul">
<li>Web browsers
</li>
<li>Mobile devices
</li>
<li>Databases, PDF, etc.
</li>
</ul>
</li>
<li>JavaScript VMs getting faster
</li>
<li>Clojure is simpler, more powerful, &amp; more robust than JS
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-1-4" class="outline-5">
<h5 id="sec-1-2-1-4">Clojure and ClojureScript&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-1-4">
<ul class="org-ul">
<li>This course will focus on Clojure
</li>
<li>Code with no interop calls mostly works in both
</li>
<li>Host platforms are different
<ul class="org-ul">
<li>Interop calls
</li>
<li>Native types (strings, numbers)
</li>
</ul>
</li>
<li>Can exchange serialized data with both
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Basic Syntax and the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-2-2">
</div><div id="outline-container-sec-1-2-2-1" class="outline-5">
<h5 id="sec-1-2-2-1">Literals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-2-1">
<div class="org-src-container">

<pre class="src src-clojure">42           <span class="org-comment">; Long</span>
6.022e23     <span class="org-comment">; Double</span>

42N          <span class="org-comment">; BigInt</span>
1.0M         <span class="org-comment">; BigDecimal</span>
22/7         <span class="org-comment">; Ratio</span>

<span class="org-string">"hello"</span>      <span class="org-comment">; String</span>
\e           <span class="org-comment">; Character</span>
#<span class="org-string">"[0-9]"</span>     <span class="org-comment">; Regular Expression</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-2-1-1" class="outline-6">
<h6 id="sec-1-2-2-1-1">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-1-2-2-1-1">
<ul class="org-ul">
<li>Comments start with a semicolon and go to the end of the line
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-2-2" class="outline-5">
<h5 id="sec-1-2-2-2">Literals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-2-2">
<div class="org-src-container">

<pre class="src src-clojure">true  false                  <span class="org-comment">; Booleans</span>

nil                          <span class="org-comment">; null</span>

call-me  +  <span class="org-preprocessor">Fred</span>  *bob*      <span class="org-comment">; Symbols</span>

<span class="org-constant">:alpha</span>  <span class="org-constant">:beta</span>  <span class="org-constant">::my-keyword</span>  <span class="org-comment">; Keywords</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-2-3" class="outline-5">
<h5 id="sec-1-2-2-3">Literals in the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-2-3">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; 42       <span class="org-comment">; Read</span>
                <span class="org-comment">; Eval</span>
42              <span class="org-comment">; Print</span>
user=&gt;          <span class="org-comment">; Loop</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-2-4" class="outline-5">
<h5 id="sec-1-2-2-4">Expressions in the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-2-4">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-variable-name">+</span> 3 4)  <span class="org-comment">; Read</span>
                <span class="org-comment">; Eval</span>
7               <span class="org-comment">; Print</span>
user=&gt;          <span class="org-comment">; Loop</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-2-5" class="outline-5">
<h5 id="sec-1-2-2-5">Binding Names With <code>def</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-2-5">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; pi     <span class="org-comment">; Not defined yet!!</span>
<span class="org-preprocessor">CompilerException</span> java.lang.RuntimeException: <span class="org-preprocessor">Unable</span> 
to resolve symbol: pi in this context ...

user=&gt; (<span class="org-keyword">def</span> <span class="org-function-name">pi</span> 3.14159)
#'user/pi

user=&gt; pi
3.14159
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-2-6" class="outline-5">
<h5 id="sec-1-2-2-6">Hello, World!&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-2-6">
<pre class="example">
user=&gt; (println "Hello, World!")
Hello, World!              ; printed output
nil                        ; return value
</pre>

<ul class="org-ul">
<li>REPL always shows return value
</li>
<li>Printing is a side effect, returns <code>nil</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2-7" class="outline-5">
<h5 id="sec-1-2-2-7">REPL Memory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-2-7">
<pre class="example">
user=&gt; (+ 3 4)
7
user=&gt; (+ 10 *1)     ; *1 is most recent return value
17
user=&gt; (+ 100 *2)    ; *2 is next most recent
107
</pre>
</div>

<div id="outline-container-sec-1-2-2-7-1" class="outline-6">
<h6 id="sec-1-2-2-7-1">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-1-2-2-7-1">
<ul class="org-ul">
<li>Our examples use these conventions:
<ul class="org-ul">
<li><code>;;</code> before printed output
</li>
<li><code>;;=&gt;</code> before return values
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-2-8" class="outline-5">
<h5 id="sec-1-2-2-8">Variants on Printing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-2-8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">Human-Readable</th>
<th scope="col" class="left">Machine-Readable</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">With newline</td>
<td class="left">&nbsp; <code>println</code></td>
<td class="left">&nbsp; <code>prn</code></td>
</tr>

<tr>
<td class="left">Without newline</td>
<td class="left">&nbsp; <code>print</code></td>
<td class="left">&nbsp; <code>pr</code></td>
</tr>
</tbody>
</table>

<pre class="example">
user=&gt; (println "one\ntwo")
one
two
nil

user=&gt; (prn "one\ntwo")
"one\ntwo"   ; quoted string, escaped newline
nil
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Evaluation and Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-2-3">
</div><div id="outline-container-sec-1-2-3-1" class="outline-5">
<h5 id="sec-1-2-3-1">Traditional Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-1">

<div class="figure">
<p><img src="slide-assets/traditional-evaluation.svg" alt="traditional-evaluation.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-3-2" class="outline-5">
<h5 id="sec-1-2-3-2">Clojure Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-2">

<div class="figure">
<p><img src="slide-assets/clojure-interactive-evaluation.svg" alt="clojure-interactive-evaluation.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-3-3" class="outline-5">
<h5 id="sec-1-2-3-3">Data Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-3">
<div class="org-src-container">

<pre class="src src-clojure">(4 <span class="org-constant">:alpha</span> 3.0)     <span class="org-comment">; List</span>

[2 <span class="org-string">"hello"</span> 99]     <span class="org-comment">; Vector</span>

{<span class="org-constant">:a</span> 1, <span class="org-constant">:b</span> 2}       <span class="org-comment">; Map</span>

#{alice jim bob}   <span class="org-comment">; Set</span>
</pre>
</div>

<ul class="org-ul">
<li>Note: commas are whitespace
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3-4" class="outline-5">
<h5 id="sec-1-2-3-4">Structure vs. Semantics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-4">

<div class="figure">
<p><img src="slide-assets/structure-and-semantics.svg" alt="structure-and-semantics.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-3-5" class="outline-5">
<h5 id="sec-1-2-3-5">Operation Forms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-5">
<div class="org-src-container">

<pre class="src src-clojure">(op ... )
</pre>
</div>

<ul class="org-ul">
<li><code>op</code> is "function position," can be any of:
<ul class="org-ul">
<li>Function: <code>+</code>, <code>mod</code>, <code>println</code>
</li>
<li>Macro: <code>when</code>, <code>cond</code>, <code>and</code>
</li>
<li>Special operator: <code>do</code>, <code>if</code>, <code>def</code>
</li>
<li>An expression which yields a function
</li>
<li>More generally, something invocable (<code>clojure.lang.IFn</code>)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3-6" class="outline-5">
<h5 id="sec-1-2-3-6">Function Calls Always Use Parens&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">hello</span> [] <span class="org-string">"Hello, world!"</span>)  <span class="org-comment">; hello is a function</span>

hello                            <span class="org-comment">; return the function</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #&lt;user$hello user$hello@bda96b&gt;</span>

(hello)                          <span class="org-comment">; invoke the function</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Hello, world!"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-3-7" class="outline-5">
<h5 id="sec-1-2-3-7">Values Never Use Parens&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-7">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">my-name</span> <span class="org-string">"Kelly Q. Programmer"</span>)  <span class="org-comment">; my-name is a value</span>

my-name                              <span class="org-comment">; return the value</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Kelly Q. Programmer"</span>

(my-name)                            <span class="org-comment">; invoke the value</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">ClassCastException java.lang.String cannot be cast to clojure.lang.IFn</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-3-8" class="outline-5">
<h5 id="sec-1-2-3-8">Quote: Preventing Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-8">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">x</span> 3)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/x</span>

(<span class="org-variable-name">+</span> x 2)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 5</span>

(quote (<span class="org-variable-name">+</span> x 2)) <span class="org-comment">; quoted list</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (+ x 2)    ; returns list, unevaluated</span>

'(<span class="org-variable-name">+</span> x 2)        <span class="org-comment">; same as above</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (+ x 2)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-3-9" class="outline-5">
<h5 id="sec-1-2-3-9">Quote: Preventing Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-3-9">
<div class="org-src-container">

<pre class="src src-clojure">(1 2 3)
<span class="org-comment-delimiter">;; </span><span class="org-comment">ClassCastException java.lang.Long cannot</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">be cast to clojure.lang.IFn</span>

'(1 2 3)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (1 2 3)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">Discovering the Environment&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-2-4">
</div><div id="outline-container-sec-1-2-4-1" class="outline-5">
<h5 id="sec-1-2-4-1"><code>doc</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-4-1">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-variable-name">use</span> 'clojure.repl)    <span class="org-comment">; quoted symbol</span>

user=&gt; (<span class="org-variable-name">doc</span> when)
<span class="org-comment-delimiter">;; </span><span class="org-comment">-------------------------</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.core/when</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">([test &amp; body])</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Macro</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">Evaluates test. If logical true, evaluates</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">body in an implicit do.</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-4-2" class="outline-5">
<h5 id="sec-1-2-4-2"><code>find-doc</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-4-2">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-variable-name">find-doc</span> <span class="org-string">"sequence"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">... all definitions with "sequence"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">in their documentation ...</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-4-3" class="outline-5">
<h5 id="sec-1-2-4-3"><code>apropos</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-4-3">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (apropos <span class="org-string">"map"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (clojure.core/Throwable-&gt;map clojure.core/amap clojure.core/array-map</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/hash-map clojure.core/map clojure.core/map-entry?</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/map-indexed clojure.core/map? clojure.core/mapcat</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/mapv clojure.core/ns-map clojure.core/ns-unmap</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/pmap clojure.core/proxy-mappings clojure.core/sorted-map</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/sorted-map-by clojure.core/struct-map clojure.core/zipmap)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-4-4" class="outline-5">
<h5 id="sec-1-2-4-4"><code>source</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-4-4">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (source not)
<span class="org-comment-delimiter">;; </span><span class="org-comment">(defn not</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">"Returns true if x is logical false, false otherwise."</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:tag Boolean</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">:added "1.0"</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">:static true}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[x] (if x false true))</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-4-5" class="outline-5">
<h5 id="sec-1-2-4-5"><code>dir</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-4-5">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (dir clojure.repl)
<span class="org-comment-delimiter">;; </span><span class="org-comment">apropos</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">demunge</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">dir</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">dir-fn</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">doc</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">find-doc</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">pst</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">root-cause</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">set-break-handler!</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">source</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">source-fn</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">stack-element-str</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">thread-stopper</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-4-6" class="outline-5">
<h5 id="sec-1-2-4-6">Cheat Sheet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-4-6">
<ul class="org-ul">
<li><a href="http://clojure.org/api/cheatsheet">http://clojure.org/api/cheatsheet</a>
</li>
<li><code>cheatsheet.pdf</code> in supplied files
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">Project Management&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-2-5">
</div><div id="outline-container-sec-1-2-5-1" class="outline-5">
<h5 id="sec-1-2-5-1">Leiningen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-5-1">
<ul class="org-ul">
<li>pronounced "LINE-ing-en"
</li>
<li><a href="http://leiningen.org/">leiningen.org</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-shell-script">lein new ${<span class="org-variable-name">NAME</span>}      <span class="org-comment-delimiter"># </span><span class="org-comment">Generate a new project</span>
lein repl             <span class="org-comment-delimiter"># </span><span class="org-comment">Start a REPL</span>
lein run -m foo/main  <span class="org-comment-delimiter"># </span><span class="org-comment">Execute function foo/main</span>
lein version          <span class="org-comment-delimiter"># </span><span class="org-comment">Show version</span>
lein help             <span class="org-comment-delimiter"># </span><span class="org-comment">Show available commands</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-5-2" class="outline-5">
<h5 id="sec-1-2-5-2">Leiningen 2 Project&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-5-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Path</th>
<th scope="col" class="left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">&nbsp; <code>project.clj</code></td>
<td class="left">Project/build config</td>
</tr>

<tr>
<td class="left">&nbsp; <code>src/</code></td>
<td class="left">Clojure sources</td>
</tr>

<tr>
<td class="left">&nbsp; <code>test/</code></td>
<td class="left">Clojure unit tests</td>
</tr>

<tr>
<td class="left">&nbsp; <code>resources/</code></td>
<td class="left">Non-code project files</td>
</tr>

<tr>
<td class="left">&nbsp; <code>resources/public/</code></td>
<td class="left">HTML/CSS/JS files for web (convention)</td>
</tr>

<tr>
<td class="left">&nbsp; <code>target/classes/</code></td>
<td class="left">Compiled bytecode</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Cached dependencies stored in <code>$HOME/.m2/repository/</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-5-3" class="outline-5">
<h5 id="sec-1-2-5-3">Leiningen project.clj&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-5-3">
<div class="org-src-container">

<pre class="src src-clojure">(defproject my-project <span class="org-string">"0.1.0-SNAPSHOT"</span>
  <span class="org-constant">:description</span> <span class="org-string">"This is the best project ever"</span>
  <span class="org-constant">:dependencies</span> [[org.clojure/clojure <span class="org-string">"1.8.0"</span>]
                 [org.clojure/math.combinatorics <span class="org-string">"0.1.1"</span>]])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-5-4" class="outline-5">
<h5 id="sec-1-2-5-4">Leiningen Dependencies&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-5-4">
<ul class="org-ul">
<li>Vector of <i>symbol</i> and version <i>string</i>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;  </span><span class="org-comment">group ID      artifact ID      version</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">----------- ------------------  -------</span>
[  org.clojure/math.combinatorics  <span class="org-string">"0.1.1"</span> ]

<span class="org-comment-delimiter">;; </span><span class="org-comment">Same group &amp; artifact ID        version</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">------------------------        -------</span>
[  compojure                       <span class="org-string">"1.5.0"</span> ]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-5-5" class="outline-5">
<h5 id="sec-1-2-5-5">Finding Dependencies&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-2-5-5">
<ul class="org-ul">
<li>Clojure-contrib: <a href="http://dev.clojure.org/display/doc/Clojure+Contrib+Libraries">http://dev.clojure.org/display/doc/Clojure+Contrib+Libraries</a>
</li>
<li><a href="http://clojars.org">Clojars.org</a>: Clojure community libraries
</li>
<li><a href="http://search.maven.org/">search.maven.org</a>: most open-source Java libraries
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">LAB: Exploring the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-3">
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Simple Arithmetic</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Using the REPL, compute the sum of 7654 and 1234.
</p>
</div>

<div id="outline-container-sec-1-3-1-1" class="outline-5">
<h5 id="sec-1-3-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-3-1-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">+</span> 7654 1234)
</pre>
</div>

<pre class="example">
;;=&gt; 8888
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Order of Operations</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Rewrite the following arithmetic expression as a Clojure expression and evaluate it at the REPL:
</p>

<p>
( 7 + 3 * 4 + 5 ) / 10
</p>
</div>

<div id="outline-container-sec-1-3-2-1" class="outline-5">
<h5 id="sec-1-3-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-3-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">/</span> (<span class="org-variable-name">+</span> 7 (<span class="org-variable-name">*</span> 3 4) 5) 10)
</pre>
</div>

<pre class="example">
;;=&gt; 12/5
</pre>
</div>
</div>
<div id="outline-container-sec-1-3-2-2" class="outline-5">
<h5 id="sec-1-3-2-2">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-3-2-2">
<ul class="org-ul">
<li>Clojure does not need an operator precedence table
</li>
<li>Division of integers returns a ratio
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">Finding Documentation by Name</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Using REPL documentation functions, find the documentation for the <b>rem</b> and <b>mod</b> functions. Evaluate some expressions that demonstrate the difference between these two functions.
</p>
</div>

<div id="outline-container-sec-1-3-3-1" class="outline-5">
<h5 id="sec-1-3-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-3-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">use</span> 'clojure.repl)
(<span class="org-variable-name">doc</span> mod)
(<span class="org-variable-name">doc</span> rem)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">rem</span> 10 -8)
</pre>
</div>

<pre class="example">
;;=&gt; 2
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">mod</span> 10 -8)
</pre>
</div>

<pre class="example">
;;=&gt; -6
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">Discovering Exceptions</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Using <b>find-doc</b>, find the function that prints the stack trace of the most recent REPL exception.
</p>
</div>

<div id="outline-container-sec-1-3-4-1" class="outline-5">
<h5 id="sec-1-3-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-3-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">find-doc</span> <span class="org-string">"stack trace"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">-------------------------</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.repl/pst</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">([] [e-or-depth] [e depth])</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">Prints a stack trace of the exception, to the</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">depth requested. If none supplied, uses the root</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">cause of the most recent repl exception (*e),</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">and a depth of 12.</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5">Creating &amp; Viewing Exceptions</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Evaluate an expression that throws an exception. Then print the stack trace of that exception.
</p>
</div>

<div id="outline-container-sec-1-3-5-1" class="outline-5">
<h5 id="sec-1-3-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-3-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">/</span> 1 0)
<span class="org-comment-delimiter">;; </span><span class="org-comment">ArithmeticException Divide by zero</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.lang.Numbers.divide (Numbers.java:156)</span>

(pst)
<span class="org-comment-delimiter">;; </span><span class="org-comment">ArithmeticException Divide by zero</span>
<span class="org-comment-delimiter">;;      </span><span class="org-comment">clojure.lang.Numbers.divide (Numbers.java:156)</span>
<span class="org-comment-delimiter">;;      </span><span class="org-comment">clojure.lang.Numbers.divide (Numbers.java:3677)</span>
<span class="org-comment-delimiter">;;      </span><span class="org-comment">user/eval15 (NO_SOURCE_FILE:4)</span>
<span class="org-comment-delimiter">;;      </span><span class="org-comment">...</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-4">
</div>

<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">Motivation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>Clojure is a functional language
</li>
<li>Functions are a first-class abstraction
<ul class="org-ul">
<li>Can be stored, passed as arguments, invoked
</li>
</ul>
</li>
<li>Ubiquitous support for high-order functions
</li>
<li>Core code (almost) entirely pure functions
<ul class="org-ul">
<li>i.e., no side-effects
</li>
</ul>
</li>
<li>The obvious place to start&#x2026;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">Creating Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-4-2">
</div><div id="outline-container-sec-1-4-2-1" class="outline-5">
<h5 id="sec-1-4-2-1"><code>defn</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-2-1">
<ul class="org-ul">
<li><code>defn</code> defines a named function
</li>
</ul>
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;    </span><span class="org-comment">name   params         body</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">-----  ------  -------------------</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">greet</span>  [name]  (<span class="org-variable-name">str</span> <span class="org-string">"Hello, "</span> name) )
</pre>
</div>

<ul class="org-ul">
<li>Invoke with the name in "function position"
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(greet <span class="org-string">"students"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Hello, students"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2-2" class="outline-5">
<h5 id="sec-1-4-2-2">Multi-arity functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-2-2">
<ul class="org-ul">
<li>Can overload function by <b>arity</b> (number of arguments)
</li>
<li>Each arity is a list <code>([<i style="font-family:serif">args*</i>] <i style="font-family:serif">body*</i>)</code>
</li>
<li>One arity can invoke another
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">messenger</span>
  ([]                             <span class="org-comment">; no args</span>
     (messenger <span class="org-string">"Hello world!"</span>))  <span class="org-comment">; call self with default</span>
  ([msg]              <span class="org-comment">; one arg</span>
     (<span class="org-variable-name">println</span> msg)))  <span class="org-comment">; print it</span>

(messenger)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello world!</span>
(messenger <span class="org-string">"Hello class!"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello class!</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2-3" class="outline-5">
<h5 id="sec-1-4-2-3">Variadic Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-2-3">
<ul class="org-ul">
<li><b>Variadic:</b> any number of arguments
</li>
<li>Specified by <code>&amp;</code> symbol in params 
<ul class="org-ul">
<li>Next param collects all remaining arguments
</li>
<li>Collected arguments represented as sequence
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">messenger</span> [greeting &amp; who]
  (<span class="org-variable-name">println</span> greeting who))

(messenger <span class="org-string">"Hello"</span> <span class="org-string">"world"</span> <span class="org-string">"class"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello (world class)</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-4-2-3-1" class="outline-6">
<h6 id="sec-1-4-2-3-1">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-1-4-2-3-1">
<ul class="org-ul">
<li>Sequences look and behave like lists
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2-4" class="outline-5">
<h5 id="sec-1-4-2-4">Anonymous Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-2-4">
<ul class="org-ul">
<li><code>fn</code> creates <i>anonymous</i> function with no name
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;      </span><span class="org-comment">params         body</span>
<span class="org-comment-delimiter">;;     </span><span class="org-comment">---------  ---------------</span>
  (<span class="org-variable-name">fn</span>  [message]  (<span class="org-variable-name">println</span> message) )
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2-5" class="outline-5">
<h5 id="sec-1-4-2-5">Invoking Anonymous Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-2-5">
<ul class="org-ul">
<li><code>(op ...)</code>
</li>
<li>Invoke a function with <code>fn</code> itself in function position
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;     </span><span class="org-comment">operation (function)             argument</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">--------------------------------  --------------</span>
(  (<span class="org-variable-name">fn</span> [message] (<span class="org-variable-name">println</span> message))  <span class="org-string">"Hello world!"</span> )

<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello world!</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-4-2-5-1" class="outline-6">
<h6 id="sec-1-4-2-5-1">Instructor notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-1-4-2-5-1">
<ul class="org-ul">
<li>Extra whitespace to show structure
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2-6" class="outline-5">
<h5 id="sec-1-4-2-6"><code>defn</code> and <code>fn</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-2-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">greet</span> [name] (<span class="org-variable-name">str</span> <span class="org-string">"Hello, "</span> name))

<span class="org-comment-delimiter">;; </span><span class="org-comment">is just a shortcut for</span>
(<span class="org-keyword">def</span> <span class="org-function-name">greet</span> (<span class="org-variable-name">fn</span> [name] (<span class="org-variable-name">str</span> <span class="org-string">"Hello, "</span> name)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2-7" class="outline-5">
<h5 id="sec-1-4-2-7">Function Reader Macro&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-2-7">
<ul class="org-ul">
<li>Terse form <code>#()</code> for short functions defined inline
<ul class="org-ul">
<li>Single argument: <code>%</code>
</li>
<li>Multiple arguments: <code>%1</code>, <code>%2</code>, <code>%3</code>, &#x2026;
</li>
<li>Variadic: <code>%&amp;</code> for remaining arguments
</li>
</ul>
</li>
<li>Can't nest
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">A function to add 6 to arg:</span>
#(<span class="org-variable-name">+</span> 6 %)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Equivalent to:</span>
(<span class="org-variable-name">fn</span> [x] (<span class="org-variable-name">+</span> 6 x))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2-8" class="outline-5">
<h5 id="sec-1-4-2-8">Function Reader Macro&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-2-8">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Wrong way to make a vector:</span>
#([%])

<span class="org-comment-delimiter">;; </span><span class="org-comment">Because it expands to:</span>
(<span class="org-variable-name">fn</span> [x] ([x]))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Which tries to invoke the vector.</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">What you really wanted:</span>
(<span class="org-variable-name">fn</span> [x]  [x])
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">Applying Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-4-3">
</div><div id="outline-container-sec-1-4-3-1" class="outline-5">
<h5 id="sec-1-4-3-1"><code>apply</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-3-1">
<ul class="org-ul">
<li>Invokes function on arguments
</li>
<li>Final argument is a sequence
</li>
<li>"Unpacks" remaining arguments from a sequence
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(f 1 2 3 4)                  <span class="org-comment-delimiter">;; </span><span class="org-comment">this calls f with args 1 2 3 4</span>

(<span class="org-variable-name">apply</span> f '(1 2 3 4))         <span class="org-comment-delimiter">;; </span><span class="org-comment">so does this</span>

(<span class="org-variable-name">apply</span> f 1 '(2 3 4))         <span class="org-comment-delimiter">;; </span><span class="org-comment">and so does this</span>

(<span class="org-variable-name">apply</span> f 1 2 '(3 4))         <span class="org-comment-delimiter">;; </span><span class="org-comment">and so does this</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-3-2" class="outline-5">
<h5 id="sec-1-4-3-2"><code>apply</code> and Variadics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-3-2">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">&amp; puts rest of args into sequence</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">messenger</span> [greeting &amp; who]
  <span class="org-comment-delimiter">;; </span><span class="org-comment">apply gets args from sequence</span>
  (<span class="org-variable-name">apply</span> println greeting who))

(messenger <span class="org-string">"Hello"</span> <span class="org-string">"world"</span> <span class="org-string">"class"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello world class</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-4-3-2-1" class="outline-6">
<h6 id="sec-1-4-3-2-1">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-1-4-3-2-1">
<ul class="org-ul">
<li>Similar to <code>*splat</code> in Ruby
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-3-3" class="outline-5">
<h5 id="sec-1-4-3-3">Partial Application&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-3-3">
<p>
Sometimes we want to "bake in" one or more arguments to a
new function call:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">x10</span> [&amp; nums]
  (<span class="org-variable-name">apply</span> * 10 nums))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-3-4" class="outline-5">
<h5 id="sec-1-4-3-4"><code>partial</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-3-4">
<ul class="org-ul">
<li><code>partial</code> - partially applies a function f with a subset of the args
</li>
<li>returns a new function that takes the remaining args and invokes with apply
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">*</span> 10 5)                      <span class="org-comment-delimiter">;; </span><span class="org-comment">50</span>

(<span class="org-keyword">def</span> <span class="org-function-name">x10</span> (<span class="org-variable-name">partial</span> * 10))

(x10 5)                       <span class="org-comment-delimiter">;; </span><span class="org-comment">50</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4">Locals and Closures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-4-4">
</div><div id="outline-container-sec-1-4-4-1" class="outline-5">
<h5 id="sec-1-4-4-1"><code>let</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-4-1">
<ul class="org-ul">
<li><code>let</code> binds <i>symbols</i> to immutable <i>values</i>
<ul class="org-ul">
<li>Values may be literals or expressions
</li>
</ul>
</li>
<li>Bound symbols are available in <i>lexical scope</i>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;      </span><span class="org-comment">bindings    code that uses name</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">------------  -------------------</span>
(<span class="org-builtin">let</span>  [name value]         ...        )
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-4-2" class="outline-5">
<h5 id="sec-1-4-4-2"><code>let</code> Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-4-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">messenger</span> [msg]
  (<span class="org-builtin">let</span> [a 7
        b 5
        c (capitalize msg)]
    (<span class="org-variable-name">println</span> a b c)
  )  <span class="org-comment">; end of 'let' scope</span>
)  <span class="org-comment">; end of function</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-4-4-2-1" class="outline-6">
<h6 id="sec-1-4-4-2-1">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-1-4-4-2-1">
<ul class="org-ul">
<li>Extra whitespace to show structure
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-4-3" class="outline-5">
<h5 id="sec-1-4-4-3">Closures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-4-3">
<ul class="org-ul">
<li><code>fn</code> creates a <i>closure</i>
<ul class="org-ul">
<li>"closes" over surrounding lexical scope
</li>
</ul>
</li>
<li>Closed-over locals persist beyond lexical scope
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">messenger-builder</span> [greeting]
  (<span class="org-variable-name">fn</span> [who] (<span class="org-variable-name">println</span> greeting who))) <span class="org-comment">; closes over greeting</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">greeting provided here, then goes out of scope</span>
(<span class="org-keyword">def</span> <span class="org-function-name">hello-er</span> (messenger-builder <span class="org-string">"Hello"</span>))

<span class="org-comment-delimiter">;; </span><span class="org-comment">greeting still available because hello-er is closure</span>
(hello-er <span class="org-string">"world!"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello world!</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5">Java Interop&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-4-5">
</div><div id="outline-container-sec-1-4-5-1" class="outline-5">
<h5 id="sec-1-4-5-1">Invoking Java Code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-5-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Task</th>
<th scope="col" class="left">Java</th>
<th scope="col" class="left">Clojure</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Instantiation</td>
<td class="left"><code>new Widget("foo")</code></td>
<td class="left"><code>(Widget. "foo")</code></td>
</tr>

<tr>
<td class="left">Instance method</td>
<td class="left"><code>rnd.nextInt()</code></td>
<td class="left"><code>(.nextInt rnd)</code></td>
</tr>

<tr>
<td class="left">Instance field</td>
<td class="left"><code>object.field</code></td>
<td class="left"><code>(.-field object)</code></td>
</tr>

<tr>
<td class="left">Static method</td>
<td class="left"><code>Math.sqrt(25)</code></td>
<td class="left"><code>(Math/sqrt 25)</code></td>
</tr>

<tr>
<td class="left">Static field</td>
<td class="left"><code>Math.PI</code></td>
<td class="left"><code>Math/PI</code></td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Note: <code>(.-field obj)</code> syntax added in Clojure 1.4
<ul class="org-ul">
<li>Previously was <code>(.field obj)</code> - still works with either
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-5-2" class="outline-5">
<h5 id="sec-1-4-5-2">Java Methods vs Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-4-5-2">
<ul class="org-ul">
<li>Java methods are not Clojure functions
</li>
<li>Can't store them, pass them as arguments
</li>
<li>Can wrap them in functions when necessary
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">make a function to invoke .length on arg</span>
(<span class="org-variable-name">fn</span> [obj] (<span class="org-preprocessor">.length</span> obj))

<span class="org-comment-delimiter">;; </span><span class="org-comment">same thing</span>
#(<span class="org-preprocessor">.length</span> %)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">LAB: Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-5">
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">Defining a function</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Define a function <code>greet</code> that takes no arguments and prints "Hello".
</p>
</div>

<div id="outline-container-sec-1-5-1-1" class="outline-5">
<h5 id="sec-1-5-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-1-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">greet</span> []
  (<span class="org-variable-name">println</span> <span class="org-string">"Hello"</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">Different ways to define functions</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
Redefine <code>greet</code> using <code>def</code>, first with the <code>fn</code> special form and then with the <code>#()</code> reader macro.
</p>
</div>

<div id="outline-container-sec-1-5-2-1" class="outline-5">
<h5 id="sec-1-5-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">greet</span> (<span class="org-variable-name">fn</span> [] (<span class="org-variable-name">println</span> <span class="org-string">"Hello"</span>)))

(<span class="org-keyword">def</span> <span class="org-function-name">greet</span> #(<span class="org-variable-name">println</span> <span class="org-string">"Hello"</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">Arities with defaults</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
Define a function <code>greeting</code> which:
</p>

<ul class="org-ul">
<li>Given no arguments, returns "Hello, World!"
</li>
<li>Given one argument <i>x</i>, returns "Hello, <i>x</i>!"
</li>
<li>Given two arguments <i>x</i> and <i>y</i>, returns "<i>x</i>, <i>y</i>!"
</li>
</ul>

<p>
Hint: use the <code>str</code> function to concatenate strings.
</p>
</div>

<div id="outline-container-sec-1-5-3-1" class="outline-5">
<h5 id="sec-1-5-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">greeting</span>
  ([] (greeting <span class="org-string">"Hello"</span> <span class="org-string">"World"</span>))
  ([x] (greeting <span class="org-string">"Hello"</span> x))
  ([x y] (<span class="org-variable-name">str</span> x <span class="org-string">", "</span> y <span class="org-string">"!"</span>)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-3-2" class="outline-5">
<h5 id="sec-1-5-3-2">Tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-3-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> <span class="org-string">"Hello, World!"</span> (greeting)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> <span class="org-string">"Hello, Clojure!"</span> (greeting <span class="org-string">"Clojure"</span>)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> <span class="org-string">"Good morning, Clojure!"</span>
           (greeting <span class="org-string">"Good morning"</span> <span class="org-string">"Clojure"</span>)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4">Do nothing</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
Define a function <code>do-nothing</code> which takes a single argument <code>x</code> and returns it, unchanged.
</p>
</div>

<div id="outline-container-sec-1-5-4-1" class="outline-5">
<h5 id="sec-1-5-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">do-nothing</span> [x] x)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-4-2" class="outline-5">
<h5 id="sec-1-5-4-2">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-4-2">
<p>
In Clojure, this is the <code>identity</code> function.
</p>

<p>
By itself, <code>identity</code> is not very useful, but it can be helpful when working with higher-order functions.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">identity</span>
  <span class="org-doc">"Returns its argument."</span>
  [x] x)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5">Do one thing well</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
Define a function <code>always-thing</code> which takes <i>any</i> number of arguments, ignores all of them, and returns the keyword <code>:thing</code>.
</p>
</div>

<div id="outline-container-sec-1-5-5-1" class="outline-5">
<h5 id="sec-1-5-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">always-thing</span> [&amp; args] <span class="org-constant">:thing</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-6" class="outline-4">
<h4 id="sec-1-5-6">Do many things</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
Define a function <code>make-thingy</code> which takes a single argument <code>x</code>. It should return <i>another function</i> which takes <i>any</i> number of arguments and always returns <i>x</i>.
</p>
</div>

<div id="outline-container-sec-1-5-6-1" class="outline-5">
<h5 id="sec-1-5-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">make-thingy</span> [x]
  (<span class="org-variable-name">fn</span> [&amp; args] x))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-6-2" class="outline-5">
<h5 id="sec-1-5-6-2">Tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-6-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [n (<span class="org-variable-name">rand-int</span> <span class="org-preprocessor">Integer/MAX_VALUE</span>)
      f (make-thingy n)]
  (<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> n (f)))
  (<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> n (f <span class="org-constant">:foo</span>)))
  (<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> n (<span class="org-variable-name">apply</span> f <span class="org-constant">:foo</span> (<span class="org-variable-name">range</span>)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-6-3" class="outline-5">
<h5 id="sec-1-5-6-3">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-6-3">
<p>
In Clojure, this is the <code>constantly</code> function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">constantly</span>
  <span class="org-doc">"Returns a function that takes any number of arguments and returns x."</span>
  [x] (<span class="org-variable-name">fn</span> [&amp; args] x))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-7" class="outline-4">
<h4 id="sec-1-5-7">In triplicate</h4>
<div class="outline-text-4" id="text-1-5-7">
<p>
Define a function <code>triplicate</code> which takes another function and calls it three times, without any arguments.
</p>
</div>

<div id="outline-container-sec-1-5-7-1" class="outline-5">
<h5 id="sec-1-5-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">triplicate</span> [f]
  (f) (f) (f))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-8" class="outline-4">
<h4 id="sec-1-5-8">Do the opposite</h4>
<div class="outline-text-4" id="text-1-5-8">
<p>
Define a function <code>opposite</code> which takes a single argument <code>f</code>. It should return <i>another function</i> which takes <i>any number</i> of arguments, applies <code>f</code> on them, and then calls <code>not</code> on the result.
</p>

<p>
The <code>not</code> function in Clojure does logical negation.
</p>
</div>

<div id="outline-container-sec-1-5-8-1" class="outline-5">
<h5 id="sec-1-5-8-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-8-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">opposite</span> [f]
  (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">not</span> (<span class="org-variable-name">apply</span> f args))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-8-2" class="outline-5">
<h5 id="sec-1-5-8-2">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-8-2">
<p>
In Clojure, this is the <code>complement</code> function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">complement</span>
  <span class="org-doc">"Takes a fn f and returns a fn that takes the same arguments as f,</span>
<span class="org-doc">  has the same effects, if any, and returns the opposite truth value."</span>
  [f] 
  (<span class="org-variable-name">fn</span> 
    ([] (<span class="org-variable-name">not</span> (f)))
    ([x] (<span class="org-variable-name">not</span> (f x)))
    ([x y] (<span class="org-variable-name">not</span> (f x y)))
    ([x y &amp; zs] (<span class="org-variable-name">not</span> (<span class="org-variable-name">apply</span> f x y zs)))))
</pre>
</div>

<p>
Many functions in <code>clojure.core</code> have multiple arities as a performance optimization.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-9" class="outline-4">
<h4 id="sec-1-5-9">In triplicate redux</h4>
<div class="outline-text-4" id="text-1-5-9">
<p>
Define a function <code>triplicate2</code> which takes another function and any number of arguments, then calls that function three times on those arguments. Re-use the function you defined in the earlier "Triplicate" exercise.
</p>
</div>

<div id="outline-container-sec-1-5-9-1" class="outline-5">
<h5 id="sec-1-5-9-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-9-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">triplicate2</span> [f &amp; args]
  (triplicate (<span class="org-variable-name">fn</span> [] (<span class="org-variable-name">apply</span> f args))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-10" class="outline-4">
<h4 id="sec-1-5-10">Squaring the circle</h4>
<div class="outline-text-4" id="text-1-5-10">
<p>
Using the <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html">java.lang.Math</a> class, demonstrate the following mathematical facts:
</p>

<ul class="org-ul">
<li>The cosine of Pi is -1
</li>
<li>For some <i>x</i>, sin(x) ^ 2 + cos(x) ^ 2 = 1
</li>
</ul>
</div>

<div id="outline-container-sec-1-5-10-1" class="outline-5">
<h5 id="sec-1-5-10-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-10-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-preprocessor">Math/cos</span> <span class="org-preprocessor">Math/PI</span>)
</pre>
</div>

<pre class="example">
;;=&gt; -1.0
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">+</span> (<span class="org-preprocessor">Math/pow</span> (<span class="org-preprocessor">Math/sin</span> <span class="org-preprocessor">Math/PI</span>) 2)
   (<span class="org-preprocessor">Math/pow</span> (<span class="org-preprocessor">Math/cos</span> <span class="org-preprocessor">Math/PI</span>) 2))
</pre>
</div>

<pre class="example">
;;=&gt; 1.0
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-11" class="outline-4">
<h4 id="sec-1-5-11">Go fetch</h4>
<div class="outline-text-4" id="text-1-5-11">
<p>
Define a function that takes an HTTP URL as a string, fetches that URL from the web, and returns the content as a string.
</p>

<p>
Hint: Using the <a href="http://docs.oracle.com/javase/7/docs/api/java/net/URL.html">java.net.URL</a> class and its <code>openStream</code> method. Then use the Clojure <code>slurp</code> function to get the content as a string.
</p>
</div>

<div id="outline-container-sec-1-5-11-1" class="outline-5">
<h5 id="sec-1-5-11-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-11-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">http-get</span> [url]
  (<span class="org-variable-name">slurp</span> (<span class="org-preprocessor">.openStream</span> (<span class="org-preprocessor">java.net.URL.</span> url))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-11-2" class="outline-5">
<h5 id="sec-1-5-11-2">Tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-11-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assert</span> (<span class="org-preprocessor">.contains</span> (http-get <span class="org-string">"http://www.w3.org/"</span>) <span class="org-string">"html"</span>))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-11-3" class="outline-5">
<h5 id="sec-1-5-11-3">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-11-3">
<p>
In fact, the Clojure <code>slurp</code> function is all that is needed, because it interprets its argument as a URL first and, failing that, as a file name.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-12" class="outline-4">
<h4 id="sec-1-5-12">Getting into the Swing of things</h4>
<div class="outline-text-4" id="text-1-5-12">
<p>
Translate the following Java code into a single Clojure function <code>sample-app</code>. Don't worry if you aren't familiar with the Java Swing API: the point is to practice using interop forms.
</p>

<div class="org-src-container">

<pre class="src src-fundamental">import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class SampleApp {
    public static void main(String[] args) {
        JPanel panel = new JPanel();
        panel.setOpaque(true);

        JLabel label = new JLabel(<span class="org-string">"Click the button!"</span>);
        panel.add(label);

        JButton button = new JButton(<span class="org-string">"Go"</span>);
        panel.add(button);

        JFrame frame = new JFrame(<span class="org-string">"Sample Application"</span>);
        frame.setContentPane(panel);
        frame.setSize(300, 100);
        frame.setVisible(true);
    }
}
</pre>
</div>
</div>

<div id="outline-container-sec-1-5-12-1" class="outline-5">
<h5 id="sec-1-5-12-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-5-12-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">import</span> (javax.swing <span class="org-preprocessor">JLabel</span> <span class="org-preprocessor">JButton</span> <span class="org-preprocessor">JPanel</span> <span class="org-preprocessor">JFrame</span>))

(<span class="org-keyword">defn</span> <span class="org-function-name">sample-app</span> []
  (<span class="org-builtin">let</span> [label (<span class="org-preprocessor">JLabel.</span> <span class="org-string">"Click the button!"</span>)
        button (<span class="org-preprocessor">JButton.</span> <span class="org-string">"Go"</span>)
        panel (<span class="org-preprocessor">JPanel.</span>)
        frame (<span class="org-preprocessor">JFrame.</span> <span class="org-string">"Sample Application"</span>)]
    (<span class="org-preprocessor">.setOpaque</span> panel true)
    (<span class="org-preprocessor">.add</span> panel label)
    (<span class="org-preprocessor">.add</span> panel button)
    (<span class="org-preprocessor">.setContentPane</span> frame panel)
    (<span class="org-preprocessor">.setSize</span> frame 300 100)
    (<span class="org-preprocessor">.setVisible</span> frame true)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-13" class="outline-4">
<h4 id="sec-1-5-13">Bonus Questions</h4>
<div class="outline-text-4" id="text-1-5-13">
</div><div id="outline-container-sec-1-5-13-1" class="outline-5">
<h5 id="sec-1-5-13-1">Partial Function Application</h5>
<div class="outline-text-5" id="text-1-5-13-1">
<p>
Define a function <code>one-less-arg</code> that takes two arguments:
</p>

<ul class="org-ul">
<li><code>f</code>, a function
</li>
<li><code>x</code>, a value
</li>
</ul>

<p>
It returns <i>another function</i> which calls <code>f</code> on <code>x</code> plus any additional arguments.
</p>
</div>

<div id="outline-container-sec-1-5-13-1-1" class="outline-6">
<h6 id="sec-1-5-13-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-5-13-1-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">one-less-arg</span> [f x]
  (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f x args)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-13-1-2" class="outline-6">
<h6 id="sec-1-5-13-1-2">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-5-13-1-2">
<p>
In Clojure, the <code>partial</code> function is a more general version of this.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">partial</span>
  <span class="org-doc">"Takes a function f and fewer than the normal arguments to f, and</span>
<span class="org-doc">  returns a fn that takes a variable number of additional args. When</span>
<span class="org-doc">  called, the returned function calls f with args + additional args."</span>
  ([f arg1]
   (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f arg1 args)))
  ([f arg1 arg2]
   (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f arg1 arg2 args)))
  ([f arg1 arg2 arg3]
   (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f arg1 arg2 arg3 args)))
  ([f arg1 arg2 arg3 &amp; more]
   (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f arg1 arg2 arg3 (<span class="org-variable-name">concat</span> more args)))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-13-2" class="outline-5">
<h5 id="sec-1-5-13-2">Function Composition</h5>
<div class="outline-text-5" id="text-1-5-13-2">
<p>
Define a function <code>two-fns</code> which takes two functions as arguments, <code>f</code> and <code>g</code>.
It returns <i>another function</i> which takes <i>one</i> argument, calls <code>g</code> on it, then calls <code>f</code> on the result, and returns that.
</p>

<p>
That is, your function returns the <i>composition</i> of <code>f</code> and <code>g</code>.
</p>
</div>

<div id="outline-container-sec-1-5-13-2-1" class="outline-6">
<h6 id="sec-1-5-13-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-5-13-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">two-fns</span> [f g]
  (<span class="org-variable-name">fn</span> [x] (f (g x))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-13-2-2" class="outline-6">
<h6 id="sec-1-5-13-2-2">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-5-13-2-2">
<p>
In Clojure, the <code>comp</code> (for "composition") function is a more general version of this.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">comp</span>
  <span class="org-doc">"Takes a set of functions and returns a fn that is the composition</span>
<span class="org-doc">  of those fns.  The returned fn takes a variable number of args,</span>
<span class="org-doc">  applies the rightmost of fns to the args, the next</span>
<span class="org-doc">  fn (right-to-left) to the result, etc."</span>
  ([] identity)
  ([f] f)
  ([f g] 
     (<span class="org-variable-name">fn</span> 
       ([] (f (g)))
       ([x] (f (g x)))
       ([x y] (f (g x y)))
       ([x y z] (f (g x y z)))
       ([x y z &amp; args] (f (<span class="org-variable-name">apply</span> g x y z args)))))
  ([f g h] 
     (<span class="org-variable-name">fn</span> 
       ([] (f (g (h))))
       ([x] (f (g (h x))))
       ([x y] (f (g (h x y))))
       ([x y z] (f (g (h x y z))))
       ([x y z &amp; args] (f (g (<span class="org-variable-name">apply</span> h x y z args))))))
  ([f1 f2 f3 &amp; fs]
    (<span class="org-builtin">let</span> [fs (<span class="org-variable-name">reverse</span> (<span class="org-variable-name">list*</span> f1 f2 f3 fs))]
      (<span class="org-variable-name">fn</span> [&amp; args]
        (<span class="org-builtin">loop</span> [ret (<span class="org-variable-name">apply</span> (<span class="org-variable-name">first</span> fs) args) fs (<span class="org-variable-name">next</span> fs)]
          (<span class="org-builtin">if</span> fs
            (<span class="org-builtin">recur</span> ((<span class="org-variable-name">first</span> fs) ret) (<span class="org-variable-name">next</span> fs))
            ret))))))
</pre>
</div>

<p>
Don't worry about understanding the implementation of <code>comp</code> just yet.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-13-3" class="outline-5">
<h5 id="sec-1-5-13-3">Let over Lambda</h5>
<div class="outline-text-5" id="text-1-5-13-3">
<p>
Rewrite the following expression using <code>fn</code> instead of <code>let</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [x 5
      y 7]
  (<span class="org-variable-name">+</span> x y))
</pre>
</div>
</div>

<div id="outline-container-sec-1-5-13-3-1" class="outline-6">
<h6 id="sec-1-5-13-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-5-13-3-1">
<div class="org-src-container">

<pre class="src src-clojure">((<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">+</span> x y)) 5 7)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-13-3-2" class="outline-6">
<h6 id="sec-1-5-13-3-2">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-5-13-3-2">
<p>
The <code>let</code> special form is functionally equivalent to creating and invoking an anonymous function, but it is easier to read and more efficient.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-13-4" class="outline-5">
<h5 id="sec-1-5-13-4">Lots of Swinging to do</h5>
<div class="outline-text-5" id="text-1-5-13-4">
<p>
Rewrite your solution to the "Getting into the Swing of things" exercise without using <code>let</code>.
</p>

<p>
Hint: use Clojure's <code>doto</code> macro.
</p>
</div>

<div id="outline-container-sec-1-5-13-4-1" class="outline-6">
<h6 id="sec-1-5-13-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-5-13-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">import</span> (javax.swing <span class="org-preprocessor">JLabel</span> <span class="org-preprocessor">JButton</span> <span class="org-preprocessor">JPanel</span> <span class="org-preprocessor">JFrame</span>))

(<span class="org-keyword">defn</span> <span class="org-function-name">sample-app</span> []
  (<span class="org-builtin">doto</span> (<span class="org-preprocessor">JFrame.</span> <span class="org-string">"Sample Application"</span>)
    (<span class="org-preprocessor">.setContentPane</span> (<span class="org-builtin">doto</span> (<span class="org-preprocessor">JPanel.</span>)
                       (<span class="org-preprocessor">.setOpaque</span> true)
                       (<span class="org-preprocessor">.add</span> (<span class="org-preprocessor">JLabel.</span> <span class="org-string">"Click the button!"</span>))
                       (<span class="org-preprocessor">.add</span> (<span class="org-preprocessor">JButton.</span> <span class="org-string">"Go"</span>))))
    (<span class="org-preprocessor">.setSize</span> 300 100)
    (<span class="org-preprocessor">.setVisible</span> true)))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Flow Control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-6">
</div>

<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">Introduction</h4>
<div class="outline-text-4" id="text-1-6-1">
</div><div id="outline-container-sec-1-6-1-1" class="outline-5">
<h5 id="sec-1-6-1-1">Statements vs. Expressions in Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-1">
<ul class="org-ul">
<li>Expressions return values, statements do not
</li>
</ul>

<div class="org-src-container">

<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">"if" is a statement because it doesn't return a value:</span>
<span class="org-type">String</span> <span class="org-variable-name">s</span>;
<span class="org-keyword">if</span> (x &gt; 10) {
    s = <span class="org-string">"greater"</span>;
} <span class="org-keyword">else</span> {
    s = <span class="org-string">"greater or equal"</span>;
}
obj.someMethod(s);

<span class="org-comment-delimiter">// </span><span class="org-comment">Ternary operator is an expression; it returns a value:</span>
obj.someMethod(x &gt; 10 ? <span class="org-string">"greater"</span> : <span class="org-string">"greater or equal"</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-2" class="outline-5">
<h5 id="sec-1-6-1-2">Expressions in Clojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-2">
<ul class="org-ul">
<li>Everything in Clojure is an expression
<ul class="org-ul">
<li>Always returns a value
</li>
<li>A block of multiple expressions returns the last value
<ul class="org-ul">
<li>E.g., <code>let</code>, <code>do</code>, <code>fn</code>
</li>
</ul>
</li>
<li>Expressions exclusively for side-effects return <code>nil</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-1-3" class="outline-5">
<h5 id="sec-1-6-1-3">Flow Control Expressions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-3">
<ul class="org-ul">
<li>Flow control operators are expressions too
</li>
<li>Composable, can use them anywhere
<ul class="org-ul">
<li>Less duplicate code
</li>
<li>Fewer intermediate variables
</li>
</ul>
</li>
<li>Extensible, via macros
<ul class="org-ul">
<li>E.g., <code>when-let</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-1-4" class="outline-5">
<h5 id="sec-1-6-1-4"><code>if</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">even?</span> 2)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; true</span>

(<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> 2) <span class="org-string">"even"</span> <span class="org-string">"odd"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "even"</span>

(<span class="org-variable-name">str</span> <span class="org-string">"2 is "</span> (<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> 2) <span class="org-string">"even"</span> <span class="org-string">"odd"</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "2 is even"</span>

<span class="org-comment-delimiter">; </span><span class="org-comment">else-expression is optional</span>
(<span class="org-builtin">if</span> (<span class="org-variable-name">true?</span> false) <span class="org-string">"impossible!"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-5" class="outline-5">
<h5 id="sec-1-6-1-5">Truthiness&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">if</span> true <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :truthy</span>
(<span class="org-builtin">if</span> (<span class="org-preprocessor">Object.</span>) <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; objects are true</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :truthy</span>
(<span class="org-builtin">if</span> [] <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; empty collections are true</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :truthy</span>
(<span class="org-builtin">if</span> 0 <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; zero is true</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :truthy</span>

(<span class="org-builtin">if</span> false <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :falsey</span>
(<span class="org-builtin">if</span> nil <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; nil is false</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :falsey</span>
(<span class="org-builtin">if</span> (<span class="org-variable-name">seq</span> []) <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; seq on empty coll is nil</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :falsey</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-6" class="outline-5">
<h5 id="sec-1-6-1-6"><code>if</code> and <code>do</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-6">
<ul class="org-ul">
<li>Multiple expressions per branch
</li>
<li>Last value in branch returned
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> 5)
  (<span class="org-builtin">do</span> (<span class="org-variable-name">println</span> <span class="org-string">"even"</span>)
      true)
  (<span class="org-builtin">do</span> (<span class="org-variable-name">println</span> <span class="org-string">"odd"</span>)
      false))
<span class="org-comment-delimiter">;; </span><span class="org-comment">odd         ; printed</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; false     ; return value</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-7" class="outline-5">
<h5 id="sec-1-6-1-7"><code>when</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-7">
<ul class="org-ul">
<li>If condition is true, execute body
</li>
<li>Otherwise, return <code>nil</code>
</li>
<li>Shortcut for <code>(if test (do body))</code> with no "else"
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">when</span> condition
  ... body of expressions ...)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-8" class="outline-5">
<h5 id="sec-1-6-1-8"><code>cond</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-8">
<ul class="org-ul">
<li>Series of tests and expressions
</li>
<li><code>:else</code> expression is optional
<ul class="org-ul">
<li>Could be any truthy value, <code>:else</code> is standard
</li>
</ul>
</li>
<li>Returns <code>nil</code> if no match and no <code>:else</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">cond</span>
 test1 expression1
 test2 expression2
 ...
 <span class="org-constant">:else</span> else-expression)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-9" class="outline-5">
<h5 id="sec-1-6-1-9"><code>cond</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-9">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [x 5]
  (<span class="org-builtin">cond</span>
   (<span class="org-variable-name">&lt;</span> x 2) <span class="org-string">"x is less than 2"</span>
   (<span class="org-variable-name">&lt;</span> x 10) <span class="org-string">"x is less than 10"</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x is less than 10"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-10" class="outline-5">
<h5 id="sec-1-6-1-10"><code>cond</code> and <code>:else</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-10">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [x 11]
  (<span class="org-builtin">cond</span>
   (<span class="org-variable-name">&lt;</span> x 2)  <span class="org-string">"x is less than 2"</span>
   (<span class="org-variable-name">&lt;</span> x 10) <span class="org-string">"x is less than 10"</span>
   <span class="org-constant">:else</span>    <span class="org-string">"x is greater than or equal to 10"</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x is greater than or equal to 10"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-11" class="outline-5">
<h5 id="sec-1-6-1-11"><code>case</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-11">
<ul class="org-ul">
<li>Compare argument to test values in O(1) time
</li>
<li>Test values must be compile-time literals
(e.g. numbers, strings, keywords)
</li>
<li>Error if no match
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">foo</span> [x]
  (<span class="org-builtin">case</span> x
    5  <span class="org-string">"x is 5"</span>
    10 <span class="org-string">"x is 10"</span>))

(foo 10)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x is 10"</span>

(foo 11)  <span class="org-comment-delimiter">;; </span><span class="org-comment">ERROR</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-1-12" class="outline-5">
<h5 id="sec-1-6-1-12"><code>case</code> with else-expression&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-1-12">
<ul class="org-ul">
<li>With an odd number of expressions&#x2026;
</li>
<li>The last expression is the "else"
</li>
<li>Prevents error on no match
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">foo</span> [x]
  (<span class="org-builtin">case</span> x
    5  <span class="org-string">"x is 5"</span>
    10 <span class="org-string">"x is 10"</span>
    <span class="org-string">"x isn't 5 or 10"</span>))

(foo 5)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x is 5"</span>

(foo 11) <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x isn't 5 or 10"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">Iteration for Side Effects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-6-2">
</div><div id="outline-container-sec-1-6-2-1" class="outline-5">
<h5 id="sec-1-6-2-1"><code>dotimes</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-2-1">
<ul class="org-ul">
<li>Evaluate expression n times
</li>
<li>Returns <code>nil</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">dotimes</span> [i 3]
  (<span class="org-variable-name">println</span> i))
<span class="org-comment-delimiter">;; </span><span class="org-comment">0</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">2</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-2-2" class="outline-5">
<h5 id="sec-1-6-2-2"><code>doseq</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-2-2">
<ul class="org-ul">
<li>Iterates over a sequence
<ul class="org-ul">
<li>Similar to Java's for-each loop
</li>
</ul>
</li>
<li>If a lazy sequence, <code>doseq</code> forces evaluation
</li>
<li>Returns <code>nil</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doseq</span> [n (<span class="org-variable-name">range</span> 3)]
  (<span class="org-variable-name">println</span> n))
<span class="org-comment-delimiter">;; </span><span class="org-comment">0</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">2</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-2-3" class="outline-5">
<h5 id="sec-1-6-2-3"><code>doseq</code> with multiple bindings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-2-3">
<ul class="org-ul">
<li>Similar to nested foreach loops
</li>
<li>Processes all permutations of sequence content
</li>
<li>Returns <code>nil</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doseq</span> [letter [<span class="org-constant">:a</span> <span class="org-constant">:b</span>]
        number (<span class="org-variable-name">range</span> 3)]  <span class="org-comment">; list of 0,1,2</span>
  (<span class="org-variable-name">pr</span> [letter number]))
<span class="org-comment-delimiter">;; </span><span class="org-comment">[:a 0][:a 1][:a 2][:b 0][:b 1][:b 2]=&gt; nil</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3">Clojure's <code>for</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>List comprehension, NOT a for-loop
</li>
<li>Generator function for sequence permutation
</li>
<li>Bindings behave like <code>doseq</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">for</span> [letter [<span class="org-constant">:a</span> <span class="org-constant">:b</span>]
      number (<span class="org-variable-name">range</span> 3)]  <span class="org-comment">; list of 0,1,2</span>
  [letter number])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ([:a 0] [:a 1] [:a 2] [:b 0] [:b 1] [:b 2])</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-4" class="outline-4">
<h4 id="sec-1-6-4">Recursion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-6-4">
</div><div id="outline-container-sec-1-6-4-1" class="outline-5">
<h5 id="sec-1-6-4-1">Recursion and Iteration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-4-1">
<ul class="org-ul">
<li>Clojure provides <code>recur</code> and the sequence abstraction
</li>
<li><code>recur</code> is "classic" recursion
<ul class="org-ul">
<li>Closed to consumers, lower-level
</li>
</ul>
</li>
<li>Sequences represent iteration as values
<ul class="org-ul">
<li>Consumers can partially iterate
</li>
</ul>
</li>
<li>Reducers and Transducers represent iteration as function composition
<ul class="org-ul">
<li>More on Reducers (not covered here): <a href="https://clojure.org/reference/reducers">https://clojure.org/reference/reducers</a>
</li>
<li>More on Transducers later
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-4-2" class="outline-5">
<h5 id="sec-1-6-4-2"><code>loop</code> and <code>recur</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-4-2">
<ul class="org-ul">
<li>Functional looping construct
<ul class="org-ul">
<li><code>loop</code> defines bindings
</li>
<li><code>recur</code> re-executes <code>loop</code> with new bindings
</li>
</ul>
</li>
<li>Prefer higher-order library fns
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">loop</span> [i 0]
  (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;</span> i 10)
    (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> i))
    i)) <span class="org-comment">;=&gt; 10</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-4-3" class="outline-5">
<h5 id="sec-1-6-4-3"><code>defn</code> and <code>recur</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-4-3">
<ul class="org-ul">
<li>fn arguments are implicit <code>loop</code> bindings
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">increase</span> [i]
  (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;</span> i 10)
    (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> i))
    i))

(increase 1) <span class="org-comment">;=&gt; 10</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-4-4" class="outline-5">
<h5 id="sec-1-6-4-4"><code>recur</code> for recursion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-4-4">
<ul class="org-ul">
<li><code>recur</code> must be in "tail position"
<ul class="org-ul">
<li>The last expression in a branch
</li>
</ul>
</li>
<li><code>recur</code> must provide values for all bound symbols by position
<ul class="org-ul">
<li>Loop bindings
</li>
<li>defn/fn args
</li>
</ul>
</li>
<li>Recursion via <code>recur</code> does not consume stack
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-5" class="outline-4">
<h4 id="sec-1-6-5">Exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-6-5">
</div><div id="outline-container-sec-1-6-5-1" class="outline-5">
<h5 id="sec-1-6-5-1">Exception handling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-5-1">
<ul class="org-ul">
<li>try/catch/finally as in Java
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">try</span>
  (<span class="org-variable-name">/</span> 2 1)
  (<span class="org-builtin">catch</span> <span class="org-preprocessor">ArithmeticException</span> e
    <span class="org-string">"divide by zero"</span>)
  (<span class="org-builtin">finally</span>
   (<span class="org-variable-name">println</span> <span class="org-string">"cleanup"</span>)))
<span class="org-comment-delimiter">;; </span><span class="org-comment">cleanup</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-5-2" class="outline-5">
<h5 id="sec-1-6-5-2">Throwing exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-5-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">try</span>
  (<span class="org-builtin">throw</span> (<span class="org-preprocessor">Exception.</span> <span class="org-string">"something went wrong"</span>))
  (<span class="org-builtin">catch</span> <span class="org-preprocessor">Exception</span> e (<span class="org-preprocessor">.getMessage</span> e)))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "something went wrong"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-5-3" class="outline-5">
<h5 id="sec-1-6-5-3">Exceptions with Clojure data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-5-3">
<ul class="org-ul">
<li><code>ex-info</code> takes a message and a map
</li>
<li><code>ex-data</code> gets the map back out
<ul class="org-ul">
<li>Or <code>nil</code> if not created with <code>ex-info</code>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">try</span>
  (<span class="org-builtin">throw</span> (ex-info <span class="org-string">"There was a problem"</span> {<span class="org-constant">:detail</span> 42}))
  (<span class="org-builtin">catch</span> <span class="org-preprocessor">Exception</span> e
    (<span class="org-variable-name">prn</span> (<span class="org-constant">:detail</span> (ex-data e)))))
<span class="org-comment-delimiter">;; </span><span class="org-comment">42</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-5-4" class="outline-5">
<h5 id="sec-1-6-5-4"><code>with-open</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-6-5-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [f (clojure.java.io/writer <span class="org-string">"/tmp/new"</span>)]
  (<span class="org-builtin">try</span>
    (<span class="org-preprocessor">.write</span> f <span class="org-string">"some text"</span>)
    (<span class="org-builtin">finally</span>
      (<span class="org-preprocessor">.close</span> f))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Can be written:</span>
(<span class="org-builtin">with-open</span> [f (clojure.java.io/writer <span class="org-string">"/tmp/new"</span>)]
  (<span class="org-preprocessor">.write</span> f <span class="org-string">"some text"</span>))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">LAB: Flow Control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-7">
</div>

<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">I am thinking of a number</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
Let's play a number-guessing game. Define a function <code>check-guess</code> that takes two arguments:
</p>

<ul class="org-ul">
<li><code>secret</code>, the number the player is trying to guess
</li>
<li><code>guess</code>, the player's most recent guess
</li>
</ul>

<p>
The function should <b>return</b> a string:
</p>

<ul class="org-ul">
<li>"You win!" if the numbers are equal
</li>
<li>"Too low" if the guess is less than the secret
</li>
<li>"Too high" if the guess is greater than the secret
</li>
</ul>

<p>
Use only <code>if</code>, not <code>cond</code>.
</p>
</div>

<div id="outline-container-sec-1-7-1-1" class="outline-5">
<h5 id="sec-1-7-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-1-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">check-guess</span> [secret guess]
  (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> guess secret)
    <span class="org-string">"You win!"</span>
    (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;</span> guess secret)
      <span class="org-string">"Too low"</span>
      <span class="org-string">"Too high"</span>)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2">I am thinking of another number</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
Repeat the previous exercise using <code>cond</code> instead of <code>if</code>.
</p>
</div>

<div id="outline-container-sec-1-7-2-1" class="outline-5">
<h5 id="sec-1-7-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">check-guess</span> [secret guess]
  (<span class="org-builtin">cond</span> (<span class="org-variable-name">=</span> guess secret)
          <span class="org-string">"You win!"</span>
        (<span class="org-variable-name">&lt;</span> guess secret)
          <span class="org-string">"Too low"</span>
        <span class="org-constant">:else</span>
          <span class="org-string">"Too high"</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3">Triplicate redux</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
Define a function <code>triplicate</code> that takes a single argument, a function <code>f</code>, and calls that function three times. Use <code>dotimes</code>.
</p>

<p>
Test it with an anonymous function that prints <code>:hi</code>.
</p>
</div>

<div id="outline-container-sec-1-7-3-1" class="outline-5">
<h5 id="sec-1-7-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">triplicate</span> [f]
  (<span class="org-builtin">dotimes</span> [i 3]
    (f)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(triplicate #(<span class="org-variable-name">prn</span> <span class="org-constant">:hi</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-4" class="outline-4">
<h4 id="sec-1-7-4">Printing Numbers</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
Define a function <code>numbers</code> that takes a single argument <code>n</code> and prints all the numbers from <b>zero</b> to <b>n-1</b> (inclusive), one per line.
</p>
</div>

<div id="outline-container-sec-1-7-4-1" class="outline-5">
<h5 id="sec-1-7-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">numbers</span> [n]
  (<span class="org-builtin">dotimes</span> [i n]
    (<span class="org-variable-name">println</span> i)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-5" class="outline-4">
<h4 id="sec-1-7-5">Counting Numbers</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
Define a function <code>counting</code> that takes a single argument <code>n</code> and prints all the numbers from <b>one</b> to <code>n</code> (inclusive), one per line.
</p>

<p>
Hint: Use <code>doseq</code> and <code>range</code>.
</p>
</div>

<div id="outline-container-sec-1-7-5-1" class="outline-5">
<h5 id="sec-1-7-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">counting</span> [n]
  (<span class="org-builtin">doseq</span> [i (<span class="org-variable-name">range</span> 1 (<span class="org-variable-name">inc</span> n))]
    (<span class="org-variable-name">println</span> i)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-6" class="outline-4">
<h4 id="sec-1-7-6">Garage band</h4>
<div class="outline-text-4" id="text-1-7-6">
<p>
Let's start a band! Define a function <code>print-bands</code> that takes three arguments:
</p>

<ul class="org-ul">
<li><code>guitars</code>, a vector of guitarists' names
</li>
<li><code>basses</code>, a vector of bass players' names
</li>
<li><code>drums</code>, a vector of drummers' names
</li>
</ul>

<p>
The function should print all the possible 3-piece combinations you can make with those players, like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(print-bands [<span class="org-string">"Gary"</span> <span class="org-string">"Gus"</span>]
             [<span class="org-string">"Bill"</span> <span class="org-string">"Bob"</span> <span class="org-string">"Buster"</span>]
             [<span class="org-string">"Darrell"</span>])
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gary Bill Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gary Bob Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gary Buster Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gus Bill Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gus Bob Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gus Buster Darrell</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-7-6-1" class="outline-5">
<h5 id="sec-1-7-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">print-bands</span> [guitars basses drums]
  (<span class="org-builtin">doseq</span> [g guitars
          b basses
          d drums]
    (<span class="org-variable-name">println</span> g b d)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-7" class="outline-4">
<h4 id="sec-1-7-7">Return of the garage band</h4>
<div class="outline-text-4" id="text-1-7-7">
<p>
Define a function <code>all-bands</code> that takes the same arguments as <code>print-bands</code>, but instead of printing all the combinations it <b>returns</b> them in a sequence. Each item in the sequence should be a vector like <code>[guitarist bass drummer]</code>.
</p>

<p>
Hint: use <code>for</code>
</p>
</div>

<div id="outline-container-sec-1-7-7-1" class="outline-5">
<h5 id="sec-1-7-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">all-bands</span> [guitars basses drums]
  (<span class="org-builtin">for</span> [g guitars
        b basses
        d drums]
    [g b d]))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-8" class="outline-4">
<h4 id="sec-1-7-8">Fizzbuzz</h4>
<div class="outline-text-4" id="text-1-7-8">
<p>
It's everybody's favorite programming problem!  Define a function <code>fizzbuzz</code> that prints the numbers from 1 to 100 (inclusive), subject to the following rules:
</p>

<ul class="org-ul">
<li>If the number is a multiple of three, print "Fizz".
</li>
<li>If the number is a multiple of five, print "Buzz".
</li>
<li>If the number is a multiple of <b>both</b> three and five print "FizzBuzz".
</li>
<li>If the number is <b>not</b> a multiple of three or five, print the number.
</li>
</ul>

<p>
Hint: the <code>rem</code> function (short for "remainder") computes the remainder of dividing two numbers, like Java's <code>%</code> operator. Clojure also has a <code>zero?</code> function to test if a number is equal to zero.
</p>
</div>

<div id="outline-container-sec-1-7-8-1" class="outline-5">
<h5 id="sec-1-7-8-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-8-1">
<p>
There are infinitely many solutions to this problem. Here is the most straightforward. Remember that conditional expressions such as <code>cond</code> return a value. 
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">fizzbuzz</span> []
  (<span class="org-builtin">doseq</span> [i (<span class="org-variable-name">range</span> 1 101)]
    (<span class="org-variable-name">println</span> (<span class="org-builtin">cond</span> (<span class="org-builtin">and</span> (zero? (<span class="org-variable-name">rem</span> i 3))
                        (zero? (<span class="org-variable-name">rem</span> i 5)))
                     <span class="org-string">"FizzBuzz"</span>
                   (zero? (<span class="org-variable-name">rem</span> i 3))
                     <span class="org-string">"Fizz"</span>
                   (zero? (<span class="org-variable-name">rem</span> i 5))
                     <span class="org-string">"Buzz"</span>
                   <span class="org-constant">:else</span> i))))
</pre>
</div>

<p>
If you want to avoid repeating the <code>rem</code> operation, here's one way to do it:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">fizzbuzz</span> []
  (<span class="org-builtin">doseq</span> [i (<span class="org-variable-name">range</span> 1 101)]
    (<span class="org-builtin">let</span> [fizz (<span class="org-builtin">if</span> (zero? (<span class="org-variable-name">rem</span> i 3)) <span class="org-string">"Fizz"</span>)
          buzz (<span class="org-builtin">if</span> (zero? (<span class="org-variable-name">rem</span> i 5)) <span class="org-string">"Buzz"</span>)
          number (<span class="org-builtin">if</span> (<span class="org-variable-name">not</span> (<span class="org-builtin">or</span> fizz buzz)) i)]
      (<span class="org-variable-name">println</span> (<span class="org-variable-name">str</span> fizz buzz number)))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-9" class="outline-4">
<h4 id="sec-1-7-9">Euclid's Algorithm</h4>
<div class="outline-text-4" id="text-1-7-9">
<p>
<a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid's Algorithm</a> finds the greatest common divisor of two integers using only subtraction. In imperative pseudo-code, it looks like this:
</p>

<pre class="example">
function gcd(A, B):
    do loop:
        if A == 0
            return B

        if B == 0
            return A

        if A &gt; B
            A := A - B
        else
            B := B - A
</pre>

<p>
Define a function <code>gcd</code> that implements Euclid's algorithm. Use <code>recur</code>.
</p>
</div>

<div id="outline-container-sec-1-7-9-1" class="outline-5">
<h5 id="sec-1-7-9-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-9-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">gcd</span> [a b]
  (<span class="org-builtin">cond</span> (zero? a) b
        (zero? b) a
        (<span class="org-variable-name">&gt;</span> a b)   (<span class="org-builtin">recur</span> (<span class="org-variable-name">-</span> a b) b)
        <span class="org-constant">:else</span>     (<span class="org-builtin">recur</span> a (<span class="org-variable-name">-</span> b a))))
</pre>
</div>

<p>
Some tests:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 1 (gcd 3 4)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 3 (gcd 3 6)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 3 (gcd 6 3)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 25 (gcd 100 25)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 4 (gcd 100 8)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 8 (gcd 16 24)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-10" class="outline-4">
<h4 id="sec-1-7-10">Bonus: I am thinking of a number</h4>
<div class="outline-text-4" id="text-1-7-10">
<p>
Define a function which <b>returns</b> another function to play the number-guessing game.
</p>

<p>
That is, define a function <code>guessing-game</code> that picks a random number and <b>returns</b> a function which takes a <b>single</b> argument, the player's guess. The returned function should return the same strings as in the first exercise.
</p>

<p>
Hint: Clojure's <code>rand-int</code> function returns a random integer.
</p>
</div>

<div id="outline-container-sec-1-7-10-1" class="outline-5">
<h5 id="sec-1-7-10-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-10-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">guessing-game</span> []
  (<span class="org-builtin">let</span> [secret (<span class="org-variable-name">rand-int</span> 100)]
    (<span class="org-variable-name">fn</span> [guess]
      (<span class="org-builtin">cond</span> (<span class="org-variable-name">=</span> guess secret)
              <span class="org-string">"You win!"</span>
            (<span class="org-variable-name">&lt;</span> guess secret)
              <span class="org-string">"Too low"</span>
            <span class="org-constant">:else</span>
              <span class="org-string">"Too high"</span>))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-11" class="outline-4">
<h4 id="sec-1-7-11">Bonus: Binary search</h4>
<div class="outline-text-4" id="text-1-7-11">
<p>
Use <code>loop</code> and <code>recur</code> to implement a binary search. Define a function <code>binary-search</code> that takes two arguments:
</p>

<ul class="org-ul">
<li><code>n</code>, a number
</li>
<li><code>nums</code>, a sorted vector of numbers
</li>
</ul>

<p>
The function should return <code>true</code> if <code>nums</code> contains <code>n</code> and <code>false</code> if it does not.
</p>
</div>

<div id="outline-container-sec-1-7-11-1" class="outline-5">
<h5 id="sec-1-7-11-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-7-11-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">binary-search</span> [n nums]
  (<span class="org-builtin">loop</span> [start 0
         end (<span class="org-variable-name">count</span> nums)]
    (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> start end)
      false
      (<span class="org-builtin">let</span> [index (<span class="org-variable-name">+</span> start (<span class="org-variable-name">int</span> (<span class="org-variable-name">/</span> (<span class="org-variable-name">-</span> end start) 2)))
            x (<span class="org-variable-name">nth</span> nums index)]
        (<span class="org-builtin">cond</span> (<span class="org-variable-name">=</span> n x) true
              (<span class="org-variable-name">&lt;</span> n x) (<span class="org-builtin">recur</span> start index)
              <span class="org-constant">:else</span>   (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> index) end))))))
</pre>
</div>

<p>
And some tests:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assert</span> (<span class="org-variable-name">false?</span> (binary-search 4 [1 3 5 7 9])))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">false?</span> (binary-search 11 [1 3 5 7 9])))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 7 [1 3 5 7 9])))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 1 [1 3 5 7 9])))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 9 [1 3 5 7 9])))

(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 54 (<span class="org-variable-name">range</span> 0 100 2))))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 98 (<span class="org-variable-name">range</span> 0 100 2))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Collections as Containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-8">
</div>

<div id="outline-container-sec-1-8-0-1" class="outline-5">
<h5 id="sec-1-8-0-1">Immutability&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-0-1">
<ul class="org-ul">
<li>Cannot "overwrite" or "update in-place"
</li>
<li>Never changes unexpectedly
</li>
<li>Simple values (numbers, strings) are immutable
</li>
<li>In Clojure, <i>compound</i> values are immutable too
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-0-2" class="outline-5">
<h5 id="sec-1-8-0-2">Data Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-0-2">
<div class="org-src-container">

<pre class="src src-clojure">#{42 <span class="org-string">"Bob"</span> 98.6 <span class="org-constant">:foo</span>}    <span class="org-comment">; Set</span>
[<span class="org-constant">:alpha</span> <span class="org-string">"beta"</span> 3.14]     <span class="org-comment">; Vector</span>
(1 2 3 4)                <span class="org-comment">; List</span>
{<span class="org-constant">:pi</span> 3.14159, <span class="org-string">"pie"</span> 3}   <span class="org-comment">; Map</span>
</pre>
</div>

<p>
"It is better to have 100 functions operate on one data structure than
to have 10 functions operate on 10 data structures." -Alan Perlis
</p>

<p>
<a href="http://clojure.org/cheatsheet">http://clojure.org/cheatsheet</a>
</p>
</div>
</div>
<div id="outline-container-sec-1-8-0-3" class="outline-5">
<h5 id="sec-1-8-0-3">Collection Use Cases&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-0-3">
<ul class="org-ul">
<li>Unordered containers: sets
</li>
<li>Ordered containers: vectors, lists
</li>
<li>Indexed data: maps, vectors
</li>
<li>Structured data: maps, records
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1">Collections as Containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-8-1">
<ul class="org-ul">
<li>You need to collect many elements
</li>
<li>Usually all the same "type"
</li>
<li>Choose collection type by the operations it supports efficiently
<ul class="org-ul">
<li>Set
</li>
<li>Vector
</li>
<li>List
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-1-8-1-1" class="outline-5">
<h5 id="sec-1-8-1-1">Common Functions for Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-1-1">
<div class="org-src-container">

<pre class="src src-clojure">count     - size of collection
conj      - <span class="org-string">"conjoin"</span> (add) a new value
into      - pour one collection into another

<span class="org-comment-delimiter">;; </span><span class="org-comment">Only for vectors and lists:</span>
peek      - retrieve the value at the insertion point
pop       - remove the value at the insertion point

<span class="org-comment-delimiter">;; </span><span class="org-comment">Only for sets:</span>
disj      - <span class="org-string">"disjoin"</span> (<span class="org-variable-name">remove</span>) a value
contains? - does this collection contain this key? 
clojure.set/union        - set union
clojure.set/intersection - set intersection
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-1-2" class="outline-5">
<h5 id="sec-1-8-1-2">Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-1-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">players</span> #{<span class="org-string">"Alice"</span> <span class="org-string">"Bob"</span> <span class="org-string">"Kelly"</span>})
</pre>
</div>

<ul class="org-ul">
<li>No order (but sorted sets are available)
</li>
<li>No duplicates
</li>
</ul>
</div>

<div id="outline-container-sec-1-8-1-2-1" class="outline-6">
<h6 id="sec-1-8-1-2-1">Uses for a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-2-1">
<ul class="org-ul">
<li>You just need a collection of stuff
</li>
<li>You don't care about order
</li>
<li>You need to efficiently check if something is in the collection
</li>
<li>You need to efficiently add or remove any item
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-1-2-2" class="outline-6">
<h6 id="sec-1-8-1-2-2">Add to a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-2-2">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> players <span class="org-string">"Una"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Una" "Bob" "Kelly"}
</pre>

<p>
Note original remains unchanged:
</p>

<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>
</div>
</div>
<div id="outline-container-sec-1-8-1-2-3" class="outline-6">
<h6 id="sec-1-8-1-2-3">Add Multiple Things to a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-2-3">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> players <span class="org-string">"Sal"</span> <span class="org-string">"Evan"</span> <span class="org-string">"Bob"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Evan" "Sal" "Kelly"}
</pre>

<p>
Note: "Bob" was already in the set, so no effect.
</p>
</div>
</div>
<div id="outline-container-sec-1-8-1-2-4" class="outline-6">
<h6 id="sec-1-8-1-2-4">Remove from a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-2-4">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">disj</span> players <span class="org-string">"Bob"</span> <span class="org-string">"Sal"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Kelly"}
</pre>

<p>
Note: "Sal" wasn't in the set, so no effect.
</p>
</div>
</div>
<div id="outline-container-sec-1-8-1-2-5" class="outline-6">
<h6 id="sec-1-8-1-2-5">Find if Set Contains Item&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-2-5">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">contains?</span> players <span class="org-string">"Kelly"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; true
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">contains?</span> players <span class="org-string">"Samwise"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; false
</pre>

<p>
Note: <code>contains?</code> doesn't work on vectors or lists.
</p>
</div>
</div>
<div id="outline-container-sec-1-8-1-2-6" class="outline-6">
<h6 id="sec-1-8-1-2-6">Sets are Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-2-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s</span> #{3 7 9})

<span class="org-comment-delimiter">;; </span><span class="org-comment">Returns the element if it's in the set:</span>
(s 7)   <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 7</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Returns nil otherwise:</span>
(s 20)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-1-3" class="outline-5">
<h5 id="sec-1-8-1-3">Sorted Sets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-1-3">
<ul class="org-ul">
<li>Preserves "natural" sort order of items
</li>
<li>Uses Clojure's <code>compare</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> (<span class="org-variable-name">sorted-set</span>) <span class="org-string">"Bravo"</span> <span class="org-string">"Charlie"</span> <span class="org-string">"Sigma"</span> <span class="org-string">"Alpha"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alpha" "Bravo" "Charlie" "Sigma"}
</pre>
</div>

<div id="outline-container-sec-1-8-1-3-1" class="outline-6">
<h6 id="sec-1-8-1-3-1">Sorted Set with Comparator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-3-1">
<p>
Provide your own <code>compare</code> function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">doc</span> compare)
</pre>
</div>

<pre class="example">
;; -------------------------
;; clojure.core/compare
;; ([x y])
;;   Comparator. Returns a negative number, zero, or a positive number
;;   when x is logically 'less than', 'equal to', or 'greater than'
;;   y. Same as Java x.compareTo(y) except it also works for nil, and
;;   compares numbers and collections in a type-independent manner. x
;;   must implement Comparable
;;=&gt; nil
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> (<span class="org-variable-name">sorted-set-by</span> (<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">-</span> (<span class="org-variable-name">compare</span> x y))))
      <span class="org-string">"Bravo"</span> <span class="org-string">"Charlie"</span> <span class="org-string">"Sigma"</span> <span class="org-string">"Alpha"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Sigma" "Charlie" "Bravo" "Alpha"}
</pre>

<p>
Note: If comparator says 2 elements are equal (it returns zero) then
one of them will be removed!
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sorted-set-by</span> (<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">compare</span> (<span class="org-constant">:age</span> x) (<span class="org-constant">:age</span> y)))
               {<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:age</span> 30}
               {<span class="org-constant">:name</span> <span class="org-string">"Kim"</span> <span class="org-constant">:age</span> 30}
               {<span class="org-constant">:name</span> <span class="org-string">"Foo"</span> <span class="org-constant">:age</span> 24})
</pre>
</div>

<pre class="example">
;;=&gt; #{{:age 24, :name "Foo"} {:age 30, :name "Bob"}}
</pre>

<p>
In general, first compare the thing you care about, then compare
what's left.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-1-4" class="outline-5">
<h5 id="sec-1-8-1-4">Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-1-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">callsigns</span> [<span class="org-string">"Alfa"</span> <span class="org-string">"Bravo"</span> <span class="org-string">"Charlie"</span>])
</pre>
</div>

<ul class="org-ul">
<li>Ordered
</li>
<li>Indexed by position
</li>
<li>Grows at the <b>tail</b> (end)
</li>
</ul>
</div>

<div id="outline-container-sec-1-8-1-4-1" class="outline-6">
<h6 id="sec-1-8-1-4-1">Uses for a Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-4-1">
<ul class="org-ul">
<li>You need to preserve some order of inputs
</li>
<li>You need efficient access to the <i>nth</i> item
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-1-4-2" class="outline-6">
<h6 id="sec-1-8-1-4-2">Add to a Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-4-2">
<div class="org-src-container">

<pre class="src src-clojure">callsigns
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo" "Charlie"]
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> callsigns <span class="org-string">"Delta"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo" "Charlie" "Delta"]
</pre>
</div>
</div>
<div id="outline-container-sec-1-8-1-4-3" class="outline-6">
<h6 id="sec-1-8-1-4-3">Get Nth Item&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-4-3">
<ul class="org-ul">
<li>Index starts at zero
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">callsigns
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo" "Charlie"]
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">nth</span> callsigns 2)  <span class="org-comment">; get 'third' item</span>
</pre>
</div>

<pre class="example">
;;=&gt; "Charlie"
</pre>
</div>
</div>
<div id="outline-container-sec-1-8-1-4-4" class="outline-6">
<h6 id="sec-1-8-1-4-4">Take Apart a Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-4-4">
<div class="org-src-container">

<pre class="src src-clojure">callsigns
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo" "Charlie"]
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">peek</span> callsigns)  <span class="org-comment">; get last item</span>
</pre>
</div>

<pre class="example">
;;=&gt; "Charlie"
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">pop</span> callsigns)  <span class="org-comment">; everything but last item</span>
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo"]
</pre>

<p>
Note: <code>peek</code> on a vector is more efficient than <code>last</code>.
</p>
</div>
</div>
<div id="outline-container-sec-1-8-1-4-5" class="outline-6">
<h6 id="sec-1-8-1-4-5">Vectors are Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-4-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">v</span> [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])

(v 2)   <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :c</span>

(v 10)  <span class="org-comment">;&gt; ERROR</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-1-5" class="outline-5">
<h5 id="sec-1-8-1-5">List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-1-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">cards</span> '(10 <span class="org-constant">:ace</span> <span class="org-constant">:jack</span> 9))
</pre>
</div>

<ul class="org-ul">
<li>Must <b>quote</b> in code
</li>
<li>Ordered
</li>
<li><b>Not</b> indexed
<ul class="org-ul">
<li>Just <code>first</code> and <code>rest</code>
</li>
<li>O(N) access to N'th element
</li>
</ul>
</li>
<li>Grows at the <b>head</b> (front)
</li>
</ul>
</div>

<div id="outline-container-sec-1-8-1-5-1" class="outline-6">
<h6 id="sec-1-8-1-5-1">Uses for a List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-5-1">
<ul class="org-ul">
<li>You need efficient access to the first element
</li>
<li>You need to efficiently remove ("pop") the first element off the list
</li>
<li>You need to preserve <b>reverse</b> order of inputs ("last in, first out")
</li>
<li>You need to simulate a stack
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-1-5-2" class="outline-6">
<h6 id="sec-1-8-1-5-2">Add to a List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-5-2">
<div class="org-src-container">

<pre class="src src-clojure">cards
</pre>
</div>

<pre class="example">
;;=&gt; (10 :ace :jack 9)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> cards <span class="org-constant">:queen</span>)
</pre>
</div>

<pre class="example">
;;=&gt; (:queen 10 :ace :jack 9)
</pre>
</div>
</div>
<div id="outline-container-sec-1-8-1-5-3" class="outline-6">
<h6 id="sec-1-8-1-5-3">Examine a List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-8-1-5-3">
<div class="org-src-container">

<pre class="src src-clojure">cards
</pre>
</div>

<pre class="example">
;;=&gt; (10 :ace :jack 9)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">first</span> cards)  <span class="org-comment">; get first item</span>
</pre>
</div>

<pre class="example">
;;=&gt; 10
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">rest</span> cards)   <span class="org-comment">; everything but first item</span>
</pre>
</div>

<pre class="example">
;;=&gt; (:ace :jack 9)
</pre>

<p>
Note: <code>peek</code> and <code>pop</code> on a list are the same as <code>first</code> and <code>rest</code>,
respectively.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-1-6" class="outline-5">
<h5 id="sec-1-8-1-6">Adding One Collection to Another&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-1-6">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">new-players</span> [<span class="org-string">"Tim"</span> <span class="org-string">"Sue"</span> <span class="org-string">"Grog"</span>])

(<span class="org-variable-name">into</span> players new-players)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Grog" "Sue" "Bob" "Tim" "Kelly"}
</pre>

<p>
Note: <code>into</code> returns a collection of the same type as its <b>first</b>
argument. Not the same as <code>concat</code>, see lazy sequences.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2">Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-8-2">
</div><div id="outline-container-sec-1-8-2-1" class="outline-5">
<h5 id="sec-1-8-2-1">Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-2-1">
<ul class="org-ul">
<li>Declarative way to pull apart compound data
<ul class="org-ul">
<li>vs. explicit, verbose access
</li>
</ul>
</li>
<li>Works for both sequential and associative data structures
</li>
<li>Nests for deep, arbitrary access
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-2-2" class="outline-5">
<h5 id="sec-1-8-2-2">Destructuring is Concise&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-2-2">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Without destructuring:</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">next-fib-pair</span> [pair]
  [(<span class="org-variable-name">second</span> pair) (<span class="org-variable-name">+</span> (<span class="org-variable-name">first</span> pair) (<span class="org-variable-name">second</span> pair))])

<span class="org-comment-delimiter">;; </span><span class="org-comment">With destructuring:</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">next-fib-pair</span> [[a b]]
  [b (<span class="org-variable-name">+</span> a b)])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-2-3" class="outline-5">
<h5 id="sec-1-8-2-3">Sequential Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-2-3">
<ul class="org-ul">
<li>Provide vector of symbols to bind by position
<ul class="org-ul">
<li>Binds to <code>nil</code> if there's no data
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">stuff</span> [7 8 9 10 11]) <span class="org-comment">;=&gt; #'user/stuff</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Bind a, b, c to first 3 values in stuff</span>
(<span class="org-builtin">let</span> [[a b c] stuff]
  (<span class="org-variable-name">list</span> (<span class="org-variable-name">+</span> a b) (<span class="org-variable-name">+</span> b c)))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (15 17)</span>

(<span class="org-builtin">let</span> [[a b c d e f] stuff]
  (<span class="org-variable-name">list</span> d e f))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (10 11 nil)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-2-4" class="outline-5">
<h5 id="sec-1-8-2-4">Sequential Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-2-4">
<ul class="org-ul">
<li>Can get "everything else" with <code>&amp;</code>
<ul class="org-ul">
<li>Value is a sequence
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">stuff</span> [7 8 9 10 11]) <span class="org-comment">;=&gt; #'user/stuff</span>

(<span class="org-builtin">let</span> [[a &amp; others] stuff]
  (<span class="org-variable-name">println</span> a)
  (<span class="org-variable-name">println</span> others))
<span class="org-comment-delimiter">;; </span><span class="org-comment">7</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">(8 9 10 11)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-2-5" class="outline-5">
<h5 id="sec-1-8-2-5">Where You Can Destructure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-2-5">
<ul class="org-ul">
<li>Destructuring works in <code>fn</code> and <code>defn</code> params, <code>let</code> bindings
<ul class="org-ul">
<li>And anything built on top of them
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3">Performance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-8-3">
</div><div id="outline-container-sec-1-8-3-1" class="outline-5">
<h5 id="sec-1-8-3-1">Persistent Data Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-3-1">
<ul class="org-ul">
<li>"Change" always creates new copy
</li>
<li>Old versions remain available
</li>
<li>All Clojure data structures are persistent
</li>
<li>Clojure does this efficiently
</li>
<li>Nothing to do with "persistent storage" on disk
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-3-2" class="outline-5">
<h5 id="sec-1-8-3-2">Example: Linked List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-3-2">

<div class="figure">
<p><img src="slide-assets/collections-linked-list-1.svg" alt="collections-linked-list-1.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-3-3" class="outline-5">
<h5 id="sec-1-8-3-3">Example: Linked List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-3-3">

<div class="figure">
<p><img src="slide-assets/collections-linked-list-2.svg" alt="collections-linked-list-2.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-3-4" class="outline-5">
<h5 id="sec-1-8-3-4">Example: Binary Tree&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-3-4">

<div class="figure">
<p><img src="slide-assets/collections-tree-1.svg" alt="collections-tree-1.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-3-5" class="outline-5">
<h5 id="sec-1-8-3-5">Example: Binary Tree&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-3-5">

<div class="figure">
<p><img src="slide-assets/collections-tree-2.svg" alt="collections-tree-2.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-3-6" class="outline-5">
<h5 id="sec-1-8-3-6">Example: Shared Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-3-6">

<div class="figure">
<p><img src="slide-assets/collections-structural-sharing.svg" alt="collections-structural-sharing.svg" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-4" class="outline-4">
<h4 id="sec-1-8-4">Choosing a Collection&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-8-4">
<ul class="org-ul">
<li>Each data structure operation has specific performance guarantees
</li>
<li>Most operations either <i>linear time</i> or <i>constant time</i>
</li>
<li>Choose data structure by operations you need
</li>
</ul>
</div>

<div id="outline-container-sec-1-8-4-1" class="outline-5">
<h5 id="sec-1-8-4-1">Linear Time&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-4-1">
<ul class="org-ul">
<li>O( <i>n</i> ) in size of collection
</li>
<li><code>nth</code> on lists
</li>
<li><code>last</code> on anything
</li>
<li>Almost anything using sequences
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-4-2" class="outline-5">
<h5 id="sec-1-8-4-2">Constant Time&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-4-2">
<ul class="org-ul">
<li>O(1)
</li>
<li><code>first</code>, <code>rest</code>, <code>peek</code>, <code>pop</code> on lists
</li>
<li><code>conj</code> on lists
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-4-3" class="outline-5">
<h5 id="sec-1-8-4-3">Near-Constant Time&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-4-3">
<ul class="org-ul">
<li>O(log <sub>32</sub> <i>n</i>)
<ul class="org-ul">
<li>Which is <b>really close</b> to O(1)
</li>
<li>And actually <b>is</b> O(1) for <i>n</i> &lt; 1 billion
</li>
</ul>
</li>
<li>Most operations on vectors, sets, &amp; maps
</li>
<li><code>nth</code> on vectors but not on lists
</li>
<li><code>peek</code> on vectors but not <code>last</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-4-4" class="outline-5">
<h5 id="sec-1-8-4-4">Summary&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-4-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">If you need&#x2026;</th>
<th scope="col" class="left">Then use&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Preserve input order</td>
<td class="left">vector</td>
</tr>

<tr>
<td class="left">Lookup by index</td>
<td class="left">vector</td>
</tr>

<tr>
<td class="left">"Does it contain X?"</td>
<td class="left">set</td>
</tr>

<tr>
<td class="left">Remove item</td>
<td class="left">set</td>
</tr>

<tr>
<td class="left">Sort order</td>
<td class="left">sorted set</td>
</tr>

<tr>
<td class="left">Last in, first out</td>
<td class="left">list</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-sec-1-8-4-5" class="outline-5">
<h5 id="sec-1-8-4-5">Review&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-8-4-5">
<ul class="org-ul">
<li>What function do you use to add an element to a collection?
</li>
<li>What function pours one collection into another?
</li>
<li>What function removes an element from a set?
</li>
<li>What does (contains? #{1 2} 1) return?
</li>
<li>What does (contains? [1 2] 2) return?
</li>
<li>How do you split [1 2 3] into 1 and (2 3)?
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">Collections as Indexes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-9">
</div>

<div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1">Collections as Indexes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-9-1">
<ul class="org-ul">
<li>You need to <b>associate</b> one type of stuff with another type of stuff
</li>
<li>"Given an X, find me its Y"
</li>
<li>Make a <b>mapping</b> from X's to Y's
</li>
<li>Use a map
</li>
</ul>
</div>

<div id="outline-container-sec-1-9-1-1" class="outline-5">
<h5 id="sec-1-9-1-1">Common Functions for Maps&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-1-1">
<div class="org-src-container">

<pre class="src src-clojure">assoc      - associate a new key-value mapping
dissoc     - dissociate a mapping by key
into       - pour one map into another
reduce     - apply a function to each mapping to accumulate result
keys       - sequence of map's keys
vals       - sequence of map's values
merge      - merge maps together
merge-with - merge maps and combine keys with fn
update-in  - update a value in nested map
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-1-2" class="outline-5">
<h5 id="sec-1-9-1-2">Map Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-1-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">scores</span> {<span class="org-string">"Una"</span> 1400
             <span class="org-string">"Bob"</span> 1240
             <span class="org-string">"Cid"</span> 1024})
</pre>
</div>
</div>

<div id="outline-container-sec-1-9-1-2-1" class="outline-6">
<h6 id="sec-1-9-1-2-1">Look Up in a Map&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-1">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get</span> scores <span class="org-string">"Cid"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; 1024
</pre>

<p>
Alternative:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(scores <span class="org-string">"Cid"</span>)   <span class="org-comment">; Note: error if scores is nil</span>
</pre>
</div>

<pre class="example">
;;=&gt; 1024
</pre>
</div>
</div>
<div id="outline-container-sec-1-9-1-2-2" class="outline-6">
<h6 id="sec-1-9-1-2-2">Look Up with Default&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-2">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get</span> scores <span class="org-string">"Samwise"</span> 0)
</pre>
</div>

<pre class="example">
;;=&gt; 0
</pre>

<p>
Alternative:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(scores <span class="org-string">"Samwise"</span> 0)   <span class="org-comment">; Note: error if scores is nil</span>
</pre>
</div>

<pre class="example">
;;=&gt; 0
</pre>
</div>
</div>
<div id="outline-container-sec-1-9-1-2-3" class="outline-6">
<h6 id="sec-1-9-1-2-3">Maps and Keywords are Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">m</span> {<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2})

<span class="org-comment-delimiter">;; </span><span class="org-comment">Maps are functions of their keys</span>
(m <span class="org-constant">:b</span>)       <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>
(m <span class="org-constant">:foo</span>)     <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
(m <span class="org-constant">:foo</span> 50)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 50    ; default</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Keywords are functions of maps</span>
(<span class="org-constant">:a</span> m)    <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-1-2-4" class="outline-6">
<h6 id="sec-1-9-1-2-4">Does the Map Contain Item&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-4">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">contains?</span> scores <span class="org-string">"Una"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; true
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">find</span> scores <span class="org-string">"Una"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; ["Una" 1400]
</pre>

<p>
Note: <code>contains?</code> only works on indexed collections.
</p>
<ul class="org-ul">
<li>sets, maps
</li>
<li>vectors are indexed, too!
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9-1-2-5" class="outline-6">
<h6 id="sec-1-9-1-2-5">Get Just Keys or Values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-5">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">keys</span> scores)
</pre>
</div>

<pre class="example">
;;=&gt; ("Una" "Bob" "Cid")
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">vals</span> scores)
</pre>
</div>

<pre class="example">
;;=&gt; (1400 1240 1024)
</pre>
</div>
</div>
<div id="outline-container-sec-1-9-1-2-6" class="outline-6">
<h6 id="sec-1-9-1-2-6">Building a Map&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-6">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">zipmap</span> players (<span class="org-variable-name">repeat</span> 0))
</pre>
</div>

<pre class="example">
;;=&gt; {"Kelly" 0, "Bob" 0, "Alice" 0}
</pre>

<p>
Alternative:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> {} (<span class="org-variable-name">map</span> (<span class="org-variable-name">fn</span> [player] [player 0]) players))
</pre>
</div>

<pre class="example">
;;=&gt; {"Alice" 0, "Bob" 0, "Kelly" 0}
</pre>

<p>
Note: this doesn't work:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> {} (<span class="org-variable-name">map</span> #([% 0]) players))
</pre>
</div>

<pre class="example">
;; ArityException Wrong number of args (0) passed to: PersistentVector  clojure.lang.AFn.throwArity (AFn.java:437)
</pre>
</div>
</div>
<div id="outline-container-sec-1-9-1-2-7" class="outline-6">
<h6 id="sec-1-9-1-2-7">Building a Map with <code>reduce</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-7">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [m player]
          (<span class="org-variable-name">assoc</span> m player 0))
        {}  <span class="org-comment">; initial value</span>
        players)
</pre>
</div>

<pre class="example">
;;=&gt; {"Kelly" 0, "Bob" 0, "Alice" 0}
</pre>
</div>
</div>
<div id="outline-container-sec-1-9-1-2-8" class="outline-6">
<h6 id="sec-1-9-1-2-8">Combining Maps&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-8">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">new-scores</span> {<span class="org-string">"Cid"</span> 300 <span class="org-string">"Baz"</span> 900})

(<span class="org-variable-name">merge</span> scores new-scores)
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Baz" 900, "Cid" 300}
</pre>

<p>
If both maps contain the same key, second one wins.
</p>
</div>
</div>
<div id="outline-container-sec-1-9-1-2-9" class="outline-6">
<h6 id="sec-1-9-1-2-9">Combining Maps with Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-2-9">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">new-scores</span> {<span class="org-string">"Una"</span> 550 <span class="org-string">"Cid"</span> 900 <span class="org-string">"Samwise"</span> 1000})

(<span class="org-variable-name">merge-with</span> + scores new-scores)
</pre>
</div>

<pre class="example">
;;=&gt; {"Samwise" 1000, "Una" 1950, "Bob" 1240, "Cid" 1924}
</pre>

<p>
If both maps contain the same <b>key</b>, call the function on both
<b>values</b> to get the new value.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-1-3" class="outline-5">
<h5 id="sec-1-9-1-3">Sorted Map&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-1-3">
<ul class="org-ul">
<li>Maintains <b>keys</b> in natural sort order
</li>
<li>Uses Clojure's <code>compare</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">sm</span> (<span class="org-variable-name">sorted-map</span>
         <span class="org-string">"Bravo"</span> 204
         <span class="org-string">"Alfa"</span> 35
         <span class="org-string">"Sigma"</span> 99
         <span class="org-string">"Charlie"</span> 100))

sm
</pre>
</div>

<pre class="example">
;;=&gt; {"Alfa" 35, "Bravo" 204, "Charlie" 100, "Sigma" 99}
</pre>
</div>

<div id="outline-container-sec-1-9-1-3-1" class="outline-6">
<h6 id="sec-1-9-1-3-1">Keys and Vals of Sorted Map&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-3-1">
<p>
<code>keys</code> and <code>vals</code> return in sorted order
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">keys</span> sm)
</pre>
</div>

<pre class="example">
;;=&gt; ("Alfa" "Bravo" "Charlie" "Sigma")
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">vals</span> sm)
</pre>
</div>

<pre class="example">
;;=&gt; (35 204 100 99)
</pre>
</div>
</div>
<div id="outline-container-sec-1-9-1-3-2" class="outline-6">
<h6 id="sec-1-9-1-3-2">Sorted Map with Comparator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-9-1-3-2">
<p>
Like <code>sorted-set-by</code>
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">smb</span> (<span class="org-variable-name">sorted-map-by</span> (<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">-</span> (<span class="org-variable-name">compare</span> x y)))
                        <span class="org-string">"Bravo"</span> 204
                        <span class="org-string">"Alfa"</span> 35
                        <span class="org-string">"Sigma"</span> 99
                        <span class="org-string">"Charlie"</span> 100))

smb
</pre>
</div>

<pre class="example">
;;=&gt; {"Sigma" 99, "Charlie" 100, "Bravo" 204, "Alfa" 35}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9-1-4" class="outline-5">
<h5 id="sec-1-9-1-4">Map Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-1-4">
<p>
{ } as left side of binding will initiate map destructuring
</p>

<ul class="org-ul">
<li>{new :old} - extracts :old from map and binds as new
</li>
<li>{:keys [a]} - extracts :a and binds as a
</li>
<li>{:syms [a b]} - extracts a and binds as a
</li>
<li>{:strs [a b]} - extracts "a" and binds as a
</li>
<li>{:as m} - binds entire map as m
</li>
<li>{:keys [a] :or {a 5}} - extracts :a if found and binds as a, else binds as 5
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9-1-5" class="outline-5">
<h5 id="sec-1-9-1-5">:keys example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-1-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">stuff</span> {<span class="org-constant">:a</span> 8 <span class="org-constant">:b</span> 9})

(<span class="org-builtin">let</span> [{<span class="org-constant">:keys</span> [a b c] <span class="org-constant">:or</span> {c 5} <span class="org-constant">:as</span> m} stuff]
  (<span class="org-variable-name">println</span> a b c m))
<span class="org-comment-delimiter">;; </span><span class="org-comment">8 9 5 {:a 8 :b 9}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-1-6" class="outline-5">
<h5 id="sec-1-9-1-6">Map Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-1-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">stuff</span> {<span class="org-constant">:a</span> 8 <span class="org-constant">:b</span> 9 <span class="org-constant">:c</span> 10})

(<span class="org-builtin">let</span> [{<span class="org-constant">:keys</span> [a b c]} stuff]
  (<span class="org-variable-name">println</span> a b c))
<span class="org-comment-delimiter">;; </span><span class="org-comment">8 9 10</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-1-7" class="outline-5">
<h5 id="sec-1-9-1-7">Named Arguments&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-1-7">
<ul class="org-ul">
<li>Applying vector of keys to <code>&amp;</code> binding emulates named args
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">game</span> [planet &amp; {<span class="org-constant">:keys</span> [human-players computer-players]}]
  (<span class="org-variable-name">println</span> <span class="org-string">"Total players: "</span> (<span class="org-variable-name">+</span> human-players computer-players)))

(game <span class="org-string">"Mars"</span> <span class="org-constant">:human-players</span> 1 <span class="org-constant">:computer-players</span> 2)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Total players: 3</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2">Transients&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-9-2">
</div><div id="outline-container-sec-1-9-2-1" class="outline-5">
<h5 id="sec-1-9-2-1">Fast Accumulation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-2-1">
<ul class="org-ul">
<li>Consider rapidly accumulating values into a collection
</li>
<li>Each new value creates a new persistent collection
</li>
<li>What if we could safely use mutation while we were accumulating,
then switch back to persistent collections?
</li>
<li>Supported with transient hash-sets, vectors, and hash-maps
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9-2-2" class="outline-5">
<h5 id="sec-1-9-2-2">Creating Transient Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-2-2">
<ul class="org-ul">
<li>Create from existing collection with <code>transient</code>
</li>
<li>O(1) time
</li>
<li>Original collection is still immutable
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9-2-3" class="outline-5">
<h5 id="sec-1-9-2-3">Using Transient Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-2-3">
<ul class="org-ul">
<li>Transient collection supports "read" methods - <code>get</code>, <code>nth</code>, etc
</li>
<li>Transient collection do not support "write" methods like <code>conj</code>,
  <code>assoc</code>, etc
</li>
<li>Instead use <code>conj!</code>, <code>assoc!</code>, etc
</li>
<li>Convert back with <code>persistent!</code> (also O(1))
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9-2-4" class="outline-5">
<h5 id="sec-1-9-2-4">Transient Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-2-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">vrange</span> [n]
  (<span class="org-builtin">loop</span> [i 0
         v (<span class="org-variable-name">transient</span> [])]
    (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;</span> i n)
      (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> i) (<span class="org-variable-name">conj!</span> v i))
      (<span class="org-variable-name">persistent!</span> v))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-3" class="outline-4">
<h4 id="sec-1-9-3">Map</h4>
<div class="outline-text-4" id="text-1-9-3">
</div><div id="outline-container-sec-1-9-3-1" class="outline-5">
<h5 id="sec-1-9-3-1">Review&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-9-3-1">
<ul class="org-ul">
<li>What are the keys in {:a 1 :b 2 :c 3} ?
</li>
<li>What are all the ways to get 1 from {:a 1}?
</li>
</ul>

<p>
Given:  (def m {:x 5})
</p>

<ul class="org-ul">
<li>How do we add a new mapping :y 10 to m?
</li>
<li>How do we get a modified m with :x mapped to 4?
</li>
<li>How do we remove the :x mapping from m?
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">LAB: Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-10">
</div>

<div id="outline-container-sec-1-10-1" class="outline-4">
<h4 id="sec-1-10-1">Building Collections</h4>
<div class="outline-text-4" id="text-1-10-1">
</div><div id="outline-container-sec-1-10-1-1" class="outline-5">
<h5 id="sec-1-10-1-1">Representing scores in a game</h5>
<div class="outline-text-5" id="text-1-10-1-1">
<p>
What collection would be best to represent a table of scores
(represented by a number) for players (represented by a string) in a
game?
</p>
</div>

<div id="outline-container-sec-1-10-1-1-1" class="outline-6">
<h6 id="sec-1-10-1-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-1-1-1">
<p>
This is an index of string to number and is best represented as a map.
</p>

<pre class="example">
{"Una" 1400
 "Bob" 1240
 "Cid" 1024}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-10-1-2" class="outline-5">
<h5 id="sec-1-10-1-2">Add a new player to the scores</h5>
<div class="outline-text-5" id="text-1-10-1-2">
<p>
Given a scores table:
</p>

<p>
<code>(def scores {"Una" 1400, "Bob" 1240, "Cid" 1024})</code>
</p>

<p>
write an expression that adds a new player "Mel" to the table.
</p>
</div>

<div id="outline-container-sec-1-10-1-2-1" class="outline-6">
<h6 id="sec-1-10-1-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-1-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assoc</span> scores <span class="org-string">"Mel"</span> 0)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-10-1-3" class="outline-5">
<h5 id="sec-1-10-1-3">Representing a player</h5>
<div class="outline-text-5" id="text-1-10-1-3">
<p>
How would you represent a player with the attributes <code>name</code> and <code>ranking</code>?
</p>
</div>

<div id="outline-container-sec-1-10-1-3-1" class="outline-6">
<h6 id="sec-1-10-1-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-1-3-1">
<p>
There are two reasonable answers: maps and records. A map would look
like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43}
</pre>
</div>

<p>
Given that we have known attributes representing an entity, it's also
reasonable to use a record:
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">define the record</span>
(<span class="org-keyword">defrecord</span> <span class="org-function-name">Player</span> [name ranking])

<span class="org-comment-delimiter">;; </span><span class="org-comment">define a player</span>
(-&gt;<span class="org-preprocessor">Player</span> <span class="org-string">"Una"</span> 43)
</pre>
</div>

<p>
For the rest of this lab, we'll stick with the map representation for
players as the examples are easier to read.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-10-1-4" class="outline-5">
<h5 id="sec-1-10-1-4">Retrieving the a player's ranking</h5>
<div class="outline-text-5" id="text-1-10-1-4">
<p>
Given either a map or record instance of a player like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43}
</pre>
</div>

<p>
What are three ways to retrieve the ranking given a player?
</p>
</div>

<div id="outline-container-sec-1-10-1-4-1" class="outline-6">
<h6 id="sec-1-10-1-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-1-4-1">
<p>
Here are three different ways to do a lookup of a keyword key in a
map:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get</span> player <span class="org-constant">:ranking</span>)
(player <span class="org-constant">:ranking</span>)
(<span class="org-constant">:ranking</span> player)
</pre>
</div>

<p>
The last option where the keyword is used as a function is the most
common usage.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-10-2" class="outline-4">
<h4 id="sec-1-10-2">Modifying Nested Collections</h4>
<div class="outline-text-4" id="text-1-10-2">
</div><div id="outline-container-sec-1-10-2-1" class="outline-5">
<h5 id="sec-1-10-2-1">Advance to the next round</h5>
<div class="outline-text-5" id="text-1-10-2-1">
<p>
A game's state is represented in a data structure like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">game</span>
  {<span class="org-constant">:round</span> 2
   <span class="org-constant">:players</span> #{{<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43}
              {<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:ranking</span> 77}
              {<span class="org-constant">:name</span> <span class="org-string">"Cid"</span> <span class="org-constant">:ranking</span> 33}}
   <span class="org-constant">:scores</span> {<span class="org-string">"Una"</span> 1400
            <span class="org-string">"Bob"</span> 1240
            <span class="org-string">"Cid"</span> 1024}})
</pre>
</div>

<p>
Write a function <code>next-round</code> that takes a game and returns it with
the round incremented.
</p>

<p>
<i>Note:</i> Clojure has a function <code>update-in</code> that applies a function to a
value in a nested associative structure and returns the updated map:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">update-in</span> {<span class="org-constant">:a</span> {<span class="org-constant">:b</span> 1}} [<span class="org-constant">:a</span> <span class="org-constant">:b</span>] inc)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {:a {:b 2}}</span>
</pre>
</div>

<p>
The <code>[:a :b]</code> vector is a series of keys that are applied from the
root of the map to locate the value that will be passed to the
function.
</p>
</div>

<div id="outline-container-sec-1-10-2-1-1" class="outline-6">
<h6 id="sec-1-10-2-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-2-1-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">next-round</span> [game]
  (<span class="org-variable-name">update-in</span> game [<span class="org-constant">:round</span>] inc))
</pre>
</div>

<p>
Example use:
</p>

<pre class="example">
(next-round game)
;; =&gt; {:round 3
;;     :players #{{:name "Una" :ranking 43}
;;                {:name "Bob" :ranking 77}
;;                {:name "Cid" :ranking 33}}
;;     :scores {"Una" 1400
;;              "Bob" 1240
;;              "Cid" 1024}}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-10-2-2" class="outline-5">
<h5 id="sec-1-10-2-2">Update the scores</h5>
<div class="outline-text-5" id="text-1-10-2-2">
<p>
Write a function <code>add-score</code> that increments a players score by a
specified amount.
</p>
</div>

<div id="outline-container-sec-1-10-2-2-1" class="outline-6">
<h6 id="sec-1-10-2-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-2-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-score</span> [game name score]
  (<span class="org-variable-name">update-in</span> game [<span class="org-constant">:scores</span> name] + score))
</pre>
</div>

<p>
Example:
</p>
<pre class="example">
(add-score game "Cid" 500)
;; =&gt; {:round 3
;;     :players #{{:name "Una" :ranking 43}
;;                {:name "Bob" :ranking 77}
;;                {:name "Cid" :ranking 33}}
;;     :scores {"Una" 1400
;;              "Bob" 1240
;;              "Cid" 1524}}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-10-2-3" class="outline-5">
<h5 id="sec-1-10-2-3">Add a new player</h5>
<div class="outline-text-5" id="text-1-10-2-3">
<p>
Write a function <code>add-player</code> that adds a new player and initializes
their score.
</p>
</div>

<div id="outline-container-sec-1-10-2-3-1" class="outline-6">
<h6 id="sec-1-10-2-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-2-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-player</span> [game name ranking]
  (<span class="org-variable-name">update-in</span> (<span class="org-variable-name">update-in</span> game [<span class="org-constant">:players</span>] conj {<span class="org-constant">:name</span> name <span class="org-constant">:ranking</span> ranking})
             [<span class="org-constant">:scores</span>] assoc name 0))
</pre>
</div>

<p>
or with the thread-first <code>-&gt;</code>: 
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-player</span> [game name ranking]
  (<span class="org-builtin">-&gt;</span> game
      (<span class="org-variable-name">update-in</span> [<span class="org-constant">:players</span>] conj {<span class="org-constant">:name</span> name <span class="org-constant">:ranking</span> ranking})
      (<span class="org-variable-name">update-in</span> [<span class="org-constant">:scores</span>] assoc name 0)))
</pre>
</div>

<p>
Example:
</p>
<pre class="example">
(add-player game "Mel" 24)
;; =&gt; {:round 3
;;     :players #{{:name "Una" :ranking 43}
;;                {:name "Bob" :ranking 77}
;;                {:name "Cid" :ranking 33}
;;                {:name "Mel" :ranking 24}}
;;     :scores {"Una" 1400
;;              "Bob" 1240
;;              "Cid" 1524
;;              "Mel" 0}}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-10-3" class="outline-4">
<h4 id="sec-1-10-3">Index Lookup</h4>
<div class="outline-text-4" id="text-1-10-3">
</div><div id="outline-container-sec-1-10-3-1" class="outline-5">
<h5 id="sec-1-10-3-1">Looking up a player</h5>
<div class="outline-text-5" id="text-1-10-3-1">
<p>
We'd like to be able to look up a player's ranking based on their
name. This is currently difficult. What data structure would make
this easier?
</p>
</div>

<div id="outline-container-sec-1-10-3-1-1" class="outline-6">
<h6 id="sec-1-10-3-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-3-1-1">
<p>
Currently player information is stored in a set and there is no way
to look up a player by name. Alternatively we could index the players
by name like we do with scores:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">game</span>
  {<span class="org-constant">:round</span> 2
   <span class="org-constant">:players</span> {<span class="org-string">"Una"</span> {<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43}
             <span class="org-string">"Bob"</span> {<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:ranking</span> 77}
             <span class="org-string">"Cid"</span> {<span class="org-constant">:name</span> <span class="org-string">"Cid"</span> <span class="org-constant">:ranking</span> 33}}
   <span class="org-constant">:scores</span> {<span class="org-string">"Una"</span> 1400
            <span class="org-string">"Bob"</span> 1240
            <span class="org-string">"Cid"</span> 1024}})
</pre>
</div>

<p>
Since we now have two maps with the same keys, it makes sense to
combine them into a single player index:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">game</span>
  {<span class="org-constant">:round</span> 2
   <span class="org-constant">:players</span> {<span class="org-string">"Una"</span> {<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43 <span class="org-constant">:score</span> 1400}
             <span class="org-string">"Bob"</span> {<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:ranking</span> 77 <span class="org-constant">:score</span> 1240}
             <span class="org-string">"Cid"</span> {<span class="org-constant">:name</span> <span class="org-string">"Cid"</span> <span class="org-constant">:ranking</span> 33 <span class="org-constant">:score</span> 1024}}})
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-10-3-2" class="outline-5">
<h5 id="sec-1-10-3-2">Find a player</h5>
<div class="outline-text-5" id="text-1-10-3-2">
<p>
Using the game definition defined in the prior section, how can we
implement <code>find-player</code> for a game?
</p>
</div>

<div id="outline-container-sec-1-10-3-2-1" class="outline-6">
<h6 id="sec-1-10-3-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-3-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">find-player</span> [game name]
  (<span class="org-variable-name">get-in</span> game [<span class="org-constant">:players</span> name]))
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(find-player game <span class="org-string">"Una"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; {:name "Una", :score 1400, :ranking 43}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-10-3-3" class="outline-5">
<h5 id="sec-1-10-3-3">Remove a player</h5>
<div class="outline-text-5" id="text-1-10-3-3">
<p>
Write a function <code>remove-player</code> that removes a player from a game,
including their score. 
</p>
</div>

<div id="outline-container-sec-1-10-3-3-1" class="outline-6">
<h6 id="sec-1-10-3-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-10-3-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">remove-player</span> [game name]
  (<span class="org-variable-name">update-in</span> game [<span class="org-constant">:players</span>] dissoc name))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">Collections as Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-11">
</div>

<div id="outline-container-sec-1-11-1" class="outline-4">
<h4 id="sec-1-11-1">Collections as Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-11-1">
<ul class="org-ul">
<li>Small set of named "fields"
</li>
<li>Field names known in advance
</li>
<li>Use a map
<ul class="org-ul">
<li>Keys are keywords
</li>
<li>Values are any type
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-1-11-1-1" class="outline-5">
<h5 id="sec-1-11-1-1">Common Functions for Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-1">
<div class="org-src-container">

<pre class="src src-clojure">assoc
assoc-in
dissoc
update-in
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-11-1-2" class="outline-5">
<h5 id="sec-1-11-1-2">Structured Data Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">person</span>
  {<span class="org-constant">:first-name</span> <span class="org-string">"Kelly"</span>
   <span class="org-constant">:last-name</span> <span class="org-string">"Keen"</span>
   <span class="org-constant">:age</span> 32
   <span class="org-constant">:occupation</span> <span class="org-string">"Programmer"</span>})
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-11-1-3" class="outline-5">
<h5 id="sec-1-11-1-3">Get Values Out of Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-3">
<ul class="org-ul">
<li>Use keywords as functions
<ul class="org-ul">
<li>When the map represents structured data
</li>
<li>And the keyword is a literal
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-constant">:occupation</span> person)
</pre>
</div>

<pre class="example">
;;=&gt; "Programmer"
</pre>
</div>
</div>
<div id="outline-container-sec-1-11-1-4" class="outline-5">
<h5 id="sec-1-11-1-4">Get Values With Default&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-4">
<div class="org-src-container">

<pre class="src src-clojure">(pprint person)
</pre>
</div>

<pre class="example">
;; {:age 32,
;;  :last-name "Keen",
;;  :first-name "Kelly",
;;  :occupation "Programmer"}
;;=&gt; nil
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-constant">:favorite-color</span> person <span class="org-string">"beige"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "beige"
</pre>
</div>
</div>
<div id="outline-container-sec-1-11-1-5" class="outline-5">
<h5 id="sec-1-11-1-5">"Change" a Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-5">
<div class="org-src-container">

<pre class="src src-clojure">(pprint (<span class="org-variable-name">assoc</span> person <span class="org-constant">:occupation</span> <span class="org-string">"Baker"</span>))
</pre>
</div>

<pre class="example">
;; {:age 32,
;;  :last-name "Keen",
;;  :first-name "Kelly",
;;  :occupation "Baker"}
;;=&gt; nil
</pre>

<p>
Note: original is unchanged
</p>

<div class="org-src-container">

<pre class="src src-clojure">(pprint person)
</pre>
</div>

<pre class="example">
;; {:age 32,
;;  :last-name "Keen",
;;  :first-name "Kelly",
;;  :occupation "Programmer"}
;;=&gt; nil
</pre>
</div>
</div>
<div id="outline-container-sec-1-11-1-6" class="outline-5">
<h5 id="sec-1-11-1-6">"Remove" a Key&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-6">
<div class="org-src-container">

<pre class="src src-clojure">(pprint (<span class="org-variable-name">dissoc</span> person <span class="org-constant">:age</span>))
</pre>
</div>

<pre class="example">
;; {:last-name "Keen",
;;  :first-name "Kelly",
;;  :occupation "Programmer"}
;;=&gt; nil
</pre>
</div>
</div>
<div id="outline-container-sec-1-11-1-7" class="outline-5">
<h5 id="sec-1-11-1-7">Nested Structure Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-7">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">company</span>
  {<span class="org-constant">:name</span> <span class="org-string">"WidgetCo"</span>
   <span class="org-constant">:address</span> {<span class="org-constant">:street</span> <span class="org-string">"123 Main St"</span>
             <span class="org-constant">:city</span> <span class="org-string">"Springfield"</span>
             <span class="org-constant">:state</span> <span class="org-string">"IL"</span>}})
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-11-1-8" class="outline-5">
<h5 id="sec-1-11-1-8">Reach Inside Nested Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-8">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get-in</span> company [<span class="org-constant">:address</span> <span class="org-constant">:city</span>])
</pre>
</div>

<pre class="example">
;;=&gt; "Springfield"
</pre>
</div>
</div>
<div id="outline-container-sec-1-11-1-9" class="outline-5">
<h5 id="sec-1-11-1-9">Thread-first For Nested Access&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-9">
<ul class="org-ul">
<li>"Thread-first"
</li>
<li>Invoke each step with the prior result as the first argument
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get</span> (<span class="org-variable-name">get</span> company <span class="org-constant">:address</span>) <span class="org-constant">:city</span>)
</pre>
</div>

<ul class="org-ul">
<li>Rewrite as:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">-&gt;</span> company <span class="org-constant">:address</span> <span class="org-constant">:city</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-11-1-10" class="outline-5">
<h5 id="sec-1-11-1-10">"Change" a Nested Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-10">
<div class="org-src-container">

<pre class="src src-clojure">(pprint (<span class="org-variable-name">assoc-in</span> company [<span class="org-constant">:address</span> <span class="org-constant">:street</span>] <span class="org-string">"303 Broadway"</span>))
</pre>
</div>

<pre class="example">
;; {:name "WidgetCo",
;;  :address
;;  {:state "IL",
;;   :city "Springfield",
;;   :street "303 Broadway"}}
;;=&gt; nil
</pre>
</div>
</div>
<div id="outline-container-sec-1-11-1-11" class="outline-5">
<h5 id="sec-1-11-1-11">Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-11">
<ul class="org-ul">
<li>Better performance
</li>
<li>Have named "type"
</li>
<li>Can have polymorphic behavior by implementing protocols
</li>
<li>Usage like maps
<ul class="org-ul">
<li>Different way of constructing
</li>
<li>Cannot be invoked like functions
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-11-1-12" class="outline-5">
<h5 id="sec-1-11-1-12">Constructing Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-12">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Person</span> [first-name last-name age occupation])

<span class="org-comment-delimiter">;; </span><span class="org-comment">Positional constructor - generated</span>
(<span class="org-keyword">def</span> <span class="org-function-name">kelly</span> (-&gt;<span class="org-preprocessor">Person</span> <span class="org-string">"Kelly"</span> <span class="org-string">"Keen"</span> 32 <span class="org-string">"Programmer"</span>))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Map constructor - generated</span>
(<span class="org-keyword">def</span> <span class="org-function-name">kelly</span> (map-&gt;<span class="org-preprocessor">Person</span>
             {<span class="org-constant">:first-name</span> <span class="org-string">"Kelly"</span>
              <span class="org-constant">:last-name</span> <span class="org-string">"Keen"</span>
              <span class="org-constant">:age</span> 32
              <span class="org-constant">:occupation</span> <span class="org-string">"Programmer"</span>}))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-11-1-13" class="outline-5">
<h5 id="sec-1-11-1-13">Record Literals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-1-13">
<div class="org-src-container">

<pre class="src src-clojure">#<span class="org-preprocessor">user.Foo</span>{<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2}   <span class="org-comment">; fields by name</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #user.Foo{:a 1, :b 2, :c nil}</span>

#<span class="org-preprocessor">user.Foo</span>[1 2 3]       <span class="org-comment">; fields by position</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #user.Foo{:a 1, :b 2, :c 3}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-11-2" class="outline-4">
<h4 id="sec-1-11-2">Data Structure Summary&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-11-2">
</div><div id="outline-container-sec-1-11-2-1" class="outline-5">
<h5 id="sec-1-11-2-1">Constructing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-2-1">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-preprocessor">Literal</span>              <span class="org-preprocessor">Constructor</span>            <span class="org-preprocessor">From</span> another collection

[1 2]                (<span class="org-variable-name">vector</span> 1 2)           (<span class="org-variable-name">vec</span> '(1 2))

#{1 2}               (<span class="org-variable-name">hash-set</span> 1 2)         (<span class="org-variable-name">set</span> [1 2])

'(1 2)               (<span class="org-variable-name">list</span> 1 2)             (<span class="org-variable-name">list*</span> [1 2])

{<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2}          (<span class="org-variable-name">array-map</span> <span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2)  (<span class="org-variable-name">apply</span> array-map [<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2])
                     (<span class="org-variable-name">hash-map</span> <span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2)   (<span class="org-variable-name">apply</span> hash-map [<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2])
                                            (<span class="org-variable-name">into</span> {} [[<span class="org-constant">:a</span> 1] [<span class="org-constant">:b</span> 2]])

#<span class="org-preprocessor">user.Foo</span>{<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2} (-&gt;<span class="org-preprocessor">Foo</span> 1 2)            (map-&gt;<span class="org-preprocessor">Foo</span> {<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2})
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-11-2-2" class="outline-5">
<h5 id="sec-1-11-2-2">Using&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-11-2-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Add Item</th>
<th scope="col" class="left">Get Item</th>
<th scope="col" class="left">Remove Item</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Vector</td>
<td class="left">conj</td>
<td class="left">nth, peek</td>
<td class="left">pop</td>
</tr>

<tr>
<td class="left">Set</td>
<td class="left">conj</td>
<td class="left">contains?</td>
<td class="left">disj</td>
</tr>

<tr>
<td class="left">List</td>
<td class="left">conj</td>
<td class="left">first, rest</td>
<td class="left">pop</td>
</tr>

<tr>
<td class="left">Map</td>
<td class="left">assoc, conj</td>
<td class="left">get</td>
<td class="left">dissoc</td>
</tr>

<tr>
<td class="left">Nested Maps</td>
<td class="left">assoc-in</td>
<td class="left">get-in</td>
<td class="left">update-in &amp; dissoc</td>
</tr>

<tr>
<td class="left">Record</td>
<td class="left">assoc</td>
<td class="left">get</td>
<td class="left">dissoc</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">LAB: Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-12">
</div>

<div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1">Structured Data</h4>
<div class="outline-text-4" id="text-1-12-1">
</div><div id="outline-container-sec-1-12-1-1" class="outline-5">
<h5 id="sec-1-12-1-1">Modeling a Course Catalog</h5>
<div class="outline-text-5" id="text-1-12-1-1">
<p>
Let's consider how to model a college course catalog. Create record
definitions representing the following domain types:
</p>

<ul class="org-ul">
<li>Course
<ul class="org-ul">
<li>course-id (ex: "ECON-101")
</li>
<li>name (ex: "Economics 101")
</li>
<li>prereqs - other course ids that are a prereq
</li>
<li>hours - credit hours this is worth (ex: 3)
</li>
</ul>
</li>

<li>Faculty
<ul class="org-ul">
<li>faculty-id (ex: "184826")
</li>
<li>first
</li>
<li>last
</li>
</ul>
</li>

<li>Offering
<ul class="org-ul">
<li>offering-id (ex: "123123")
</li>
<li>course - course id
</li>
<li>teacher - faculty id
</li>
<li>days - list of 2-char day of the week (Mo, Tu, &#x2026;)
</li>
<li>start-time - "9:00am"
</li>
<li>end-time - "10:00am"
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-1-12-1-1-1" class="outline-6">
<h6 id="sec-1-12-1-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-12-1-1-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Course</span> [course-id name prereqs hours])
(<span class="org-keyword">defrecord</span> <span class="org-function-name">Faculty</span> [faculty-id first last])
(<span class="org-keyword">defrecord</span> <span class="org-function-name">Offering</span> [offering-id course teacher days start-time end-time])
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-12-1-2" class="outline-5">
<h5 id="sec-1-12-1-2">Course catalog</h5>
<div class="outline-text-5" id="text-1-12-1-2">
<p>
We'll work with the following example data, each represented as a 
map, keyed by the id for the entity type.
</p>

<p>
You can use this to initialize your course catalog data:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">courses</span>
  {<span class="org-string">"CS-101"</span> (-&gt;<span class="org-preprocessor">Course</span> <span class="org-string">"CS-101"</span> <span class="org-string">"Comp Sci Concepts"</span> nil 2)
   <span class="org-string">"CS-110"</span> (-&gt;<span class="org-preprocessor">Course</span> <span class="org-string">"CS-110"</span> <span class="org-string">"Data Structures"</span> #{<span class="org-string">"CS-101"</span>} 3)
   <span class="org-string">"CS-120"</span> (-&gt;<span class="org-preprocessor">Course</span> <span class="org-string">"CS-120"</span> <span class="org-string">"Intro to Algorithms"</span> #{<span class="org-string">"CS-101"</span>} 3)
   <span class="org-string">"CS-220"</span> (-&gt;<span class="org-preprocessor">Course</span> <span class="org-string">"CS-220"</span> <span class="org-string">"Compilers"</span> #{<span class="org-string">"CS-110"</span> <span class="org-string">"CS-120"</span>} 4)})

(<span class="org-keyword">def</span> <span class="org-function-name">faculty</span>
  {138138 (-&gt;<span class="org-preprocessor">Faculty</span> 138138 <span class="org-string">"John"</span> <span class="org-string">"Stringbean"</span>)
   293843 (-&gt;<span class="org-preprocessor">Faculty</span> 293843 <span class="org-string">"Maya"</span> <span class="org-string">"Mayfair"</span>)
   234232 (-&gt;<span class="org-preprocessor">Faculty</span> 234232 <span class="org-string">"Emily"</span> <span class="org-string">"Surcher"</span>)})

(<span class="org-keyword">def</span> <span class="org-function-name">offerings</span>
  {230203 (-&gt;<span class="org-preprocessor">Offering</span> 230203 <span class="org-string">"CS-101"</span> 138138 [<span class="org-string">"Mo"</span>,<span class="org-string">"We"</span>,<span class="org-string">"Fr"</span>] <span class="org-string">"8:00am"</span> <span class="org-string">"8:50am"</span>)
   234109 (-&gt;<span class="org-preprocessor">Offering</span> 234109 <span class="org-string">"CS-110"</span> 293843 [<span class="org-string">"Mo"</span>,<span class="org-string">"We"</span>,<span class="org-string">"Fr"</span>] <span class="org-string">"10:00am"</span> <span class="org-string">"10:50am"</span>)
   934934 (-&gt;<span class="org-preprocessor">Offering</span> 934934 <span class="org-string">"CS-120"</span> 138138 [<span class="org-string">"Tu"</span>, <span class="org-string">"Th"</span>] <span class="org-string">"1:00pm"</span> <span class="org-string">"3:00pm"</span>)})

(<span class="org-keyword">def</span> <span class="org-function-name">catalog</span>
  {<span class="org-constant">:courses</span> courses
   <span class="org-constant">:faculty</span> faculty
   <span class="org-constant">:offerings</span> offerings})
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-12-1-3" class="outline-5">
<h5 id="sec-1-12-1-3">Adding a course</h5>
<div class="outline-text-5" id="text-1-12-1-3">
<p>
Write a function <code>add-course</code> that takes a catalog and a course
instance and returns a new catalog:
</p>
</div>

<div id="outline-container-sec-1-12-1-3-1" class="outline-6">
<h6 id="sec-1-12-1-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-12-1-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-course</span> [catalog course]
  (<span class="org-variable-name">assoc-in</span> catalog [<span class="org-constant">:courses</span> (<span class="org-constant">:course-id</span> course)] course))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-12-1-4" class="outline-5">
<h5 id="sec-1-12-1-4">Adding a faculty member</h5>
<div class="outline-text-5" id="text-1-12-1-4">
<p>
Write a function <code>add-faculty</code> that takes a catalog and a
faculty member instance and returns a new catalog:
</p>
</div>

<div id="outline-container-sec-1-12-1-4-1" class="outline-6">
<h6 id="sec-1-12-1-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-12-1-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-faculty</span> [catalog faculty]
  (<span class="org-variable-name">assoc-in</span> catalog [<span class="org-constant">:faculty</span> (<span class="org-constant">:faculty-id</span> faculty)] faculty))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-12-1-5" class="outline-5">
<h5 id="sec-1-12-1-5">Adding a course offering</h5>
<div class="outline-text-5" id="text-1-12-1-5">
<p>
Write a function <code>add-offering</code> that adds a new course offering
to the catalog.
</p>
</div>

<div id="outline-container-sec-1-12-1-5-1" class="outline-6">
<h6 id="sec-1-12-1-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-12-1-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-offering</span> [catalog offering]
  (<span class="org-variable-name">assoc-in</span> catalog [<span class="org-constant">:offerings</span> (<span class="org-constant">:offering-id</span> offering)] offering))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-12-1-6" class="outline-5">
<h5 id="sec-1-12-1-6">Offering to string</h5>
<div class="outline-text-5" id="text-1-12-1-6">
<p>
Write a function that takes a catalog and offering-id and returns a
formatted string as shown:
</p>

<pre class="example">
user&gt; (println (offer-&gt;str catalog 934934))
CS-120 Intro to Algorithms (3 hrs)
TuTh 1:00pm-3:00pm John Stringbean
Prereqs: CS-101
</pre>
</div>

<div id="outline-container-sec-1-12-1-6-1" class="outline-6">
<h6 id="sec-1-12-1-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-12-1-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">offer-&gt;str</span> [catalog offer-id]
  (<span class="org-builtin">let</span> [offering (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:offerings</span> offer-id])
        course-id (<span class="org-constant">:course</span> offering)
        course (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:courses</span> course-id])
        faculty (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:faculty</span> (<span class="org-constant">:teacher</span> offering)])
        prereqs (<span class="org-constant">:prereqs</span> course)
        reqstr (<span class="org-builtin">if</span> prereqs (clojure.string/<span class="org-type">join</span> <span class="org-string">", "</span> prereqs) <span class="org-string">"None"</span>)]
    (<span class="org-variable-name">format</span> <span class="org-string">"%s %s (%d hrs)\n%s %s-%s %s %s\nPrereqs: %s"</span>
      course-id (<span class="org-constant">:name</span> course) (<span class="org-constant">:hours</span> course) 
      (<span class="org-constant">:days</span> offering) (<span class="org-constant">:start-time</span> offering) (<span class="org-constant">:end-time</span> offering)
      (<span class="org-constant">:first</span> faculty) (<span class="org-constant">:last</span> faculty)
      reqstr)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">or a version relying on destructuring:</span>

(<span class="org-keyword">defn</span> <span class="org-function-name">offer-&gt;str</span> [catalog offer-id]
  (<span class="org-builtin">let</span> [{<span class="org-constant">:keys</span> [course teacher days start-time end-time]}
        (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:offerings</span> offer-id])

        {<span class="org-constant">:keys</span> [name hours prereqs]}
        (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:courses</span> course])

        {<span class="org-constant">:keys</span> [first last]}
        (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:faculty</span> teacher])

        reqstr 
        (<span class="org-builtin">if</span> prereqs (clojure.string/<span class="org-type">join</span> <span class="org-string">", "</span> prereqs) <span class="org-string">"None"</span>)]

    (<span class="org-variable-name">format</span> <span class="org-string">"%s %s (%d hrs)\n%s %s-%s %s %s\nPrereqs: %s"</span>
      course name hours days start-time end-time first last reqstr)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-12-1-7" class="outline-5">
<h5 id="sec-1-12-1-7">Bonus: Faculty course load</h5>
<div class="outline-text-5" id="text-1-12-1-7">
<p>
Note: This question and the next are best completed with sequence
functions like <code>map</code>, <code>filter</code>, and <code>reduce</code> which we will learn more
about in Sequences.
</p>

<p>
Write a function <code>faculty-hours</code> that takes a catalog and a
faculty-id and produces a count of the total course credit hours the
faculty member is teaching this semester. Example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">user&gt; (faculty-hours catalog 138138)
5
</pre>
</div>
</div>

<div id="outline-container-sec-1-12-1-7-1" class="outline-6">
<h6 id="sec-1-12-1-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-12-1-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">faculty-hours</span> [catalog faculty-id]
  (<span class="org-variable-name">reduce</span> + 0
    (<span class="org-variable-name">map</span> #(<span class="org-constant">:hours</span> (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:courses</span> (<span class="org-constant">:course</span> %)]))
      (<span class="org-variable-name">filter</span> #(<span class="org-variable-name">=</span> faculty-id (<span class="org-constant">:teacher</span> %))
        (<span class="org-variable-name">vals</span> (<span class="org-constant">:offerings</span> catalog))))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-12-1-8" class="outline-5">
<h5 id="sec-1-12-1-8">Bonus: Faculty course load report</h5>
<div class="outline-text-5" id="text-1-12-1-8">
<p>
Write a function using <code>faculty-hours</code> that reports the total number
of credit hours per faculty member for all faculty members as a map
from faculty-id to hours. For example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">user&gt; (faculty-load catalog)
{234232 0, 293843 3, 138138 5}
</pre>
</div>
</div>

<div id="outline-container-sec-1-12-1-8-1" class="outline-6">
<h6 id="sec-1-12-1-8-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-12-1-8-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">faculty-load</span> [catalog]
  (<span class="org-builtin">let</span> [ids (<span class="org-variable-name">keys</span> (<span class="org-constant">:faculty</span> catalog))]
    (<span class="org-variable-name">zipmap</span> ids 
            (<span class="org-variable-name">map</span> #(faculty-hours catalog %) ids))))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-13">
</div>

<div id="outline-container-sec-1-13-1" class="outline-4">
<h4 id="sec-1-13-1">Sequences Overview&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-13-1">
</div><div id="outline-container-sec-1-13-1-1" class="outline-5">
<h5 id="sec-1-13-1-1">Not Really a Data Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-1-1">
<p>
But it <b>looks</b> like a list when you print it.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span> 5)
</pre>
</div>

<pre class="example">
;;=&gt; (0 1 2 3 4)
</pre>

<p>
A list <b>is</b> a sequence (but a sequence is not necessarily a list).
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">seq?</span> (<span class="org-variable-name">list</span> <span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>))
</pre>
</div>

<pre class="example">
;;=&gt; true
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-1-2" class="outline-5">
<h5 id="sec-1-13-1-2">A Sequence is a Source of Values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-1-2">
<ul class="org-ul">
<li>In some order
<ul class="org-ul">
<li>Vector or list: same as collection order
</li>
<li>Map or set: arbitrary, but consistent
</li>
<li>Sorted map or set: in sort order
</li>
</ul>
</li>
<li>Sort of like Java <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html">Iterator</a> or Ruby <a href="http://www.ruby-doc.org/core-2.1.1/Enumerator.html">Enumerator</a>
</li>
<li>May be <b>lazy</b>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-13-1-3" class="outline-5">
<h5 id="sec-1-13-1-3">Partial Computation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-1-3">
<ul class="org-ul">
<li>Most sequence functions return another sequence
</li>
<li>Each sequence represents one step in the "job"
</li>
<li>Compose a "stack" of lazy sequence operations
</li>
<li>Consume the result non-lazily
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-2" class="outline-4">
<h4 id="sec-1-13-2">The Sequence Library: Generating&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-13-2">
</div><div id="outline-container-sec-1-13-2-1" class="outline-5">
<h5 id="sec-1-13-2-1">Generating a Sequence of Numbers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span> 10)
</pre>
</div>

<pre class="example">
;;=&gt; (0 1 2 3 4 5 6 7 8 9)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span> 40 45)
</pre>
</div>

<pre class="example">
;;=&gt; (40 41 42 43 44)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 1 2 3 4 ;... forever</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-2-2" class="outline-5">
<h5 id="sec-1-13-2-2">Sequence from Data Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-2-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">seq</span> [1 2 3])
</pre>
</div>

<pre class="example">
;;=&gt; (1 2 3)
</pre>

<ul class="org-ul">
<li><code>seq</code> gets a sequence from any data structure
</li>
<li>Also strings, Java arrays, and Iterable
</li>
<li>Every sequence function calls <code>seq</code> for you
</li>
<li>You rarely need to call <code>seq</code>, except to check for empty collection
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-2-3" class="outline-5">
<h5 id="sec-1-13-2-3"><code>seq</code> to Check for Empty&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-2-3">
<ul class="org-ul">
<li><code>seq</code> on empty collection returns <code>nil</code>
</li>
<li><code>nil</code> is logical false
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">if</span> (<span class="org-variable-name">seq</span> <span class="org-string">""</span>)
  <span class="org-constant">:not-empty</span>
  <span class="org-constant">:empty</span>)
</pre>
</div>

<pre class="example">
;;=&gt; :empty
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-2-4" class="outline-5">
<h5 id="sec-1-13-2-4">Sequence from String&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-2-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">seq</span> <span class="org-string">"Hello, World!"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; (\H \e \l \l \o \, \space \W \o \r \l \d \!)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">remove</span> #{\a \e \i \o \u} <span class="org-string">"Hello, World!"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; (\H \l \l \, \space \W \r \l \d \!)
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-2-5" class="outline-5">
<h5 id="sec-1-13-2-5">More Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-2-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">file-seq</td>
<td class="left">Files in directory</td>
</tr>

<tr>
<td class="left">line-seq</td>
<td class="left">Lines from java.io.BufferedReader</td>
</tr>

<tr>
<td class="left">re-seq</td>
<td class="left">Regex matches</td>
</tr>

<tr>
<td class="left">tree-seq</td>
<td class="left">Generic tree walker</td>
</tr>

<tr>
<td class="left">resultset-seq</td>
<td class="left">SQL query results</td>
</tr>

<tr>
<td class="left">xml-seq</td>
<td class="left">XML document nodes</td>
</tr>

<tr>
<td class="left">enumeration-seq</td>
<td class="left">Java Enumeration</td>
</tr>

<tr>
<td class="left">iterator-seq</td>
<td class="left">Java Iterator</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-3" class="outline-4">
<h4 id="sec-1-13-3">The Sequence Library: Operations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-13-3">
</div><div id="outline-container-sec-1-13-3-1" class="outline-5">
<h5 id="sec-1-13-3-1">Iterating Over a Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">map</span> (<span class="org-variable-name">fn</span> [n] (<span class="org-variable-name">long</span> (<span class="org-preprocessor">Math/pow</span> 2 n)))
     (<span class="org-variable-name">range</span> 9))
</pre>
</div>

<pre class="example">
;;=&gt; (1 2 4 8 16 32 64 128 256)
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-3-2" class="outline-5">
<h5 id="sec-1-13-3-2">Iterating Over Many Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">map</span> +
     [100 200 300 400 500]
     (<span class="org-variable-name">range</span> 1 999)
     [10 20 30])
</pre>
</div>

<pre class="example">
;;=&gt; (111 222 333)
</pre>

<p>
Note: stops at end of <b>shortest</b> sequence.
</p>
</div>
</div>
<div id="outline-container-sec-1-13-3-3" class="outline-5">
<h5 id="sec-1-13-3-3">Iterating with <code>for</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">for</span> [n (<span class="org-variable-name">range</span> 9)]
  (<span class="org-variable-name">long</span> (<span class="org-preprocessor">Math/pow</span> 2 n)))
</pre>
</div>

<pre class="example">
;;=&gt; (1 2 4 8 16 32 64 128 256)
</pre>

<p>
Note: Not an imperative for-loop; lazy like <code>map</code>.
</p>
</div>
</div>
<div id="outline-container-sec-1-13-3-4" class="outline-5">
<h5 id="sec-1-13-3-4">Nested Iteration with <code>for</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">for</span> [k [<span class="org-constant">:a</span> <span class="org-constant">:b</span>]
      n (<span class="org-variable-name">range</span> 1 4)]
  [k n])
</pre>
</div>

<pre class="example">
;;=&gt; ([:a 1] [:a 2] [:a 3] [:b 1] [:b 2] [:b 3])
</pre>

<p>
Note: different from <code>map</code> with multiple sequences.
</p>
</div>
</div>
<div id="outline-container-sec-1-13-3-5" class="outline-5">
<h5 id="sec-1-13-3-5">Shortening Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 3 (<span class="org-variable-name">range</span>)) <span class="org-comment">;=&gt; (0 1 2)</span>

(<span class="org-variable-name">drop</span> 3 (<span class="org-variable-name">range</span>)) <span class="org-comment">;=&gt; (3 4 5 ... infinite</span>

(<span class="org-variable-name">take-while</span> #(<span class="org-variable-name">&lt;</span> % 5) (<span class="org-variable-name">range</span>)) <span class="org-comment">;=&gt; (0 1 2 3 4)</span>

(<span class="org-variable-name">drop-while</span> #(<span class="org-variable-name">&lt;</span> % 5) (<span class="org-variable-name">range</span>)) <span class="org-comment">;=&gt; (5 6 7 8 ... infinite</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-3-6" class="outline-5">
<h5 id="sec-1-13-3-6">Taking Out Items&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">filter</span> even? (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; (0 2 4 6 8)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">remove</span> even? (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; (1 3 5 7 9)
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-3-7" class="outline-5">
<h5 id="sec-1-13-3-7">Grouping Elements of a Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-7">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">partition</span> 3 (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; ((0 1 2) (3 4 5) (6 7 8))
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(partition-all 3 (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; ((0 1 2) (3 4 5) (6 7 8) (9))
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(group-by (<span class="org-variable-name">fn</span> [n] (<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> n) <span class="org-constant">:even</span> <span class="org-constant">:odd</span>))
          (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; {:even [0 2 4 6 8], :odd [1 3 5 7 9]}
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-3-8" class="outline-5">
<h5 id="sec-1-13-3-8">Re-Ordering a Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-8">
</div><div id="outline-container-sec-1-13-3-8-1" class="outline-6">
<h6 id="sec-1-13-3-8-1"><code>sort</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-13-3-8-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sort</span> '(10 37 3 10 44 6))
</pre>
</div>

<pre class="example">
;;=&gt; (3 6 10 10 37 44)
</pre>

<p>
Note: <code>sort</code> is not lazy.
</p>
</div>
</div>
<div id="outline-container-sec-1-13-3-8-2" class="outline-6">
<h6 id="sec-1-13-3-8-2"><code>sort</code> with Comparator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-13-3-8-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sort</span> (<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">-</span> (<span class="org-variable-name">compare</span> x y))) '(10 37 3 10 44 6))
</pre>
</div>

<pre class="example">
;;=&gt; (44 37 10 10 6 3)
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-3-8-3" class="outline-6">
<h6 id="sec-1-13-3-8-3"><code>sort-by</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-13-3-8-3">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Note: not a comparator</span>
(<span class="org-variable-name">sort-by</span> <span class="org-constant">:name</span> [{<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:age</span> 33}
                {<span class="org-constant">:name</span> <span class="org-string">"Ali"</span> <span class="org-constant">:age</span> 39}
                {<span class="org-constant">:name</span> <span class="org-string">"Mel"</span> <span class="org-constant">:age</span> 22}
                {<span class="org-constant">:name</span> <span class="org-string">"Jim"</span> <span class="org-constant">:age</span> 58}])
</pre>
</div>

<pre class="example">
;;=&gt; ({:age 39, :name "Ali"} {:age 33, :name "Bob"} {:age 58, :name "Jim"} {:age 22, :name "Mel"})
</pre>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Note: not a comparator</span>
(<span class="org-variable-name">sort-by</span> <span class="org-constant">:age</span> [{<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:age</span> 33}
               {<span class="org-constant">:name</span> <span class="org-string">"Ali"</span> <span class="org-constant">:age</span> 39}
               {<span class="org-constant">:name</span> <span class="org-string">"Mel"</span> <span class="org-constant">:age</span> 22}
               {<span class="org-constant">:name</span> <span class="org-string">"Jim"</span> <span class="org-constant">:age</span> 58}])
</pre>
</div>

<pre class="example">
;;=&gt; ({:age 22, :name "Mel"} {:age 33, :name "Bob"} {:age 39, :name "Ali"} {:age 58, :name "Jim"})
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-3-8-4" class="outline-6">
<h6 id="sec-1-13-3-8-4"><code>shuffle</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-13-3-8-4">
<div class="org-src-container">

<pre class="src src-clojure">(shuffle (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; [9 3 4 2 6 1 0 5 8 7]
</pre>

<p>
Note: <code>shuffle</code> returns a vector, is not lazy.
</p>
</div>
</div>
<div id="outline-container-sec-1-13-3-8-5" class="outline-6">
<h6 id="sec-1-13-3-8-5"><code>reverse</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-1-13-3-8-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reverse</span> (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; (9 8 7 6 5 4 3 2 1 0)
</pre>

<p>
Note: <code>reverse</code> is not lazy.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-3-9" class="outline-5">
<h5 id="sec-1-13-3-9">Flattening Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-9">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">mapcat</span> (<span class="org-variable-name">fn</span> [i] (<span class="org-variable-name">range</span> i)) (<span class="org-variable-name">range</span> 7))
</pre>
</div>

<pre class="example">
;;=&gt; (0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">flatten</span> '(1 1 (2 3) (5 8 (13 21))))
</pre>
</div>

<pre class="example">
;;=&gt; (1 1 2 3 5 8 13 21)
</pre>

<p>
Note: <code>flatten</code> is usually a sign of poorly-constructed sequences.
Prefer <code>mapcat</code> where possible.
</p>
</div>
</div>
<div id="outline-container-sec-1-13-3-10" class="outline-5">
<h5 id="sec-1-13-3-10">Combining Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-10">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">concat</span> [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>] (<span class="org-variable-name">range</span> 5))
</pre>
</div>

<pre class="example">
;;=&gt; (:a :b :c 0 1 2 3 4)
</pre>

<p>
Note: Beware lazy "stacks".
</p>
</div>
</div>
<div id="outline-container-sec-1-13-3-11" class="outline-5">
<h5 id="sec-1-13-3-11">Utility Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-3-11">
<p>
Typically used in combination with <code>map</code> or <code>reduce</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">repeat</span> <span class="org-constant">:b</span>)     <span class="org-comment">;=&gt; (:b :b :b ... infinite</span>

(<span class="org-variable-name">repeatedly</span> #(<span class="org-variable-name">rand-int</span> 100))   <span class="org-comment">;=&gt; (89 58 73 ... infinite</span>

(<span class="org-variable-name">cycle</span> [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])  <span class="org-comment">;=&gt; (:a :b :c :a :b :c :a ... infinite</span>

(<span class="org-variable-name">interpose</span> \, <span class="org-string">"abc"</span>)  <span class="org-comment">;=&gt; (\a \, \b \, \c)</span>
(<span class="org-variable-name">apply</span> str *1)  <span class="org-comment">;=&gt; "a,b,c"</span>

(<span class="org-variable-name">interleave</span> [1 2 3] [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])  <span class="org-comment">;=&gt; (1 :a 2 :b 3 :c)</span>

(<span class="org-variable-name">iterate</span> #(<span class="org-variable-name">*</span> 2 %) 2)  <span class="org-comment">;=&gt; (2 4 8 16 ... infinite</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-4" class="outline-4">
<h4 id="sec-1-13-4">The Sequence Library: Results&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-13-4">
</div><div id="outline-container-sec-1-13-4-1" class="outline-5">
<h5 id="sec-1-13-4-1">Collecting Result of a Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">vec</span> (<span class="org-variable-name">filter</span> even? (<span class="org-variable-name">range</span> 10)))
</pre>
</div>

<pre class="example">
;;=&gt; [0 2 4 6 8]
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">set</span> (<span class="org-variable-name">map</span> inc (<span class="org-variable-name">range</span> 10)))
</pre>
</div>

<pre class="example">
;;=&gt; #{1 2 3 4 5 6 7 8 9 10}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">apply</span> hash-map (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; {0 1, 2 3, 4 5, 6 7, 8 9}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">apply</span> str (<span class="org-variable-name">interpose</span> \, (<span class="org-variable-name">range</span> 4)))
</pre>
</div>

<pre class="example">
;;=&gt; "0,1,2,3"
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-4-2" class="outline-5">
<h5 id="sec-1-13-4-2">Seqs <code>into</code> Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-4-2">
<ul class="org-ul">
<li><code>(into <i style="font-family:serif">coll</i> <i style="font-family:serif">seq</i>)</code>
</li>
<li>Adds elements of <i>seq</i> to <i>coll</i> using <code>conj</code>
</li>
<li>"Pours" <i>seq</i> into <i>coll</i>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> #{} <span class="org-string">"hello"</span>)        <span class="org-comment">;=&gt; #{\e \h \l \o}</span>

(<span class="org-variable-name">into</span> {} [[<span class="org-constant">:x</span> 1] [<span class="org-constant">:y</span> 2]]) <span class="org-comment">;=&gt; {:x 1, :y 2}</span>

(<span class="org-variable-name">into</span> () [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])      <span class="org-comment">;=&gt; (:c :b :a)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-4-3" class="outline-5">
<h5 id="sec-1-13-4-3">Consuming a Sequence for Side Effects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-4-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doseq</span> [i (<span class="org-variable-name">range</span> 5)]
  (<span class="org-variable-name">prn</span> i))
</pre>
</div>

<pre class="example">
;; 0
;; 1
;; 2
;; 3
;; 4
;;=&gt; nil
</pre>

<p>
Note: <code>doseq</code> always returns <code>nil</code>
</p>
</div>
</div>
<div id="outline-container-sec-1-13-4-4" class="outline-5">
<h5 id="sec-1-13-4-4"><code>doseq</code> Over Many Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-4-4">
<p>
Creates nested iteration like <code>for</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doseq</span> [c [<span class="org-constant">:a</span> <span class="org-constant">:b</span>]
        i (<span class="org-variable-name">range</span> 3)]
  (<span class="org-variable-name">prn</span> c i))
</pre>
</div>

<pre class="example">
;; :a 0
;; :a 1
;; :a 2
;; :b 0
;; :b 1
;; :b 2
;;=&gt; nil
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-4-5" class="outline-5">
<h5 id="sec-1-13-4-5"><code>reduce</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-4-5">
<ul class="org-ul">
<li><code>(reduce <i style="font-family:serif">function</i> <i style="font-family:serif">init</i> <i style="font-family:serif">seq</i>)</code>
</li>
<li><i>function</i> takes two arguments
<ul class="org-ul">
<li><code>reduce</code> calls <code>(<i style="font-family:serif">function</i> <i style="font-family:serif">init</i> (first <i style="font-family:serif">seq</i>))</code>
</li>
<li>Return value becomes <i>init</i> for the next step
</li>
</ul>
</li>
<li>Repeat until the end of the seq, return last init
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [total item] (<span class="org-variable-name">+</span> total (<span class="org-variable-name">*</span> 10 item)))
        0  <span class="org-comment">; init</span>
        [1 2 3 4])  <span class="org-comment">;=&gt; 100</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-4-6" class="outline-5">
<h5 id="sec-1-13-4-6"><code>reduce</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-4-6">
<ul class="org-ul">
<li>With no <i>init</i>, uses first element of seq
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> + [1 1 2 3 5])  <span class="org-comment">;=&gt; 12</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-4-7" class="outline-5">
<h5 id="sec-1-13-4-7"><code>some</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-4-7">
<ul class="org-ul">
<li><code>(some <i style="font-family:serif">function</i> <i style="font-family:serif">seq</i>)</code>
</li>
<li>Maps <i>function</i> over the seq
</li>
<li>Returns <i>first</i> logical true value of function
</li>
<li>Or <code>nil</code> if nothing true
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">some</span> #(zero? (<span class="org-variable-name">rem</span> % 5)) [9 22 35 76])  <span class="org-comment">;=&gt; true</span>

(<span class="org-variable-name">some</span> #(<span class="org-variable-name">=</span> 4 %) [1 3 5])  <span class="org-comment">;=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-4-8" class="outline-5">
<h5 id="sec-1-13-4-8"><code>some</code> with a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-4-8">
<ul class="org-ul">
<li>Sets are functions
</li>
<li>Can be used as linear search
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">some</span> #{<span class="org-constant">:b</span>} [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])    <span class="org-comment">;=&gt; :b</span>

(<span class="org-variable-name">some</span> #{<span class="org-constant">:foo</span>} [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])  <span class="org-comment">;=&gt; nil</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-5" class="outline-4">
<h4 id="sec-1-13-5">Laziness&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-13-5">
<ul class="org-ul">
<li>Sequences can be <b>lazy</b>
</li>
<li>Compute results as needed
</li>
<li>Only compute value once, then cached
</li>
<li>Can be infinite!
</li>
<li>Most Clojure functions which return sequences are lazy
</li>
</ul>
</div>

<div id="outline-container-sec-1-13-5-1" class="outline-5">
<h5 id="sec-1-13-5-1">Don't Mix Side Effects and Laziness&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-5-1">
<p>
<b>Chunked sequences</b> lead to confusing results.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 4 (<span class="org-variable-name">map</span> println (<span class="org-variable-name">range</span> 100)))
</pre>
</div>

<pre class="example">
;;=&gt; (0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
nil nil nil nil)
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-5-2" class="outline-5">
<h5 id="sec-1-13-5-2">Use Side Effects at the End&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-5-2">
<ul class="org-ul">
<li>Usually <code>doseq</code>
</li>
<li>Sometimes <code>reduce</code>
</li>
<li>Rarely <code>doall</code> or <code>dorun</code>
<ul class="org-ul">
<li>"Force" complete evaluation of lazy seq
</li>
<li>Sequence must be finite!
</li>
<li><code>doall</code> returns entire sequence (must fit in memory!)
</li>
<li><code>dorun</code> returns <code>nil</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-5-3" class="outline-5">
<h5 id="sec-1-13-5-3">Beware Lazy Stacks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-5-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">build-sequence</span> [n]
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [sequence i]
            (<span class="org-variable-name">concat</span> sequence (<span class="org-variable-name">range</span> i)))
          nil
          (<span class="org-variable-name">range</span> 1 (<span class="org-variable-name">inc</span> n))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(build-sequence 6)
</pre>
</div>

<pre class="example">
;;=&gt; (0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">first</span> (build-sequence 4000))
</pre>
</div>

<pre class="example">
;; StackOverflowError   clojure.lang.LazySeq.sval (LazySeq.java:42)
</pre>
</div>
</div>
<div id="outline-container-sec-1-13-5-4" class="outline-5">
<h5 id="sec-1-13-5-4">Non-Lazy Alternative&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-5-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">build-vector</span> [n]
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [v i]
            (<span class="org-variable-name">into</span> v (<span class="org-variable-name">range</span> i)))
          []
          (<span class="org-variable-name">range</span> 1 (<span class="org-variable-name">inc</span> n))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (build-vector 4000))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Takes a while...</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 0 1 0 1 2 0 1 2 3)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-5-5" class="outline-5">
<h5 id="sec-1-13-5-5">Non-Lazy Alternatives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-5-5">
<p>
Many lazy sequence operations have non-lazy equivalents that return
vectors.
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Return Lazy Seq    ;; Return Vector</span>
map                   mapv
filter                filterv
concat                into []


<span class="org-comment-delimiter">;; </span><span class="org-comment">O(n) on a seq      ;; O(1) on a vector</span>
last                  peek
butlast               pop
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6" class="outline-4">
<h4 id="sec-1-13-6">Sequence Theory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-13-6">
</div><div id="outline-container-sec-1-13-6-1" class="outline-5">
<h5 id="sec-1-13-6-1">Sequence API&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-1">
<ul class="org-ul">
<li><code>(seq coll)</code>
<ul class="org-ul">
<li>If collection is not empty, return seq object on it
</li>
<li>If collection is empty, return <code>nil</code>
</li>
</ul>
</li>
<li><code>(first coll)</code> returns the first element
</li>
<li><code>(rest coll)</code> returns a sequence of the rest of the elements
<ul class="org-ul">
<li>Might be empty, but not <code>nil</code>
</li>
</ul>
</li>
<li><code>(next coll)</code> is same as <code>(seq (rest coll))</code>
</li>
<li><code>(cons x coll)</code> returns a new sequence: first is x, rest is coll
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-6-2" class="outline-5">
<h5 id="sec-1-13-6-2">Sequences Over Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-2">
<ul class="org-ul">
<li>Can treat any Clojure data structure as a seq
<ul class="org-ul">
<li>Lists actually <i>are</i> seqs
</li>
<li>Associative structures treated as sequence of pairs
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-6-3" class="outline-5">
<h5 id="sec-1-13-6-3">List as a Seq&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">x</span> '(1 2 3))  <span class="org-comment">; x is a list</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-list-initial.svg" alt="collections-seq-list-initial.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-4" class="outline-5">
<h5 id="sec-1-13-6-4">List as a Seq&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">first</span> x))   <span class="org-comment">; a is 1</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-list-first.svg" alt="collections-seq-list-first.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-5" class="outline-5">
<h5 id="sec-1-13-6-5">List as a Seq&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s</span> (<span class="org-variable-name">rest</span> x))   <span class="org-comment">; s is a seq</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-list-rest.svg" alt="collections-seq-list-rest.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-6" class="outline-5">
<h5 id="sec-1-13-6-6">List as a Seq&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">first</span> (<span class="org-variable-name">rest</span> x))   <span class="org-comment">; b is 2</span>
(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">second</span> x))        <span class="org-comment">; same thing</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-list-second.svg" alt="collections-seq-list-second.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-7" class="outline-5">
<h5 id="sec-1-13-6-7">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-7">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">v</span> [1 2 3]))  <span class="org-comment">; v is a vector</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-vector-initial.svg" alt="collections-seq-vector-initial.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-8" class="outline-5">
<h5 id="sec-1-13-6-8">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-8">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s1</span> (<span class="org-variable-name">seq</span> v))   <span class="org-comment">; s1 is a seq</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-vector-seq.svg" alt="collections-seq-vector-seq.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-9" class="outline-5">
<h5 id="sec-1-13-6-9">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-9">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">first</span> v))   <span class="org-comment">; a is 1</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-vector-first.svg" alt="collections-seq-vector-first.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-10" class="outline-5">
<h5 id="sec-1-13-6-10">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-10">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s2</span> (<span class="org-variable-name">rest</span> v))   <span class="org-comment">; s2 is a seq</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-vector-rest.svg" alt="collections-seq-vector-rest.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-11" class="outline-5">
<h5 id="sec-1-13-6-11">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-11">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">first</span> (<span class="org-variable-name">rest</span> v))  <span class="org-comment">; b is 2</span>
(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">second</span> v))       <span class="org-comment">; same thing</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-vector-second.svg" alt="collections-seq-vector-second.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-12" class="outline-5">
<h5 id="sec-1-13-6-12">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-12">
<ul class="org-ul">
<li>Can map a generator function to a seq
</li>
<li>Seq is lazy, can be infinite
<ul class="org-ul">
<li>Can process more than fits in memory
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-6-13" class="outline-5">
<h5 id="sec-1-13-6-13">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-13">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">r</span> (<span class="org-variable-name">range</span> 1 100))   <span class="org-comment">; r is a lazy seq</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-lazy-initial.svg" alt="collections-seq-lazy-initial.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-14" class="outline-5">
<h5 id="sec-1-13-6-14">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-14">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">first</span> r))  <span class="org-comment">; a is 1</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-lazy-first.svg" alt="collections-seq-lazy-first.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-15" class="outline-5">
<h5 id="sec-1-13-6-15">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-15">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s</span> (<span class="org-variable-name">rest</span> r))    <span class="org-comment">; s is a lazy seq</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-lazy-rest.svg" alt="collections-seq-lazy-rest.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-16" class="outline-5">
<h5 id="sec-1-13-6-16">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-16">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">first</span> (<span class="org-variable-name">rest</span> r))  <span class="org-comment">; b is 2</span>
(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">second</span> r))       <span class="org-comment">; same thing</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-lazy-second.svg" alt="collections-seq-lazy-second.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-17" class="outline-5">
<h5 id="sec-1-13-6-17">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-17">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">c</span> (<span class="org-variable-name">first</span> (<span class="org-variable-name">rest</span> (<span class="org-variable-name">rest</span> r))))  <span class="org-comment">; c is 3</span>
(<span class="org-keyword">def</span> <span class="org-function-name">c</span> (<span class="org-variable-name">nth</span> r 2))                <span class="org-comment">; same thing</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-lazy-third.svg" alt="collections-seq-lazy-third.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-18" class="outline-5">
<h5 id="sec-1-13-6-18">Sequences and GC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-18">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">count</span> (<span class="org-variable-name">range</span> 10000000))  <span class="org-comment">;=&gt; 10000000</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-lazy-GC-safe.svg" alt="collections-seq-lazy-GC-safe.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-19" class="outline-5">
<h5 id="sec-1-13-6-19">Holding on to the Head&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-19">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">r</span> (<span class="org-variable-name">range</span> 10000000)) 
(<span class="org-variable-name">count</span> r)  <span class="org-comment">; out of memory error</span>
</pre>
</div>


<div class="figure">
<p><img src="slide-assets/collections-seq-lazy-GC-unsafe.svg" alt="collections-seq-lazy-GC-unsafe.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-6-20" class="outline-5">
<h5 id="sec-1-13-6-20">Sequences in the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-6-20">
<ul class="org-ul">
<li>REPL always prints sequences with parens
<ul class="org-ul">
<li>But it's not a list!
</li>
</ul>
</li>
<li>Infinite sequences take a long time to print
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(set! *print-length* 10) <span class="org-comment">; only print 10 things</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-7" class="outline-4">
<h4 id="sec-1-13-7">Generating a Raw Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-13-7">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">pseudocode</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">generate-seq</span> [input-source]
  (<span class="org-variable-name">lazy-seq</span>   <span class="org-comment">; macro creates lazy seq of body</span>
   (<span class="org-builtin">when</span> (more-available? input-source)   <span class="org-comment">; termination check</span>
     (<span class="org-variable-name">cons</span> (get-next-item input-source)   <span class="org-comment">; construct "next" seq</span>
           (generate-seq input-source)))))  <span class="org-comment">; recursive call (not recur)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-8" class="outline-4">
<h4 id="sec-1-13-8">Combining Sequence Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-1-13-8">
</div><div id="outline-container-sec-1-13-8-1" class="outline-5">
<h5 id="sec-1-13-8-1">Sequence Power&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-8-1">
<ul class="org-ul">
<li>Generators
<ul class="org-ul">
<li>list, vector, map, SQL ResultSet, Stream, Directory, Iterator, XML, &#x2026;
</li>
</ul>
</li>
<li>Operations
<ul class="org-ul">
<li>map, filter, reduce, count, some, replace, &#x2026;
</li>
</ul>
</li>
<li>Generators * Operations = Power!
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-8-2" class="outline-5">
<h5 id="sec-1-13-8-2">Adopting the Sequence Mindset&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-8-2">
<ul class="org-ul">
<li>Sequence library surface space is big
</li>
<li>Most things you want to do are in there somewhere
</li>
<li>If you find yourself explicitly iterating, look for a function
<ul class="org-ul">
<li>The Clojure Cheatsheet helps
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-8-3" class="outline-5">
<h5 id="sec-1-13-8-3">Combining Sequence Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-8-3">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Sum of the first 50 odd integers</span>
(<span class="org-variable-name">reduce</span> + (<span class="org-variable-name">take</span> 50 (<span class="org-variable-name">filter</span> odd? (<span class="org-variable-name">range</span>))))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2500</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Frequency of vowels in the docstring of 'ns'</span>
(frequencies (<span class="org-variable-name">re-seq</span> #<span class="org-string">"[aeiou]"</span> (<span class="org-constant">:doc</span> (<span class="org-variable-name">meta</span> #'ns))))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {"e" 109, "o" 48, "a" 49, "u" 32, "i" 49}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-13-8-4" class="outline-5">
<h5 id="sec-1-13-8-4">Thread-last For Readability&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-8-4">
<ul class="org-ul">
<li>"Thread-last"
</li>
<li>Invoke each step with the prior result as the last argument
</li>

<li>Example:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">-&gt;&gt;</span> (<span class="org-variable-name">range</span>) (<span class="org-variable-name">filter</span> odd?) (<span class="org-variable-name">take</span> 50) (<span class="org-variable-name">reduce</span> +))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-13-8-5" class="outline-5">
<h5 id="sec-1-13-8-5">The Fibonacci Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-1-13-8-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">fibs</span>            <span class="org-comment">; define a sequence called fibs...</span>
  (<span class="org-variable-name">map</span> first         <span class="org-comment">; that maps the first value of a pair across...</span>
    (<span class="org-variable-name">iterate</span>         <span class="org-comment">; a lazy, infinite sequence that's generated by...</span>
      (<span class="org-variable-name">fn</span> [[a b]]    <span class="org-comment">; a function that destructures a pair of args...</span>
        [b (<span class="org-variable-name">+</span> a b)]) <span class="org-comment">; and returns the next pair in the sequence...</span>
      [0 1])))       <span class="org-comment">; starting at [0 1]</span>

(<span class="org-variable-name">take</span> 5 fibs)        <span class="org-comment">; consume as many as you'd like</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 1 1 2 3)</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14">LAB: Sums and Ciphers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-1-14">
</div>

<div id="outline-container-sec-1-14-1" class="outline-4">
<h4 id="sec-1-14-1">Fibonacci sum</h4>
<div class="outline-text-4" id="text-1-14-1">
<p>
Clojure's <code>take</code> function is commonly used to work with limited portions of infinite sequences.
</p>

<p>
Given this infinite, lazy sequence of Fibonacci numbers:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">fibs</span>
  (<span class="org-variable-name">map</span> first
       (<span class="org-variable-name">iterate</span> (<span class="org-variable-name">fn</span> [[a b]] [b (<span class="org-variable-name">+</span> a b)])
                [0 1])))
</pre>
</div>

<p>
Find the sum of the first fifty Fibonacci numbers.
</p>
</div>

<div id="outline-container-sec-1-14-1-1" class="outline-5">
<h5 id="sec-1-14-1-1">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-1-1">
<p>
The expected answer is 20365011073.
</p>
</div>
</div>
<div id="outline-container-sec-1-14-1-2" class="outline-5">
<h5 id="sec-1-14-1-2">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-1-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> + (<span class="org-variable-name">take</span> 50 fibs))
</pre>
</div>

<pre class="example">
;;=&gt; 20365011073
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-2" class="outline-4">
<h4 id="sec-1-14-2">Reduce vs. apply</h4>
<div class="outline-text-4" id="text-1-14-2">
<p>
The solution to the previous exercise can be written with <code>apply</code> instead of <code>reduce</code>. Why? 
</p>

<p>
For most uses of <code>reduce</code>, this is not the case. Why not?
</p>
</div>

<div id="outline-container-sec-1-14-2-1" class="outline-5">
<h5 id="sec-1-14-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-2-1">
<p>
<code>reduce</code> is designed to be used with functions that take exactly two arguments. The <code>+</code> function is somewhat unique in that it takes any number of arguments. For the non-trivial cases, it is implemented in terms of <code>reduce</code>:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">+</span>
  ([] 0)
  ([x] (<span class="org-variable-name">cast</span> <span class="org-preprocessor">Number</span> x))
  ([x y] (<span class="org-preprocessor">clojure.lang.Numbers/add</span> x y))
  ([x y &amp; more]
     (<span class="org-variable-name">reduce</span> + (<span class="org-variable-name">+</span> x y) more)))
</pre>
</div>

<p>
When you call <code>(apply + some-collection)</code> you are actually reducing over successive pairs of elements from the collection.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-3" class="outline-4">
<h4 id="sec-1-14-3">Prime sum</h4>
<div class="outline-text-4" id="text-1-14-3">
<p>
The <code>take</code> and <code>drop</code> functions, as well as variants like <code>take-while</code> and <code>drop-while</code>, can be combined to select subsequences out of a larger sequence.
</p>

<p>
Given this infinite, lazy (and inefficient) sequence of prime numbers:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">primes</span>
  (<span class="org-builtin">letfn</span> [(next-prime [known-primes n]
            (<span class="org-variable-name">lazy-seq</span>
             (<span class="org-builtin">if</span> (<span class="org-variable-name">some</span> #(zero? (<span class="org-variable-name">rem</span> n %)) known-primes)
               (next-prime known-primes (<span class="org-variable-name">inc</span> n))
               (<span class="org-variable-name">cons</span> n (next-prime (<span class="org-variable-name">conj</span> known-primes n) (<span class="org-variable-name">inc</span> n))))))]
    (next-prime [] 2)))
</pre>
</div>

<p>
Find the sum of the first fifty primes over one hundred.
</p>
</div>

<div id="outline-container-sec-1-14-3-1" class="outline-5">
<h5 id="sec-1-14-3-1">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-3-1">
<p>
The expected answer is 11658.
</p>
</div>
</div>
<div id="outline-container-sec-1-14-3-2" class="outline-5">
<h5 id="sec-1-14-3-2">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-3-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> + (<span class="org-variable-name">take</span> 50 (<span class="org-variable-name">drop-while</span> #(<span class="org-variable-name">&lt;=</span> % 100) primes)))
</pre>
</div>

<pre class="example">
;;=&gt; 11658
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-4" class="outline-4">
<h4 id="sec-1-14-4">Ranges of letters</h4>
<div class="outline-text-4" id="text-1-14-4">
<p>
Suppose we want to make a collection of all the capital letters, from <i>A</i> to <i>Z</i>. Clojure's <code>range</code> function only works on numbers, but we can convert between characters and numbers using the <code>char</code> and <code>int</code> functions.
</p>

<p>
Using those functions, plus <code>map</code> and <code>range</code>, define <code>letters</code> as a sequence of capital letters.
</p>
</div>

<div id="outline-container-sec-1-14-4-1" class="outline-5">
<h5 id="sec-1-14-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">letters</span> (<span class="org-variable-name">map</span> char (<span class="org-variable-name">range</span> (<span class="org-variable-name">int</span> \A) (<span class="org-variable-name">inc</span> (<span class="org-variable-name">int</span> \Z)))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-5" class="outline-4">
<h4 id="sec-1-14-5">Rotating a sequence</h4>
<div class="outline-text-4" id="text-1-14-5">
<p>
In the next few exercises, we will implement the famous ROT-13 cipher, also known as the Caesar cipher.
</p>

<p>
ROT-13 works by "rotating" the alphabet 13 places to the left. So <i>A</i> becomes 
<i>N</i>, <i>B</i> becomes <i>O</i>, and so on.
</p>

<p>
Clojure's <code>cycle</code> function takes a sequential collection and returns the elements of that sequence repeated in an infinite cycle. For example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (<span class="org-variable-name">cycle</span> [<span class="org-constant">:A</span> <span class="org-constant">:B</span> <span class="org-constant">:C</span>]))
</pre>
</div>

<pre class="example">
;;=&gt; (:A :B :C :A :B :C :A :B :C :A)
</pre>

<p>
Using <code>cycle</code>, rotate the alphabet 13 places to the left.
</p>
</div>

<div id="outline-container-sec-1-14-5-1" class="outline-5">
<h5 id="sec-1-14-5-1">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-5-1">
<div class="org-src-container">

<pre class="src src-clojure">: <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (\N \O \P \Q \R \S \T \U \V \W \X \Y \Z \A \B \C \D \E \F \G \H \I \J \K \L \M)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-5-2" class="outline-5">
<h5 id="sec-1-14-5-2">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-5-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 26 (<span class="org-variable-name">drop</span> 13 (<span class="org-variable-name">cycle</span> letters)))
</pre>
</div>

<pre class="example">
;;=&gt; (\N \O \P \Q \R \S \T \U \V \W \X \Y \Z \A \B \C \D \E \F \G \H \I \J \K \L \M)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-6" class="outline-4">
<h4 id="sec-1-14-6">Generic rotation</h4>
<div class="outline-text-4" id="text-1-14-6">
<p>
Define a function which takes two arguments: a collection and a number <i>n</i>, and rotates the collection by <i>n</i> places.
</p>
</div>

<div id="outline-container-sec-1-14-6-1" class="outline-5">
<h5 id="sec-1-14-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">rotate</span> [coll n]
  (<span class="org-variable-name">take</span> (<span class="org-variable-name">count</span> coll) (<span class="org-variable-name">drop</span> n (<span class="org-variable-name">cycle</span> coll))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-7" class="outline-4">
<h4 id="sec-1-14-7">ROT-13 pairs</h4>
<div class="outline-text-4" id="text-1-14-7">
<p>
Clojure's <code>map</code> function takes multiple collection arguments. Use this fact to create a sequence of pairs in the ROT-13 cipher, like <code>[\A \N]</code>.
</p>
</div>

<div id="outline-container-sec-1-14-7-1" class="outline-5">
<h5 id="sec-1-14-7-1">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-7-1">
<pre class="example">
;;=&gt; ([\A \N] [\B \O] [\C \P] [\D \Q] [\E \R] [\F \S] [\G \T] [\H \U] [\I \V] [\J \W] [\K \X] [\L \Y] [\M \Z] [\N \A] [\O \B] [\P \C] [\Q \D] [\R \E] [\S \F] [\T \G] [\U \H] [\V \I] [\W \J] [\X \K] [\Y \L] [\Z \M])
</pre>
</div>
</div>
<div id="outline-container-sec-1-14-7-2" class="outline-5">
<h5 id="sec-1-14-7-2">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-7-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">map</span> vector letters (rotate letters 13))
</pre>
</div>

<pre class="example">
;;=&gt; ([\A \N] [\B \O] [\C \P] [\D \Q] [\E \R] [\F \S] [\G \T] [\H \U] [\I \V] [\J \W] [\K \X] [\L \Y] [\M \Z] [\N \A] [\O \B] [\P \C] [\Q \D] [\R \E] [\S \F] [\T \G] [\U \H] [\V \I] [\W \J] [\X \K] [\Y \L] [\Z \M])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-8" class="outline-4">
<h4 id="sec-1-14-8">ROT-13 as a map</h4>
<div class="outline-text-4" id="text-1-14-8">
<p>
We will define a cipher as a map from plain-text characters to cipher-text characters. We already have a sequence of pairs. Use Clojure's <code>into</code> function to convert this sequence into a map.
</p>
</div>

<div id="outline-container-sec-1-14-8-1" class="outline-5">
<h5 id="sec-1-14-8-1">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-8-1">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {\A \N, \B \O, \C \P, \D \Q, \E \R, \F \S, \G \T, \H \U, \I \V, \J \W, \K \X, \L \Y, \M \Z, \N \A, \O \B, \P \C, \Q \D, \R \E, \S \F, \T \G, \U \H, \V \I, \W \J, \X \K, \Y \L, \Z \M}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-8-2" class="outline-5">
<h5 id="sec-1-14-8-2">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-8-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> {} (<span class="org-variable-name">map</span> vector letters (rotate letters 13)))
</pre>
</div>

<pre class="example">
;;=&gt; {\A \N, \B \O, \C \P, \D \Q, \E \R, \F \S, \G \T, \H \U, \I \V, \J \W, \K \X, \L \Y, \M \Z, \N \A, \O \B, \P \C, \Q \D, \R \E, \S \F, \T \G, \U \H, \V \I, \W \J, \X \K, \Y \L, \Z \M}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-9" class="outline-4">
<h4 id="sec-1-14-9">Building a map with reduce</h4>
<div class="outline-text-4" id="text-1-14-9">
<p>
Clojure has a shortcut for this method of constructing maps called <code>zipmap</code>. Use <code>zipmap</code> to create the same map as the previous exercise. Define this map as <code>rot13-cipher</code>.
</p>
</div>

<div id="outline-container-sec-1-14-9-1" class="outline-5">
<h5 id="sec-1-14-9-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-9-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">rot13-cipher</span> (<span class="org-variable-name">zipmap</span> letters (rotate letters 13)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-10" class="outline-4">
<h4 id="sec-1-14-10">Invoking the map</h4>
<div class="outline-text-4" id="text-1-14-10">
<p>
In the classic ROT-13 cipher, non-letter characters are left unchanged. Define a function <code>rot13-one-char</code> which takes a single character as its argument. If that character is in the <code>rot13-cipher</code> map, it returns the corresponding value. If the character is not in the map, it returns the original character unchanged.
</p>

<p>
Note: Our cipher ONLY WORKS ON CAPITAL LETTERS.
</p>
</div>

<div id="outline-container-sec-1-14-10-1" class="outline-5">
<h5 id="sec-1-14-10-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-10-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">rot13-one-char</span> [c]
  (rot13-cipher c c))
</pre>
</div>

<p>
Here we take advantage of the fact that maps are invocable, and take an optional second argument which is returned when the first argument is not a key in the map.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-11" class="outline-4">
<h4 id="sec-1-14-11">Enciphering text</h4>
<div class="outline-text-4" id="text-1-14-11">
<p>
Define a function <code>rot13</code> that takes a string argument and returns the ROT-13 enciphered version.
</p>

<p>
Remember, our cipher ONLY WORKS ON CAPITAL LETTERS.
</p>

<p>
Hint: <code>apply str</code> will convert a collection of characters to a string.
</p>
</div>

<div id="outline-container-sec-1-14-11-1" class="outline-5">
<h5 id="sec-1-14-11-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-11-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">rot13</span> [text]
  (<span class="org-variable-name">apply</span> str (<span class="org-variable-name">map</span> rot13-one-char text)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-11-2" class="outline-5">
<h5 id="sec-1-14-11-2">Examples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-1-14-11-2">
<div class="org-src-container">

<pre class="src src-clojure">(rot13 <span class="org-string">"HELLO, WORLD!"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "URYYB, JBEYQ!"
</pre>

<p>
The ROT-13 cipher is its own inverse, so we can use the same function to decipher text:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(rot13 <span class="org-string">"URYYB, JBEYQ!"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "HELLO, WORLD!"
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-12" class="outline-4">
<h4 id="sec-1-14-12">Bonus Questions</h4>
<div class="outline-text-4" id="text-1-14-12">
<p>
The next few exercises will help you decipher the following message:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">secret-message</span>
  <span class="org-string">"FCMJ C CM U JLIALUGGCHA MSMNYG ZIL NBY CVG 704 ZIL WIGJONCHA QCNB</span>
<span class="org-string">MSGVIFCW YRJLYMMCIHM. CN BUM VYYH OMYX ZIL MSGVIFCW WUFWOFUNCIHM CH</span>
<span class="org-string">XCZZYLYHNCUF UHX CHNYALUF WUFWOFOM, YFYWNLCW WCLWOCN NBYILS,</span>
<span class="org-string">GUNBYGUNCWUF FIACW, UHX ULNCZCWCUF CHNYFFCAYHWY."</span>)
</pre>
</div>

<p>
This message was encoded with a rotation cipher similar to ROT-13. We can guess which cipher was used by finding the most common letters.
</p>
</div>

<div id="outline-container-sec-1-14-12-1" class="outline-5">
<h5 id="sec-1-14-12-1">Counting letter frequency</h5>
<div class="outline-text-5" id="text-1-14-12-1">
<p>
Define a function <code>count-letters</code> that counts the occurrences of each letter in a string and returns them in a map.
</p>

<p>
Hint: a common strategy for building up a map from another collection is to <code>reduce</code> over the collection, adding one or more keys to the map at each step:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [result item]
          (<span class="org-variable-name">assoc</span> result ...))
        {}  <span class="org-comment">; empty map as seed for result</span>
        collection)
</pre>
</div>
</div>

<div id="outline-container-sec-1-14-12-1-1" class="outline-6">
<h6 id="sec-1-14-12-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-14-12-1-1">
<p>
Clojure already has a function <code>frequencies</code> that does this. It could also be written:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">count-letters</span> [text]
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [counts character]
            (<span class="org-variable-name">assoc</span> counts character
                   (<span class="org-variable-name">inc</span> (counts character 0))))
          {}
          text))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-12-2" class="outline-5">
<h5 id="sec-1-14-12-2">Counting with fnil</h5>
<div class="outline-text-5" id="text-1-14-12-2">
<p>
Clojure's <code>update-in</code> function is useful when making modifications to a map. It takes a vector of keys and a function, uses those keys to "reach into" the map, apply the function to a value, and return the modified map. The <code>fnil</code> function is useful in conjunction with <code>update-in</code>.
</p>

<p>
Use <code>update-in</code> and <code>fnil</code> to redefine the <code>count-letters</code> function.
</p>
</div>

<div id="outline-container-sec-1-14-12-2-1" class="outline-6">
<h6 id="sec-1-14-12-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-14-12-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">count-letters</span> [text]
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [counts character]
            (<span class="org-variable-name">update-in</span> counts [character] (fnil inc 0)))
          {}
          text))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-12-3" class="outline-5">
<h5 id="sec-1-14-12-3">Finding most common letters</h5>
<div class="outline-text-5" id="text-1-14-12-3">
<p>
Clojure's <code>sort-by</code> function can sort a collection by any arbitrary function. Use this to find the most common letters in the secret message cipher-text.
</p>
</div>

<div id="outline-container-sec-1-14-12-3-1" class="outline-6">
<h6 id="sec-1-14-12-3-1">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-14-12-3-1">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (\D \E \K \P \T \Q \R \J \S \V \X \B \A \O \Z \G \I \H \L \M \F \N \U \W \Y \C)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-12-3-2" class="outline-6">
<h6 id="sec-1-14-12-3-2">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-14-12-3-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sort-by</span> (count-letters secret-message) letters)
</pre>
</div>

<pre class="example">
;;=&gt; (\D \E \K \P \T \Q \R \J \S \V \X \B \A \O \Z \G \I \H \L \M \F \N \U \W \Y \C)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-12-4" class="outline-5">
<h5 id="sec-1-14-12-4">Deciphering</h5>
<div class="outline-text-5" id="text-1-14-12-4">
<p>
In most English texts <i>E</i> is the most common letter, and this fact can often be used to break encryption. Our secret message is too short for that technique to work, so we will tell you that the most common letter in the plain-text message is <i>I</i>. We know the most common letter in the cipher-text from the previous exercise.
</p>

<p>
Given those facts, define a function to decipher the secret message.
</p>
</div>

<div id="outline-container-sec-1-14-12-4-1" class="outline-6">
<h6 id="sec-1-14-12-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-1-14-12-4-1">
<p>
We can see from the previous exercise that <i>C</i> is the most common letter in the cipher-text.  How far is <i>C</i> from <i>I</i>?
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">-</span> (<span class="org-variable-name">int</span> \I) (<span class="org-variable-name">int</span> \C))
</pre>
</div>

<pre class="example">
;;=&gt; 6
</pre>

<p>
So if we rotate the alphabet by six letters, we should be able to decipher the message.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">rot6-cipher</span> (<span class="org-variable-name">zipmap</span> letters (rotate letters 6)))

(<span class="org-keyword">defn</span> <span class="org-function-name">rot6</span> [text]
  (<span class="org-variable-name">apply</span> str (<span class="org-variable-name">map</span> #(rot6-cipher % %) text)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">println</span> (rot6 secret-message))
<span class="org-comment-delimiter">;; </span><span class="org-comment">LISP I IS A PROGRAMMING SYSTEM FOR THE IBM 704 FOR COMPUTING WITH</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">SYMBOLIC EXPRESSIONS. IT HAS BEEN USED FOR SYMBOLIC CALCULATIONS IN</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">DIFFERENTIAL AND INTEGRAL CALCULUS, ELECTRIC CIRCUIT THEORY,</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">MATHEMATICAL LOGIC, AND ARTIFICIAL INTELLIGENCE.</span>
</pre>
</div>

<p>
The text is the opening paragraph of the <a href="http://history.siam.org/sup/Fox_1960_LISP.pdf">LISP I Programmer's Manual (PDF)</a>, published in 1960.
</p>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Intermediate Topics</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-1">
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">Transducers</h4>
<div class="outline-text-4" id="text-2-1-1">
</div><div id="outline-container-sec-2-1-1-1" class="outline-5">
<h5 id="sec-2-1-1-1">Why transducers?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-1">
<ul class="org-ul">
<li>Implementation of <code>map</code>, <code>filter</code>, etc involves:
<ul class="org-ul">
<li>Iterating input
</li>
<li>Constructing output
</li>
</ul>
</li>
<li>But the essence of transformations is independent
</li>
<li>Transformations can be applied in many other contexts
</li>
<li>Transducers separate algorithmic transformation from processing context
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-2" class="outline-5">
<h5 id="sec-2-1-1-2">Transducer advantages vs sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-2">
<ul class="org-ul">
<li>Create transformation once, apply in multiple contexts
<ul class="org-ul">
<li>Improves code factoring
</li>
</ul>
</li>
<li>Single pass over the input instead of pass per transformation
<ul class="org-ul">
<li>Less computation
</li>
<li>Less object creation and garbage collection
</li>
</ul>
</li>
<li>Eager execution
<ul class="org-ul">
<li>Easier to know and manage use of input resource
</li>
<li>Errors occur at point of use rather than later
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-3" class="outline-5">
<h5 id="sec-2-1-1-3">Sequence advantages vs transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-3">
<ul class="org-ul">
<li>Lazier in consumption
<ul class="org-ul">
<li>Transducers fully realize each "step" per input
</li>
</ul>
</li>
<li>Broader set of transformations available
<ul class="org-ul">
<li>Not all core sequence functions have transducers
</li>
</ul>
</li>
<li>Many existing APIs expect sequences
<ul class="org-ul">
<li>This will likely change over time
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-4" class="outline-5">
<h5 id="sec-2-1-1-4">Creating transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-4">
<ul class="org-ul">
<li>Most sequence functions have reduced arity form
</li>
<li>Omit the collection and get a transducer instead
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">map</span> inc)          <span class="org-comment-delimiter">;; </span><span class="org-comment">transducer</span>
(<span class="org-variable-name">filter</span> odd?)      <span class="org-comment-delimiter">;; </span><span class="org-comment">transducer</span>
(partition-all 2)  <span class="org-comment-delimiter">;; </span><span class="org-comment">transducer</span>
</pre>
</div>

<ul class="org-ul">
<li>Transducer is a "recipe" for the algorithm
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-5" class="outline-5">
<h5 id="sec-2-1-1-5">Combining transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-5">
<ul class="org-ul">
<li>Transducers are most easily combined using <code>comp</code>
</li>
<li>Composition creates a modified "recipe"
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">transducer</span>
(<span class="org-variable-name">comp</span> (<span class="org-variable-name">filter</span> odd?) (<span class="org-variable-name">map</span> inc) (partition-all 2))
</pre>
</div>

<ul class="org-ul">
<li>Transformations are applied left to right in a process
<ul class="org-ul">
<li><code>filter</code>, then <code>map</code>, then <code>partition-all</code>
</li>
</ul>
</li>
<li>Mnemonic - think of it reading like <code>-&gt;&gt;</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-6" class="outline-5">
<h5 id="sec-2-1-1-6">Transducible process&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-6">
<ul class="org-ul">
<li>A "transducible process" takes a transducer and applies it to a
series of inputs. What happens to the results depends on the process.
</li>
<li><code>transduce</code> - like reduce. Applies transducer to an input
collection and accumulates an output.
</li>
<li><code>into</code> - collect the results of applying a transducer to an input
collection into an output collection
</li>
<li><code>sequence</code> - creates an incrementally computed sequence from
applying a transducer to an input collection.
</li>
<li><code>eduction</code> - creates an iterable/reducible instance that
will perform the entire transformation anew on each use
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-7" class="outline-5">
<h5 id="sec-2-1-1-7">transduce&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-7">
<p>
Similar to reduce. Applies transducer to input collection and
reduces with + using initial value 0:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(transduce (<span class="org-variable-name">map</span> inc) + 0 (<span class="org-variable-name">range</span> 100))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 5050</span>
</pre>
</div>

<p>
Arguments:
</p>
<ul class="org-ul">
<li>transducer
</li>
<li>final reducing function
</li>
<li>initial value (optional)
</li>
<li>input collection
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-1-1-8" class="outline-5">
<h5 id="sec-2-1-1-8">into&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-8">
<p>
Eager collection into a target collection.
</p>

<p>
Collect the results of applying a transducer into an output
collection:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> [] (<span class="org-variable-name">filter</span> prime?) (<span class="org-variable-name">range</span> 1000))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-1-9" class="outline-5">
<h5 id="sec-2-1-1-9">sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-9">
<p>
Delayed, cached production of output elements.
Note: will completely realize intermediate results.
</p>

<p>
Create a lazy sequence from a collection and a transducer:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sequence</span> (<span class="org-variable-name">map</span> inc) (<span class="org-variable-name">range</span> 100))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-1-10" class="outline-5">
<h5 id="sec-2-1-1-10">eduction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-10">
<p>
Delayed, <b>non-cached</b> production of results.
</p>

<p>
Create an eduction from a collection and a transducer:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(eduction (<span class="org-variable-name">map</span> inc) (<span class="org-variable-name">range</span> 100))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-1-11" class="outline-5">
<h5 id="sec-2-1-1-11">core.async Channels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-11">
<p>
Transducers can also be applied to streams of values flowing through a
channel:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(async/chan 10 (<span class="org-variable-name">map</span> inc))
</pre>
</div>

<ul class="org-ul">
<li>More on this later!
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Polymorphism&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-2">
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">Motivation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>Protocols (<code>defprotocol</code>)
<ul class="org-ul">
<li>Type-oriented polymorphic behavior
</li>
</ul>
</li>
<li>Multimethods (<code>defmulti</code>)
<ul class="org-ul">
<li>Polymorphic behavior with arbitrary dispatch
</li>
</ul>
</li>

<li>Records (<code>defrecord</code>)
<ul class="org-ul">
<li>Represent information entities with known fields
</li>
</ul>
</li>
<li>Types (<code>deftype</code>)
<ul class="org-ul">
<li>Implement custom data structures
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-1-1" class="outline-5">
<h5 id="sec-2-2-1-1">Opinions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-1-1">
<ul class="org-ul">
<li>Implementation inheritance is bad
<ul class="org-ul">
<li>Only derive from interfaces
</li>
<li>All methods must be in interfaces
</li>
</ul>
</li>
<li>Polymorphism doesn't require inheritance
</li>
<li>Data is still immutable
</li>
<li>No data hiding (encapsulation)
<ul class="org-ul">
<li>Immutable data can be safely shared
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-1-2" class="outline-5">
<h5 id="sec-2-2-1-2">What does "type" mean?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-1-2">
<ul class="org-ul">
<li>"What is the type (class) of object x?"
<ul class="org-ul">
<li><code>(class x)</code> or <code>(type x)</code>
</li>
</ul>
</li>
<li>"Foo is a type (class)"
<ul class="org-ul">
<li><code>(defrecord Foo ...)</code> or <code>(deftype Foo ...)</code>
</li>
<li>or Java <code>public class Foo {...}</code>
</li>
</ul>
</li>
<li>Java primitive types
<ul class="org-ul">
<li><code>int</code>, <code>long</code>, <code>double</code>, arrays, etc.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">Protocols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>Abstract behavioral contract
</li>
<li>Named group of generic functions
<ul class="org-ul">
<li>Parameters and doc string
</li>
<li>No implementation
</li>
</ul>
</li>
<li>Polymorphic on <i>type</i> of <i>first</i> argument
<ul class="org-ul">
<li>Like methods in object-oriented programming
</li>
</ul>
</li>
<li>Must have at least one argument, used for dispatch
<ul class="org-ul">
<li>Equivalent to <code>this</code> in Java
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-2-1" class="outline-5">
<h5 id="sec-2-2-2-1"><code>defprotocol</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defprotocol</span> <span class="org-function-name">MyProtocol</span>
  <span class="org-doc">"A doc string for MyProtocol abstraction"</span>
  (bar [q r] <span class="org-string">"bar docs"</span>)
  (baz [q] <span class="org-string">"baz docs"</span>))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2-2" class="outline-5">
<h5 id="sec-2-2-2-2">Protocol Dispatch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-2-2">
<ul class="org-ul">
<li><code>defprotocol</code> creates generic <i>functions</i>
<ul class="org-ul">
<li>Normal functions like <code>defn</code>
</li>
<li>Invoked like any other Clojure function
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defprotocol</span> <span class="org-function-name">Describe</span>
  (desc [self]))

(desc thing)  <span class="org-comment">; Invoke it like this</span>

(<span class="org-preprocessor">.desc</span> thing) <span class="org-comment">; Not this</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Similar to Java:  thing.desc()</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">Extending Protocols to Types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-2-3">
<ul class="org-ul">
<li>What if we want to <i>add</i> protocols to an <i>existing</i> type
<ul class="org-ul">
<li>E.g. Java built-in types like <code>String</code>
</li>
</ul>
</li>
<li>Commonly called "The Expression Problem"
</li>
<li>Common solutions are inadequate:
<ul class="org-ul">
<li>Inheritance: can't inherit from <code>String</code>
</li>
<li>Multiple inheritance: complex, not allowed in Java
</li>
<li>Wrapping: complex, breaks type &amp; equality
</li>
<li>Open classes: no namespacing, error-prone
</li>
<li>Conditionals: complex, not extensible
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-3-1" class="outline-5">
<h5 id="sec-2-2-3-1">Extending Protocols to Types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-3-1">
<ul class="org-ul">
<li>Extend <i>any</i> protocol to <i>any</i> type
<ul class="org-ul">
<li>Including <code>final</code> Java classes
</li>
</ul>
</li>
<li>Type is not modified in any way
</li>
<li>Can extend an implementation to <code>nil</code>
</li>
<li>Can extend default implementation to <code>Object</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-3-2" class="outline-5">
<h5 id="sec-2-2-3-2"><code>extend-type</code> and <code>extend-protocol</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-3-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">extend-type</span> <span class="org-preprocessor">SomeType</span>          <span class="org-comment">; 1 type, many protocols</span>
  <span class="org-preprocessor">SomeProtocol</span>
  (some-method [...] ...)
  <span class="org-preprocessor">AnotherProtocol</span>
  (another-method [...] ...))

(<span class="org-variable-name">extend-protocol</span> <span class="org-preprocessor">SomeProtocol</span>  <span class="org-comment">; 1 protocol, many types</span>
  <span class="org-preprocessor">SomeType</span>
  (some-method [...] ...)
  <span class="org-preprocessor">AnotherType</span>
  (some-method [...] ...))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3-3" class="outline-5">
<h5 id="sec-2-2-3-3"><code>extend-type</code> example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-3-3">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">; </span><span class="org-comment">java.lang.String does not implement Describe</span>
(desc <span class="org-string">"a"</span>)

<span class="org-comment-delimiter">; </span><span class="org-comment">IllegalArgumentException No implementation of</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">method: :desc of protocol: #'user/Describe</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">found for class: java.lang.String </span>

(<span class="org-variable-name">satisfies?</span> <span class="org-preprocessor">Describe</span> <span class="org-string">"a"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; false</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3-4" class="outline-5">
<h5 id="sec-2-2-3-4"><code>extend-type</code> example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-3-4">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">; </span><span class="org-comment">extend Describe to java.lang.String</span>
(<span class="org-variable-name">extend-type</span> <span class="org-preprocessor">String</span>
  <span class="org-preprocessor">Describe</span>
  (desc [s] s))

(<span class="org-variable-name">satisfies?</span> <span class="org-preprocessor">Describe</span> <span class="org-string">"a"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; true</span>

<span class="org-comment-delimiter">; </span><span class="org-comment">try again...</span>
(desc <span class="org-string">"a"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "a"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">Reifying Protocols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-2-4">
<ul class="org-ul">
<li><code>reify</code> builds anonymous type and instance on the fly
</li>
<li>Conceptually similar to anonymous functions
<ul class="org-ul">
<li>Or anonymous inner classes in Java
</li>
</ul>
</li>
<li>Function bodies are closures
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">r</span> (<span class="org-builtin">let</span> [x 42]
         (<span class="org-variable-name">reify</span> <span class="org-preprocessor">Describe</span>
           (desc [_] (<span class="org-variable-name">str</span> <span class="org-string">"describe with "</span> x)))))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #user/r</span>

(desc r)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "describe with 42"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5">Multimethods&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-2-5">
<ul class="org-ul">
<li>Protocols limited to:
<ul class="org-ul">
<li><i>Single-argument</i> dispatch
</li>
<li>On <i>type</i> of first argument
</li>
</ul>
</li>
<li>Multimethods provide:
<ul class="org-ul">
<li><i>Multiple-argument</i> dispatch
</li>
<li>On <i>any</i> criteria
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-5-1" class="outline-5">
<h5 id="sec-2-2-5-1">Multimethod Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmulti</span> <span class="org-function-name">reaction</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">2-argument dispatch function:</span>
  (<span class="org-variable-name">fn</span> [a b] [(<span class="org-constant">:species</span> a) (<span class="org-constant">:species</span> b)]))

(<span class="org-keyword">defmethod</span> <span class="org-function-name">reaction</span> [<span class="org-constant">:hero</span> <span class="org-constant">:monster</span>] <span class="org-comment">; match criteria</span>
  [hero monster]                     <span class="org-comment">; function parameters</span>
  (<span class="org-variable-name">str</span> hero <span class="org-string">" fights "</span> monster))     <span class="org-comment">; function body</span>

(<span class="org-keyword">defmethod</span> <span class="org-function-name">reaction</span> [<span class="org-constant">:monster</span> <span class="org-constant">:hero</span>]
  [monster hero]
  (<span class="org-variable-name">str</span> monster <span class="org-string">" eats "</span> hero))

(<span class="org-keyword">defmethod</span> <span class="org-function-name">reaction</span> [<span class="org-constant">:monster</span> <span class="org-constant">:monster</span>]
  [monster1 monster2]
  (<span class="org-variable-name">str</span> monster1 <span class="org-string">" plays with "</span> monster2))

(<span class="org-keyword">defmethod</span> <span class="org-function-name">reaction</span> [<span class="org-constant">:hero</span> <span class="org-constant">:hero</span>]
  [hero1 hero2]
  (<span class="org-variable-name">str</span> hero1 <span class="org-string">" taunts "</span> hero2))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-5-2" class="outline-5">
<h5 id="sec-2-2-5-2">Custom Dispatch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-5-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmulti</span> <span class="org-function-name">shape</span> count)

(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> 3 [points] <span class="org-string">"triangle"</span>)
(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> 4 [points] <span class="org-string">"rectangle"</span>)
(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> 5 [points] <span class="org-string">"pentagon"</span>)
(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> 6 [points] <span class="org-string">"hexagon"</span>)
(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> <span class="org-constant">:default</span> [n] <span class="org-string">"who cares?"</span>)

(shape [[0 0], [0 5], [5 0]]) <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "triangle"</span>
(shape [[0 0], [0 5], [5 0], [5 5]]) <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "rectangle"</span>
(shape []) <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "who cares?"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-5-3" class="outline-5">
<h5 id="sec-2-2-5-3">Multimethods vs. Protocols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-5-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">Multimethods</th>
<th scope="col" class="left">Protocols</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Extensible</td>
<td class="left">yes</td>
<td class="left">yes</td>
</tr>

<tr>
<td class="left">Java interop story</td>
<td class="left">Vars</td>
<td class="left">interfaces</td>
</tr>

<tr>
<td class="left">Dispatch on arguments</td>
<td class="left">any number</td>
<td class="left">only first</td>
</tr>

<tr>
<td class="left">Dispatch function</td>
<td class="left">arbitrary</td>
<td class="left">only type</td>
</tr>

<tr>
<td class="left">Method grouping</td>
<td class="left">no</td>
<td class="left">yes</td>
</tr>

<tr>
<td class="left">High performance</td>
<td class="left">no</td>
<td class="left">yes</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6">Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-2-6">
<ul class="org-ul">
<li>Typical app represents domain data using maps
</li>
<li>Often want polymorphic behavior across different types of map data
</li>
<li>Records are <i>named</i> map types
</li>
<li>Records can implement protocols
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-6-1" class="outline-5">
<h5 id="sec-2-2-6-1"><code>defrecord</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Car</span> [make model year])   <span class="org-comment">; named type with fields</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; user.Car</span>

(<span class="org-keyword">def</span> <span class="org-function-name">car</span> (-&gt;<span class="org-preprocessor">Car</span> <span class="org-string">"Dodge"</span> <span class="org-string">"Omni"</span> 1980)) <span class="org-comment">; instantiation</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/car</span>

(<span class="org-constant">:year</span> car)                   <span class="org-comment">; field access</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1980</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-6-2" class="outline-5">
<h5 id="sec-2-2-6-2">Records are Classes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-6-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">car</span> (<span class="org-preprocessor">Car.</span> <span class="org-string">"Dodge"</span> <span class="org-string">"Omni"</span> 1980))  <span class="org-comment">; Java constructor</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/car</span>

(.-year car)               <span class="org-comment">; fields are public &amp; final</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1980                 </span>

(<span class="org-variable-name">class</span> car)                <span class="org-comment">; ordinary class</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; user.Car</span>

(<span class="org-variable-name">supers</span> (<span class="org-variable-name">class</span> car))       <span class="org-comment">; lots of built-in functionality</span>

<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #{clojure.lang.IObj clojure.lang.IKeywordLookup java.util.Map</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.lang.IPersistentMap clojure.lang.IMeta java.lang.Object</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">java.lang.Iterable clojure.lang.ILookup clojure.lang.Seqable</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.lang.Counted clojure.lang.IPersistentCollection</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.lang.Associative}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-6-3" class="outline-5">
<h5 id="sec-2-2-6-3">Implementing Protocols on Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-6-3">
<ul class="org-ul">
<li>Protocols can be implemented directly in <code>defrecord</code>
<ul class="org-ul">
<li>Can implement Java interfaces too
</li>
</ul>
</li>
<li>Method implementation bodies
<ul class="org-ul">
<li>Can access record fields directly
</li>
<li>Do not close over lexical environment
</li>
</ul>
</li>
<li>Only implement the methods you need
<ul class="org-ul">
<li>Invoking undefined method throws <code>AbstractMethodError</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-6-4" class="outline-5">
<h5 id="sec-2-2-6-4">Implementing Protocols on records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-6-4">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">; </span><span class="org-comment">specify protocol(s) directly inline</span>
(<span class="org-keyword">defrecord</span> <span class="org-function-name">Car</span> [make model year]
  <span class="org-preprocessor">Describe</span>
  (desc [self] (<span class="org-variable-name">str</span> year <span class="org-string">" "</span> make <span class="org-string">" "</span> model)))

(<span class="org-keyword">def</span> <span class="org-function-name">car</span> (-&gt;<span class="org-preprocessor">Car</span> <span class="org-string">"Dodge"</span> <span class="org-string">"Omni"</span> 1980))  
(desc car)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "1980 Dodge Omni"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-6-5" class="outline-5">
<h5 id="sec-2-2-6-5">Using Protocols and Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-6-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defprotocol</span> <span class="org-function-name">Player</span> <span class="org-doc">"A rock/paper/scissors player"</span>
  (choose [p] <span class="org-string">"return :rock, :paper or :scissors"</span>)
  (update-player [p me you]
    <span class="org-string">"return a new player based on what you and I did"</span>))

(<span class="org-keyword">defrecord</span> <span class="org-function-name">Stubborn</span> [choice]
  <span class="org-preprocessor">Player</span> <span class="org-comment">; implement Player protocol</span>
  (choose [_] choice) <span class="org-comment">; always play the choice</span>
  (update-player [this _ _] this)) <span class="org-comment">; never change</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-6-6" class="outline-5">
<h5 id="sec-2-2-6-6">Using Protocols and Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-6-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Mean</span> [last-win] <span class="org-comment">; last thing that won for me</span>
  <span class="org-preprocessor">Player</span>
  (choose [_]
    (<span class="org-builtin">if</span> last-win  <span class="org-comment">; play last-win or random</span>
      last-win
      (random-choice)))
  (update-player [_ me you]
    <span class="org-comment-delimiter">;; </span><span class="org-comment">reuse last choice, or switch to random</span>
    (-&gt;<span class="org-preprocessor">Mean</span> (<span class="org-builtin">when</span> (i-won? me you) me))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-7" class="outline-4">
<h4 id="sec-2-2-7"><code>deftype</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-2-7">
<ul class="org-ul">
<li>Sometimes you don't want/need map behavior
<ul class="org-ul">
<li>New data structures
</li>
<li>Clojure's data structures implemented in Clojure
</li>
</ul>
</li>
<li><code>deftype</code> looks like <code>defrecord</code>
<ul class="org-ul">
<li>But provides <i>no</i> default behavior
</li>
<li>Not even <code>equals</code> or <code>hashCode</code>!
</li>
<li>Fields can be mutable (super-advanced)
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-7-1" class="outline-5">
<h5 id="sec-2-2-7-1"><code>deftype</code> example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-2-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">deftype</span> <span class="org-function-name">Point</span> [x y])  <span class="org-comment">; named type with fields</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; user.Point</span>

(<span class="org-keyword">def</span> <span class="org-function-name">p</span> (-&gt;<span class="org-preprocessor">Point</span> 1 2))  <span class="org-comment">; constructor</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/p          ; (but no map-&gt;Point)</span>

(.-x p)                <span class="org-comment">; ordinary field access</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1                 ; (but no keyword lookup)</span>

(<span class="org-variable-name">class</span> p)              <span class="org-comment">; ordinary class</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; user.Point</span>

(<span class="org-variable-name">supers</span> (<span class="org-variable-name">class</span> p))     <span class="org-comment">; an (almost) blank slate</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #{java.lang.Object clojure.lang.IType}</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">LAB: Rock, Paper, Scissors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-3">
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Introduction</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
In this lab, we will write programs to play the classic game of <a href="http://en.wikipedia.org/wiki/Rock-paper-scissors">Rock, Paper, Scissors</a>. The rules are pretty simple:
</p>

<ul class="org-ul">
<li>Rock beats Scissors
</li>
<li>Scissors beats Paper
</li>
<li>Paper beats Rock
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">World domination</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
Define a function <code>dominates</code> that takes a keyword argument and returns the keyword naming the thing that beats it.
</p>

<p>
Hint: remember that data structures are functions.
</p>
</div>

<div id="outline-container-sec-2-3-2-1" class="outline-5">
<h5 id="sec-2-3-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">dominates</span>
  {<span class="org-constant">:rock</span> <span class="org-constant">:paper</span>
   <span class="org-constant">:scissors</span> <span class="org-constant">:rock</span>
   <span class="org-constant">:paper</span> <span class="org-constant">:scissors</span>})
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">Choices, choices</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
Define a vector of the possible choices, reusing the definition of <code>dominates</code>.
</p>

<p>
Hint: the <code>keys</code> function returns a sequence of the keys in a map.
</p>
</div>

<div id="outline-container-sec-2-3-3-1" class="outline-5">
<h5 id="sec-2-3-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">choices</span> (<span class="org-variable-name">vec</span> (<span class="org-variable-name">keys</span> dominates)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4">Winners and losers</h4>
<div class="outline-text-4" id="text-2-3-4">
<p>
Define a function <code>winner</code> that takes two players' choices and returns the winner, or <code>nil</code> for a tie.
</p>
</div>

<div id="outline-container-sec-2-3-4-1" class="outline-5">
<h5 id="sec-2-3-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">winner</span> [p1-choice p2-choice]
  (<span class="org-builtin">cond</span>
   (<span class="org-variable-name">=</span> p1-choice p2-choice) nil
   (<span class="org-variable-name">=</span> (dominates p1-choice) p2-choice) p2-choice
   <span class="org-constant">:else</span> p1-choice))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-5" class="outline-4">
<h4 id="sec-2-3-5">Draws and ties</h4>
<div class="outline-text-4" id="text-2-3-5">
<p>
Define two predicates:
</p>

<ul class="org-ul">
<li><code>draw?</code> takes two players' choices and returns true if they are a draw
</li>
<li><code>iwon?</code> takes two players' choices and returns true if the first player won
</li>
</ul>
</div>

<div id="outline-container-sec-2-3-5-1" class="outline-5">
<h5 id="sec-2-3-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">draw?</span> [me you] (<span class="org-variable-name">=</span> me you))

(<span class="org-keyword">defn</span> <span class="org-function-name">iwon?</span> [me you] (<span class="org-variable-name">=</span> (winner me you) me))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-6" class="outline-4">
<h4 id="sec-2-3-6">The players</h4>
<div class="outline-text-4" id="text-2-3-6">
<p>
All the players will conform to a <code>Player</code> protocol. It should have two methods:
</p>

<ul class="org-ul">
<li><code>choose</code> takes a player and returns that player's choice
</li>
<li><code>update-player</code> takes a player, that player's last choice, and the other player's last choice, returning a new <code>Player</code> for the next round
</li>
</ul>

<p>
Define the <code>Player</code> protocol.
</p>
</div>

<div id="outline-container-sec-2-3-6-1" class="outline-5">
<h5 id="sec-2-3-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defprotocol</span> <span class="org-function-name">Player</span>
  (choose [p])
  (update-player [p me you]))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-7" class="outline-4">
<h4 id="sec-2-3-7">Random player</h4>
<div class="outline-text-4" id="text-2-3-7">
<p>
Define a <code>Random</code> player who always picks at random and never changes strategy based on what the other player is doing.
</p>

<p>
Hint: Clojure's <code>rand-nth</code> function picks a random element from a collection.
</p>
</div>

<div id="outline-container-sec-2-3-7-1" class="outline-5">
<h5 id="sec-2-3-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Random</span> []
  <span class="org-preprocessor">Player</span>
  (choose [_] (rand-nth choices))
  (update-player [this me you] this))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-8" class="outline-4">
<h4 id="sec-2-3-8">Stubborn player</h4>
<div class="outline-text-4" id="text-2-3-8">
<p>
Define a <code>Stubborn</code> player who is initialized with a choice and sticks with it no matter what.
</p>
</div>

<div id="outline-container-sec-2-3-8-1" class="outline-5">
<h5 id="sec-2-3-8-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-8-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Stubborn</span> [choice]
  <span class="org-preprocessor">Player</span>
  (choose [_] choice)
  (update-player [this me you] this))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-9" class="outline-4">
<h4 id="sec-2-3-9">Mean player</h4>
<div class="outline-text-4" id="text-2-3-9">
<p>
Define a <code>Mean</code> player, who is slightly more subtle. The mean player sticks with what worked last time if it won, or plays at random following a loss.
</p>
</div>

<div id="outline-container-sec-2-3-9-1" class="outline-5">
<h5 id="sec-2-3-9-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-9-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Mean</span> [last-winner]
  <span class="org-preprocessor">Player</span>
  (choose [_]
    (<span class="org-builtin">if</span> last-winner last-winner (rand-nth choices)))
  (update-player [_ me you]
    (-&gt;<span class="org-preprocessor">Mean</span> (<span class="org-builtin">when</span> (iwon? me you) me))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-10" class="outline-4">
<h4 id="sec-2-3-10">Playing a game</h4>
<div class="outline-text-4" id="text-2-3-10">
<p>
Define a <code>game</code> function with three arguments: two players and a number of rounds. The game should return the two player's scores in a map.
</p>

<p>
This can be nicely represented as a <code>loop</code> with five variables:
</p>

<ol class="org-ol">
<li>Player One
</li>
<li>Player Two
</li>
<li>Player One's current score
</li>
<li>Player Two's current score
</li>
<li>The number of rounds remaining
</li>
</ol>

<p>
Try some games with various combinations of players. Do the results match your intuition?
</p>
</div>

<div id="outline-container-sec-2-3-10-1" class="outline-5">
<h5 id="sec-2-3-10-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-10-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">game</span>
  [p1 p2 rounds]
  (<span class="org-builtin">loop</span> [p1 p1
         p2 p2
         p1-score 0
         p2-score 0
         rounds rounds]
    (<span class="org-builtin">if</span> (<span class="org-variable-name">pos?</span> rounds)
      (<span class="org-builtin">let</span> [p1-choice (choose p1)
            p2-choice (choose p2)
            result (winner p1-choice p2-choice)]
        (<span class="org-builtin">recur</span>
         (update-player p1 p1-choice p2-choice)
         (update-player p2 p2-choice p1-choice)
         (<span class="org-variable-name">+</span> p1-score (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> result p1-choice) 1 0))
         (<span class="org-variable-name">+</span> p2-score (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> result p2-choice) 1 0))
         (<span class="org-variable-name">dec</span> rounds)))
      {<span class="org-constant">:p1</span> p1-score <span class="org-constant">:p2</span> p2-score})))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-10-2" class="outline-5">
<h5 id="sec-2-3-10-2">Examples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-3-10-2">
<div class="org-src-container">

<pre class="src src-clojure">(game (-&gt;<span class="org-preprocessor">Stubborn</span> <span class="org-constant">:rock</span>) (-&gt;<span class="org-preprocessor">Stubborn</span> <span class="org-constant">:scissors</span>) 100)
</pre>
</div>

<pre class="example">
;;=&gt; {:p1 100, :p2 0}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(game (-&gt;<span class="org-preprocessor">Random</span>) (-&gt;<span class="org-preprocessor">Random</span>) 100)
</pre>
</div>

<pre class="example">
;;=&gt; {:p1 34, :p2 25}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(game (-&gt;<span class="org-preprocessor">Stubborn</span> <span class="org-constant">:rock</span>) (-&gt;<span class="org-preprocessor">Mean</span> nil) 100)
</pre>
</div>

<pre class="example">
;;=&gt; {:p1 5, :p2 93}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-11" class="outline-4">
<h4 id="sec-2-3-11">Bonus: More strategies</h4>
<div class="outline-text-4" id="text-2-3-11">
<p>
Define some players with more sophisticated strategies. 
</p>

<p>
Compare them with example strategies in the <a href="http://webdocs.cs.ualberta.ca/~darse/rsb-ts1.c">International RoShamBo Programming Competition</a> (in C) and <a href="http://rubyquiz.com/quiz16.html">Ruby Quiz #16</a>.
</p>
</div>
</div>
<div id="outline-container-sec-2-3-12" class="outline-4">
<h4 id="sec-2-3-12">Bonus: Spock, Lizard</h4>
<div class="outline-text-4" id="text-2-3-12">
<p>
Extend the simulation to support <a href="http://www.samkass.com/theories/RPSSL.html">Rock, Paper, Scissors, Spock, Lizard</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Concurrency&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-4">
</div>

<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">Concurrency Introduction</h4>
<div class="outline-text-4" id="text-2-4-1">
</div><div id="outline-container-sec-2-4-1-1" class="outline-5">
<h5 id="sec-2-4-1-1">Identity, Value, State&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-1-1">
<ul class="org-ul">
<li>Identity: a logical entity
<ul class="org-ul">
<li>Spouse, today, employer, shipping address
</li>
</ul>
</li>
<li>Value: immutable data
<ul class="org-ul">
<li>5, "Bob", [0, 1, 2]
</li>
</ul>
</li>
<li>State: the value of an identity at a given time
<ul class="org-ul">
<li>Today is September 15th, 2010
</li>
<li>My son is 6 years old
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-1-2" class="outline-5">
<h5 id="sec-2-4-1-2">OOP with Mutable State&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-1-2">
<ul class="org-ul">
<li>Identities are pointers to locations in memory
</li>
<li>Objects changed in-place
</li>
<li>Updating state means overwriting memory
<ul class="org-ul">
<li>Need to protect reads/writes
</li>
<li>No language support for coordinating change
</li>
<li>Locking, deadlocks, nightmares
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-1-3" class="outline-5">
<h5 id="sec-2-4-1-3">Clojure's Approach&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-1-3">
<ul class="org-ul">
<li>Identities are managed references to immutable values
</li>
<li>Nothing changed in-place
</li>
<li>References provide read/write protection
</li>
<li>Language-level constructs to manage change
</li>
<li>No locking in user code
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">Conceptual Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-2">
</div><div id="outline-container-sec-2-4-2-1" class="outline-5">
<h5 id="sec-2-4-2-1">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-2-1">

<div class="figure">
<p><img src="slide-assets/identity-state-01.svg" alt="identity-state-01.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-2-2" class="outline-5">
<h5 id="sec-2-4-2-2">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-2-2">

<div class="figure">
<p><img src="slide-assets/identity-state-02.svg" alt="identity-state-02.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-2-3" class="outline-5">
<h5 id="sec-2-4-2-3">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-2-3">

<div class="figure">
<p><img src="slide-assets/identity-state-03.svg" alt="identity-state-03.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-2-4" class="outline-5">
<h5 id="sec-2-4-2-4">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-2-4">

<div class="figure">
<p><img src="slide-assets/identity-state-04.svg" alt="identity-state-04.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-2-5" class="outline-5">
<h5 id="sec-2-4-2-5">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-2-5">

<div class="figure">
<p><img src="slide-assets/identity-state-05.svg" alt="identity-state-05.svg" />
</p>
</div>

<ul class="org-ul">
<li>The future is a function of the past.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2-6" class="outline-5">
<h5 id="sec-2-4-2-6">Uniform State Transition Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-2-6">
<ul class="org-ul">
<li><code>(<i style='font-family: serif'>change-state</i> reference function args*)</code>
<ul class="org-ul">
<li>Calls function on old state + args
</li>
<li>Function returns new state
</li>
<li>Different <i>change-state</i> functions for different behavior
</li>
</ul>
</li>
<li><code>(deref reference)</code>
<ul class="org-ul">
<li>Shorthand: <code>@reference</code>
</li>
<li>Returns snapshot of current state
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2-7" class="outline-5">
<h5 id="sec-2-4-2-7">Mutable Reference Types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-2-7">
<ul class="org-ul">
<li>Synchronous
<ul class="org-ul">
<li>Uncoordinated: Var, Atom
</li>
<li>Coordinated: Ref
</li>
</ul>
</li>
<li>Asynchronous
<ul class="org-ul">
<li>Write-many: Agent
</li>
<li>Write-once: Future, Promise
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3">Atoms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-3">
</div><div id="outline-container-sec-2-4-3-1" class="outline-5">
<h5 id="sec-2-4-3-1">Atoms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-3-1">
<ul class="org-ul">
<li>Share a single identity across threads
</li>
<li>Changes visible to all threads at the same time
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-3-2" class="outline-5">
<h5 id="sec-2-4-3-2">Atom Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-3-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">tick</span> (<span class="org-variable-name">atom</span> 1))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/tick</span>

(<span class="org-variable-name">deref</span> tick)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1</span>

(<span class="org-variable-name">swap!</span> tick inc)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>

@tick
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-3-3" class="outline-5">
<h5 id="sec-2-4-3-3">Atom Guarantees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-3-3">
<ul class="org-ul">
<li>Change is <i>synchronous</i> on caller thread
</li>
<li>Changes are <i>atomic</i>
</li>
<li>No locking
</li>
<li>No deadlocks
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-3-4" class="outline-5">
<h5 id="sec-2-4-3-4">Atom Caveats&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-3-4">
<ul class="org-ul">
<li>Values must be immutable
</li>
<li>Cannot atomically update more than one
</li>
<li>Spinning compare-and-set
<ul class="org-ul">
<li>Functions should be quick
</li>
<li>Function may be called more than once
</li>
<li>Must avoid side effects!
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4">Refs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-4">
</div><div id="outline-container-sec-2-4-4-1" class="outline-5">
<h5 id="sec-2-4-4-1">Refs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-4-1">
<ul class="org-ul">
<li>Share identities across threads
</li>
<li>Coordinated change among multiple identities
</li>
<li>Consistent view of the whole world
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4-2" class="outline-5">
<h5 id="sec-2-4-4-2">Ref Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-4-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">ref</span> 1))
(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">ref</span> 10))

(<span class="org-builtin">dosync</span>
 (<span class="org-variable-name">alter</span> a inc)
 (<span class="org-variable-name">alter</span> b + 10))

@a  <span class="org-comment">;=&gt; 2</span>
@b  <span class="org-comment">;=&gt; 20</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-4-3" class="outline-5">
<h5 id="sec-2-4-4-3">Ref Guarantees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-4-3">
<ul class="org-ul">
<li>Change is <i>synchronous</i> on caller thread
</li>
<li>Change can only occur in a transaction
</li>
<li>Every transaction is <i>atomic</i> and <i>isolated</i>
</li>
<li>No locking in user code
</li>
<li>Internal locking &amp; deadlock prevention
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4-4" class="outline-5">
<h5 id="sec-2-4-4-4">Within a Transaction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-4-4">
<ul class="org-ul">
<li>Consistent snapshot of "Ref world" from point where transaction started
</li>
<li>Transaction can see changes it has made
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4-5" class="outline-5">
<h5 id="sec-2-4-4-5">Ref Caveats&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-4-5">
<ul class="org-ul">
<li>Values must be immutable
</li>
<li>Transactions are speculative
<ul class="org-ul">
<li>Body may be called more than once
</li>
<li>Must avoid side effects!
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4-6" class="outline-5">
<h5 id="sec-2-4-4-6">No Read Tracking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-4-6">
<ul class="org-ul">
<li>Reading a Ref does not prevent other transactions from changing it
</li>
<li>Transaction does not see changes made by other transactions
</li>
<li>Protect from changes with <code>ensure</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4-7" class="outline-5">
<h5 id="sec-2-4-4-7"><code>ensure</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-4-7">
<p>
In this example, the fee may change during the life of the
transaction and the transaction will only see the starting value.
</p>
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">savings and fee are refs</span>
(<span class="org-builtin">dosync</span>
  (<span class="org-variable-name">alter</span> savings + @fee))
</pre>
</div>

<p>
Use ensure to guarantee that if the fee changes, the transaction will
fail and retry:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">dosync</span>
  (<span class="org-variable-name">alter</span> savings + (<span class="org-variable-name">ensure</span> fee)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-4-8" class="outline-5">
<h5 id="sec-2-4-4-8"><code>commute</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-4-8">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">counter</span> (<span class="org-variable-name">ref</span> 1))

(<span class="org-builtin">dosync</span> (<span class="org-variable-name">commute</span> counter inc))

<span class="org-comment-delimiter">;; </span><span class="org-comment">On another thread:</span>
(<span class="org-builtin">dosync</span> (<span class="org-variable-name">commute</span> counter + 30))
</pre>
</div>

<ul class="org-ul">
<li>Order of updates doesn't matter
</li>
<li>More concurrency than alter
</li>
<li>Just an optimization
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-5" class="outline-4">
<h4 id="sec-2-4-5">Agents&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-5">
</div><div id="outline-container-sec-2-4-5-1" class="outline-5">
<h5 id="sec-2-4-5-1">Agents&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-5-1">
<ul class="org-ul">
<li>Share identities across threads
</li>
<li>Ensure an entity only does one thing at a time
</li>
<li>Send messages between entities
</li>
<li>Utilize all available CPU cores
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-5-2" class="outline-5">
<h5 id="sec-2-4-5-2">Agent Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-5-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">agent</span> 5))

(<span class="org-variable-name">send</span> a + 10)  <span class="org-comment">; returns immediately</span>
@a  <span class="org-comment">; =&gt; still 5</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Some time later:</span>
@a  <span class="org-comment">; =&gt; 15</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-5-3" class="outline-5">
<h5 id="sec-2-4-5-3">Agent Guarantees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-5-3">
<ul class="org-ul">
<li>Action occurs <i>asynchronously</i> on thread pool
</li>
<li>Action called exactly once
</li>
<li>Only one action per Agent at a time
</li>
<li>Sends during an action
<ul class="org-ul">
<li>Occur <i>after</i> state has been updated
</li>
<li>Do not occur if action throws an exception
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-5-4" class="outline-5">
<h5 id="sec-2-4-5-4"><code>send</code> vs. <code>send-off</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-5-4">
<ul class="org-ul">
<li><code>send</code>
<ul class="org-ul">
<li>Fixed-size thread pool
</li>
<li>Actions should not block
</li>
<li>For CPU-bound tasks
</li>
</ul>
</li>
<li><code>send-off</code>
<ul class="org-ul">
<li>Variable-sized thread pool
</li>
<li>Actions may block
</li>
<li>For IO-bound tasks
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-5-5" class="outline-5">
<h5 id="sec-2-4-5-5">Agents Are Not Actors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-5-5">
<ul class="org-ul">
<li>In-process only
</li>
<li>Point-in-time perception is free
</li>
<li>Send functions, not messages
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-5-6" class="outline-5">
<h5 id="sec-2-4-5-6">Agents and Transactions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-5-6">
<ul class="org-ul">
<li>Sends during a transaction
<ul class="org-ul">
<li>An allowable side-effect
</li>
<li>Occur <i>after</i> transaction is committed
</li>
<li>Do not occur if transaction is aborted
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-6" class="outline-4">
<h4 id="sec-2-4-6">Vars&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-6">
</div><div id="outline-container-sec-2-4-6-1" class="outline-5">
<h5 id="sec-2-4-6-1">Vars&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-6-1">
<ul class="org-ul">
<li>Thread-safe global identity
</li>
<li>Optional dynamic scope/overrides
</li>
<li>Changes isolated to a single thread
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-6-2" class="outline-5">
<h5 id="sec-2-4-6-2">Var Guarantees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-6-2">
<ul class="org-ul">
<li>One global root binding
<ul class="org-ul">
<li><code>alter-var-root</code> is <i>atomic</i> and <i>blocking</i>
</li>
</ul>
</li>
<li>With <code>^:dynamic</code>
<ul class="org-ul">
<li>Many thread-local bindings
</li>
<li>Thread-local assignment
</li>
<li>Dynamic scope
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-6-3" class="outline-5">
<h5 id="sec-2-4-6-3">Var Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-6-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">foo</span> 1)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/foo</span>

(<span class="org-variable-name">alter-var-root</span> #'foo inc)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>

foo
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-6-4" class="outline-5">
<h5 id="sec-2-4-6-4">Dynamic Var Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-6-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-constant">^:dynamic</span> <span class="org-function-name">*foo*</span> 5)  <span class="org-comment">; root binding is 5</span>

(<span class="org-builtin">binding</span> [*foo* 100]  <span class="org-comment">; thread-local binding</span>
  (<span class="org-variable-name">println</span> *foo*)     <span class="org-comment">; =&gt; 100</span>
  (set! *foo* 42)     <span class="org-comment">; thread-local assignment</span>
  (<span class="org-variable-name">println</span> *foo*))    <span class="org-comment">; =&gt; 42</span>

*foo*  <span class="org-comment">; root binding still 5</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-7" class="outline-4">
<h4 id="sec-2-4-7">Uniform State Transition Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-7">
</div><div id="outline-container-sec-2-4-7-1" class="outline-5">
<h5 id="sec-2-4-7-1">Uniform State Transition Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-7-1">
<div class="org-src-container">

<pre class="src src-clojure">         (<span class="org-variable-name">swap!</span> an-atom  assoc <span class="org-constant">:a</span> <span class="org-string">"lucy"</span>)

 (<span class="org-builtin">dosync</span> (<span class="org-variable-name">alter</span> a-ref    assoc <span class="org-constant">:a</span> <span class="org-string">"lucy"</span>))

          (<span class="org-variable-name">send</span> an-agent assoc <span class="org-constant">:a</span> <span class="org-string">"lucy"</span>)

(<span class="org-variable-name">alter-var-root</span> #'a-var  assoc <span class="org-constant">:a</span> <span class="org-string">"lucy"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-7-2" class="outline-5">
<h5 id="sec-2-4-7-2">Breaking the State Transition Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-7-2">
<div class="org-src-container">

<pre class="src src-clojure">         (<span class="org-variable-name">reset!</span> an-atom  42)

(<span class="org-builtin">dosync</span> (<span class="org-variable-name">ref-set</span> a-ref    42))

           (<span class="org-variable-name">send</span> an-agent (<span class="org-variable-name">constantly</span> 42))

 (<span class="org-variable-name">alter-var-root</span> #'a-var  (<span class="org-variable-name">constantly</span> 42))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-8" class="outline-4">
<h4 id="sec-2-4-8">Watches&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-8">
</div><div id="outline-container-sec-2-4-8-1" class="outline-5">
<h5 id="sec-2-4-8-1">Watches&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-8-1">
<ul class="org-ul">
<li>Get notified when a reference changes
</li>
<li>Supports Atom, Ref, Agent, and Var
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-8-2" class="outline-5">
<h5 id="sec-2-4-8-2">Watch Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-8-2">
<ul class="org-ul">
<li>Arguments: key, reference, old and new states
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">my-watcher</span> [key reference old-state new-state]
  (<span class="org-variable-name">println</span> <span class="org-string">"Watcher called for"</span> key)
  (<span class="org-variable-name">println</span> <span class="org-string">"Old state:"</span> old-state)
  (<span class="org-variable-name">println</span> <span class="org-string">"New state:"</span> new-state))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-8-3" class="outline-5">
<h5 id="sec-2-4-8-3"><code>add-watch</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-8-3">
<ul class="org-ul">
<li>Arguments: reference, key, watch function
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(add-watch r <span class="org-constant">:foo</span> my-watcher)

(<span class="org-builtin">dosync</span> (<span class="org-variable-name">alter</span> r inc))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Watcher called for :foo</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Old state: 42</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">New state: 43</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 43</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-9" class="outline-4">
<h4 id="sec-2-4-9">Futures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-9">
</div><div id="outline-container-sec-2-4-9-1" class="outline-5">
<h5 id="sec-2-4-9-1">Futures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-9-1">
<ul class="org-ul">
<li>Execute code in a background thread
<ul class="org-ul">
<li>Possibly with side effects
</li>
</ul>
</li>
<li>Block only when we ask for the result
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-9-2" class="outline-5">
<h5 id="sec-2-4-9-2">Future Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-9-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">f</span> (<span class="org-variable-name">future</span>
         <span class="org-comment-delimiter">;; </span><span class="org-comment">body of expressions</span>
         ))
<span class="org-comment-delimiter">;; </span><span class="org-comment">body starts on background thread</span>

@f  <span class="org-comment">; blocks until complete, returns result</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-10" class="outline-4">
<h4 id="sec-2-4-10">Promises&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-10">
</div><div id="outline-container-sec-2-4-10-1" class="outline-5">
<h5 id="sec-2-4-10-1">Promises&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-10-1">
<ul class="org-ul">
<li>Communicate a single value across threads
</li>
<li>Set once
</li>
<li>Wait until a value becomes available
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-10-2" class="outline-5">
<h5 id="sec-2-4-10-2">Promise Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-10-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">p</span> (<span class="org-variable-name">promise</span>))

<span class="org-comment-delimiter">;; </span><span class="org-comment">on another thread</span>
(<span class="org-variable-name">deliver</span> p 42)

@p  <span class="org-comment">; blocks until delivered</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-10-3" class="outline-5">
<h5 id="sec-2-4-10-3">Inverting Async&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-4-10-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">p</span> (<span class="org-variable-name">promise</span>))

(<span class="org-variable-name">future</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">do something that takes time</span>
  (<span class="org-variable-name">deliver</span> p 42))

<span class="org-comment-delimiter">;; </span><span class="org-comment">do something else for a while</span>

@p  <span class="org-comment">; blocks until delivered</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-11" class="outline-4">
<h4 id="sec-2-4-11">Concurrency and the JVM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-4-11">
<ul class="org-ul">
<li><code>java.util.concurrent</code> is still there
<ul class="org-ul">
<li>thread pools, locks, atomics, concurrent collections
</li>
<li>Clojure fns are <code>java.util.concurrent.Callable</code>
<ul class="org-ul">
<li>And <code>java.lang.Runnable</code>
</li>
</ul>
</li>
</ul>
</li>
<li>Clojure's concurrency features are thread-agnostic
<ul class="org-ul">
<li>Use Futures/Agents to create threads
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">LAB: Concurrent Surgery&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-5">
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">Introduction</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
In this lab, we will build a crude simulation of a hospital in which surgeons perform operations on patients. In order to focus on the specific topic of concurrency, we will provide most of the initial setup code for you to copy-and-paste.
</p>

<p>
Patients are mutable references. We'll start with Atoms. Each patient has an initial state of two arms, two legs, and one head. There are 1000 patients in the hospital.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">patient</span> []
  (<span class="org-variable-name">atom</span> {<span class="org-constant">:arms</span> 2
         <span class="org-constant">:legs</span> 2
         <span class="org-constant">:heads</span> 1}))

(<span class="org-keyword">defn</span> <span class="org-function-name">init-patients</span> []
  (<span class="org-variable-name">vec</span> (<span class="org-variable-name">repeatedly</span> 1000 patient)))
</pre>
</div>

<p>
There are 100 surgeons in the hospital. Each surgeon specializes in operating on one particular part of the body.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">surgeon</span> [specialty] 
  {<span class="org-constant">:specialty</span> specialty})

(<span class="org-keyword">defn</span> <span class="org-function-name">init-surgeons</span> []
  (<span class="org-variable-name">vec</span> (<span class="org-variable-name">take</span> 100 (<span class="org-variable-name">map</span> surgeon (<span class="org-variable-name">cycle</span> [<span class="org-constant">:arms</span> <span class="org-constant">:legs</span> <span class="org-constant">:heads</span>])))))
</pre>
</div>

<p>
The global state of the simulation will be stored in two Vars:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">all-patients</span> nil)
(<span class="org-keyword">def</span> <span class="org-function-name">all-surgeons</span> nil)

(<span class="org-keyword">defn</span> <span class="org-function-name">init!</span> []
  (<span class="org-variable-name">alter-var-root</span> #'all-patients (<span class="org-variable-name">constantly</span> (init-patients)))
  (<span class="org-variable-name">alter-var-root</span> #'all-surgeons (<span class="org-variable-name">constantly</span> (init-surgeons))))
</pre>
</div>

<p>
Our hospital is very conscientious about keeping track of body parts. We want to count the total number of arms, legs, and heads to verify that it stays constant.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">totals</span> []
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">partial</span> merge-with +)
          (<span class="org-variable-name">map</span> deref all-patients)))
</pre>
</div>

<p>
For example, at the REPL:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(init!)
(totals)
</pre>
</div>

<pre class="example">
;;=&gt; {:legs 2000, :arms 2000, :heads 1000}
</pre>
</div>
</div>
<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2">Modifying patients</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
Surgeons perform transplant operations on patients by removing a limb from one patient and adding it to another patient. The particular limb they choose is determined by their specialty.
</p>

<p>
Define a function <code>transplant!</code> that takes a surgeon and two patients, gets the surgeon's specialty, and modifies the number of limbs on each patient.
</p>
</div>

<div id="outline-container-sec-2-5-2-1" class="outline-5">
<h5 id="sec-2-5-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-5-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transplant!</span> [surgn p1 p2]
  (<span class="org-builtin">let</span> [limb (<span class="org-constant">:specialty</span> surgn)]
    (<span class="org-variable-name">swap!</span> p1 update-in [limb] dec)
    (<span class="org-variable-name">swap!</span> p2 update-in [limb] inc)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-5-3" class="outline-4">
<h4 id="sec-2-5-3">Single-threaded operation</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
To select patients for transplant operations, our hospital randomly chooses two patients who are near each other.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">select-patients</span> []
  (<span class="org-builtin">let</span> [n1 (<span class="org-variable-name">rand</span> (<span class="org-variable-name">count</span> all-patients))
        n2 (<span class="org-variable-name">mod</span> (<span class="org-variable-name">inc</span> n1) (<span class="org-variable-name">count</span> all-patients))]
    [(<span class="org-variable-name">nth</span> all-patients n1) (<span class="org-variable-name">nth</span> all-patients n2)]))
</pre>
</div>

<p>
Each operation involves one surgeon and two patients.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">operate!</span> []
  (<span class="org-builtin">let</span> [surgn (rand-nth all-surgeons)
        [p1 p2] (select-patients)]
    (transplant! surgn p1 p2)))
</pre>
</div>

<p>
To begin with, assume there is only one operating room at the hospital. Define a function <code>run!</code> to initialize the simulation and perform 10,000 operations, then print the totals. 
</p>

<p>
Does the simulation make sense? Examine some of the patients. Does it still make sense?
</p>
</div>

<div id="outline-container-sec-2-5-3-1" class="outline-5">
<h5 id="sec-2-5-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-5-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-builtin">dotimes</span> [_ 10000] (operate!))
  (totals))
</pre>
</div>

<p>
At the REPL:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(run!)
</pre>
</div>

<pre class="example">
;;=&gt; {:legs 2000, :arms 2000, :heads 1000}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (<span class="org-variable-name">map</span> deref all-patients))
</pre>
</div>

<pre class="example">
;;=&gt; ({:legs 2, :arms -2, :heads 2} {:legs 1, :arms 3, :heads 5} {:legs 2, :arms 2, :heads 1} {:legs 4, :arms 2, :heads 0} {:legs 1, :arms -1, :heads -1} {:legs 5, :arms 3, :heads 2} {:legs -2, :arms 5, :heads 0} {:legs 6, :arms -3, :heads -1} {:legs -1, :arms 5, :heads 4} {:legs 2, :arms 5, :heads 0})
</pre>

<p>
Some of our patients have negative numbers of limbs, which is impossible. The simulation is flawed.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-5-4" class="outline-4">
<h4 id="sec-2-5-4">Correct single-threaded operation</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
Add a condition to the <code>transplant!</code> function that only performs the operation if the "donating" patient has the requisite limb. (You will also need to reload/redefine <code>operate!</code> and <code>run!</code>.) Run the simulation again. Is it correct?
</p>
</div>

<div id="outline-container-sec-2-5-4-1" class="outline-5">
<h5 id="sec-2-5-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-5-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transplant!</span> [surgn p1 p2]
  (<span class="org-builtin">let</span> [limb (<span class="org-constant">:specialty</span> surgn)]
    (<span class="org-builtin">when</span> (<span class="org-variable-name">pos?</span> (@p1 limb))
     (<span class="org-variable-name">swap!</span> p1 update-in [limb] dec)
     (<span class="org-variable-name">swap!</span> p2 update-in [limb] inc))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">These are the same, but need to be redefined/reloaded:</span>

(<span class="org-keyword">defn</span> <span class="org-function-name">operate!</span> []
  (<span class="org-builtin">let</span> [surgn (rand-nth all-surgeons)
        [p1 p2] (select-patients)]
    (transplant! surgn p1 p2)))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-builtin">dotimes</span> [_ 10000] (operate!))
  (totals))
</pre>
</div>

<p>
At the REPL:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(run!)
</pre>
</div>

<pre class="example">
;;=&gt; {:legs 2000, :arms 2000, :heads 1000}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (<span class="org-variable-name">map</span> deref all-patients))
</pre>
</div>

<pre class="example">
;;=&gt; ({:legs 2, :arms 3, :heads 1} {:legs 3, :arms 0, :heads 0} {:legs 0, :arms 3, :heads 0} {:legs 0, :arms 5, :heads 0} {:legs 4, :arms 1, :heads 1} {:legs 0, :arms 1, :heads 4} {:legs 3, :arms 1, :heads 0} {:legs 2, :arms 1, :heads 1} {:legs 4, :arms 4, :heads 1} {:legs 1, :arms 2, :heads 2})
</pre>

<p>
For the single-threaded case, the simulation is correct.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-5-5" class="outline-4">
<h4 id="sec-2-5-5">Multi-threaded operation</h4>
<div class="outline-text-4" id="text-2-5-5">
<p>
Suppose our hospital expands to 5 operating rooms, all of which can be used at the same time. Redefine <code>run!</code> to run 10,000 operations in each operating room on its own thread. (Hint: each room is a <code>future</code>.) Wait for the threads to finish (use <code>deref</code>) then examine the results. Is the simulation correct?
</p>
</div>

<div id="outline-container-sec-2-5-5-1" class="outline-5">
<h5 id="sec-2-5-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-5-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">operating-room</span> []
  (<span class="org-variable-name">future</span>
    (<span class="org-builtin">dotimes</span> [_ 10000] (operate!))))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-builtin">let</span> [rooms (<span class="org-builtin">doall</span> (<span class="org-variable-name">repeatedly</span> 5 operating-room))]
    (<span class="org-builtin">dorun</span> (<span class="org-variable-name">map</span> deref rooms))
    (totals)))
</pre>
</div>

<p>
The setup here may require some explanation. The call to <code>repeatedly</code> returns a <b>lazy</b> sequence of futures. To force all the futures to start at the same time, we force the sequence to be realized with <code>doall</code>. 
</p>

<p>
Before printing the totals, we want to wait for the simulation to finish. We can block our REPL thread on each of the other threads by mapping <code>deref</code> over the sequence of futures. The <code>map</code> function is also lazy, but we don't care about the return values, so we use <code>dorun</code> to force the sequence and discard the results.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(run!)
</pre>
</div>

<pre class="example">
;;=&gt; {:legs 2000, :arms 2000, :heads 1000}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (<span class="org-variable-name">map</span> deref all-patients))
</pre>
</div>

<pre class="example">
;;=&gt; ({:legs 1, :arms 4, :heads 0} {:legs 3, :arms 2, :heads 0} {:legs 0, :arms 0, :heads 0} {:legs 1, :arms 1, :heads 2} {:legs 4, :arms 0, :heads 1} {:legs 0, :arms 2, :heads 0} {:legs 2, :arms 3, :heads 3} {:legs 1, :arms 2, :heads 2} {:legs 4, :arms 3, :heads 0} {:legs 0, :arms 3, :heads 1})
</pre>

<p>
The simulation looks correct, but it isn't: see the next exercise.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-5-6" class="outline-4">
<h4 id="sec-2-5-6">Finding the variant</h4>
<div class="outline-text-4" id="text-2-5-6">
<p>
Looking at a piece of multi-threaded code from the outside, it can be difficult to recognize bugs. Our current hospital simulation appears to be correct, but we're only auditing the final results, not the intermediate states. 
</p>

<p>
Let's add another thread that performs periodic audits while the operating rooms are in use. 
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">auditor</span> []
  (<span class="org-variable-name">future</span>
    (<span class="org-builtin">dotimes</span> [_ 10]
      (<span class="org-variable-name">println</span> (totals)))))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-variable-name">println</span> <span class="org-string">"Finding the variant:"</span>)
  (<span class="org-builtin">let</span> [audit (auditor)
        rooms (<span class="org-builtin">doall</span> (<span class="org-variable-name">repeatedly</span> 5 operating-room))]
    (<span class="org-builtin">dorun</span> (<span class="org-variable-name">map</span> deref rooms))
    (<span class="org-variable-name">deref</span> audit)))
</pre>
</div>

<p>
Examine the results. What is wrong?
</p>
</div>

<div id="outline-container-sec-2-5-6-1" class="outline-5">
<h5 id="sec-2-5-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-5-6-1">
<p>
The simulation prints something like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 1998, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2002, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 2001, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 1999, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 1999, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 1999, <span class="org-constant">:arms</span> 1999, <span class="org-constant">:heads</span> 999}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 1998, <span class="org-constant">:heads</span> 1000}
</pre>
</div>

<p>
Notice that the number of arms, legs, and heads is not always consistent. When we look at the patients while the simulation is running, sometimes we catch them in the middle of an operation, when a limb has been removed from one patient but not yet added to the other. This makes it hard to be certain that we always have the correct number of arms, legs, and heads.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-5-7" class="outline-4">
<h4 id="sec-2-5-7">Refs for coordination</h4>
<div class="outline-text-4" id="text-2-5-7">
<p>
The problem with our simulation is that each operation involves two patients. We want the state to be consistent across both entities, so Atoms are not sufficient.
</p>

<p>
Rewrite the <code>patient</code> and <code>transplant!</code> functions using Refs instead of Atoms. (You will also need to reload/redefine <code>all-patients</code> and <code>operate!</code>.) Run the simulation again. Is it correct?
</p>
</div>

<div id="outline-container-sec-2-5-7-1" class="outline-5">
<h5 id="sec-2-5-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-5-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">patient</span> []
  (<span class="org-variable-name">ref</span> {<span class="org-constant">:arms</span> 2
        <span class="org-constant">:legs</span> 2
        <span class="org-constant">:heads</span> 1}))

(<span class="org-keyword">defn</span> <span class="org-function-name">transplant!</span> [surgn p1 p2]
  (<span class="org-builtin">let</span> [limb (<span class="org-constant">:specialty</span> surgn)]
    (<span class="org-builtin">dosync</span>
     (<span class="org-builtin">when</span> (<span class="org-variable-name">pos?</span> (@p1 limb))
       (<span class="org-variable-name">alter</span> p1 update-in [limb] dec)
       (<span class="org-variable-name">alter</span> p2 update-in [limb] inc)))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">These are the same, but must be reloaded/redefined: </span>

(<span class="org-keyword">defn</span> <span class="org-function-name">init-patients</span> []
  (<span class="org-variable-name">vec</span> (<span class="org-variable-name">repeatedly</span> 1000 patient)))

(<span class="org-keyword">defn</span> <span class="org-function-name">init!</span> []
  (<span class="org-variable-name">alter-var-root</span> #'all-patients (<span class="org-variable-name">constantly</span> (init-patients)))
  (<span class="org-variable-name">alter-var-root</span> #'all-surgeons (<span class="org-variable-name">constantly</span> (init-surgeons))))

(<span class="org-keyword">defn</span> <span class="org-function-name">operate!</span> []
  (<span class="org-builtin">let</span> [surgn (rand-nth all-surgeons)
        [p1 p2] (select-patients)]
    (transplant! surgn p1 p2)))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-variable-name">println</span> <span class="org-string">"Refs for coordination:"</span>)
  (<span class="org-builtin">let</span> [audit (auditor)
        rooms (<span class="org-builtin">doall</span> (<span class="org-variable-name">repeatedly</span> 5 operating-room))]
    (<span class="org-builtin">dorun</span> (<span class="org-variable-name">map</span> deref rooms))
    (<span class="org-variable-name">deref</span> audit)))
</pre>
</div>

<p>
The simulation prints something like:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2001, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 1998, <span class="org-constant">:arms</span> 1999, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 1999, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2001, <span class="org-constant">:arms</span> 1998, <span class="org-constant">:heads</span> 999}
{<span class="org-constant">:legs</span> 2001, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 1999, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
</pre>
</div>

<p>
It's still not correct: see the next exercise.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-5-8" class="outline-4">
<h4 id="sec-2-5-8">Reading in transactions</h4>
<div class="outline-text-4" id="text-2-5-8">
<p>
Although the last exercise fixed the simulation to perform all its state changes inside transactions, the <code>totals</code> function is <b>not</b> running in a transaction. It just zips through all the patients, dereferencing one at a time. There is no guarantee that those values, read at different times, will present a consistent view of the world.
</p>

<p>
If we want our audits to give consistent results, we need to do them in transactions as well. Modify the <code>totals</code> function to run in its own transaction. (You will also need to reload/redefine <code>run!</code>.) Check that the results are what you expect.
</p>
</div>

<div id="outline-container-sec-2-5-8-1" class="outline-5">
<h5 id="sec-2-5-8-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-5-8-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">totals</span> []
  (<span class="org-builtin">dosync</span>
   (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">partial</span> merge-with +)
           (<span class="org-variable-name">map</span> deref all-patients))))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> [] <span class="org-comment">; the same, but must reload/redefine</span>
  (init!)
  (<span class="org-variable-name">println</span> <span class="org-string">"Reading in transactions:"</span>)
  (<span class="org-builtin">let</span> [audit (auditor)
        rooms (<span class="org-builtin">doall</span> (<span class="org-variable-name">repeatedly</span> 5 operating-room))]
    (<span class="org-builtin">dorun</span> (<span class="org-variable-name">map</span> deref rooms))
    (<span class="org-variable-name">deref</span> audit)))
</pre>
</div>

<p>
Results:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-5-9" class="outline-4">
<h4 id="sec-2-5-9">Introducing Agents</h4>
<div class="outline-text-4" id="text-2-5-9">
<p>
Our simulation is still flawed in one respect: each operation selects a surgeon at random, but in reality a surgeon cannot be in two places at once. Let's implement that fact by turning surgeons into Agents.
</p>

<p>
Rewrite the <code>surgeon</code> function to create each surgeon as an Agent. Rewrite the <code>transplant!</code> function as an Agent action: the surgeon's state will be its first argument, and it must return that same state. Patients will still be Refs.
</p>

<p>
Then modify the <code>operate!</code> function to dispatch operations to surgeons with <code>send</code>.
</p>

<p>
Finally, re-run the simulation. This time, instead of creating futures for each operating room, just call <code>operate!</code> 10,000 times. Wait for all the surgeons to finish (call <code>await</code> on the Agents). Continue to use <code>future</code> for printing periodic audits. 
</p>

<p>
Can you describe what is happening here? How many operations can be taking place simultaneously?
</p>
</div>

<div id="outline-container-sec-2-5-9-1" class="outline-5">
<h5 id="sec-2-5-9-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-5-9-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">surgeon</span> [specialty]
  (<span class="org-variable-name">agent</span> {<span class="org-constant">:specialty</span> specialty}))

(<span class="org-keyword">defn</span> <span class="org-function-name">init-surgeons</span> []  <span class="org-comment">; the same, must reload/redefine</span>
  (<span class="org-variable-name">vec</span> (<span class="org-variable-name">take</span> 100 (<span class="org-variable-name">map</span> surgeon (<span class="org-variable-name">cycle</span> [<span class="org-constant">:arms</span> <span class="org-constant">:legs</span> <span class="org-constant">:heads</span>])))))

(<span class="org-keyword">defn</span> <span class="org-function-name">init!</span> []  <span class="org-comment">; the same, must reload/redefine</span>
  (<span class="org-variable-name">alter-var-root</span> #'all-patients (<span class="org-variable-name">constantly</span> (init-patients)))
  (<span class="org-variable-name">alter-var-root</span> #'all-surgeons (<span class="org-variable-name">constantly</span> (init-surgeons))))

(<span class="org-keyword">defn</span> <span class="org-function-name">transplant!</span> [surgn-state p1 p2]
  (<span class="org-builtin">let</span> [limb (<span class="org-constant">:specialty</span> surgn-state)]
    (<span class="org-builtin">dosync</span>
     (<span class="org-builtin">when</span> (<span class="org-variable-name">pos?</span> (@p1 limb))
       (<span class="org-variable-name">alter</span> p1 update-in [limb] dec)
       (<span class="org-variable-name">alter</span> p2 update-in [limb] inc))))
  surgn-state)  <span class="org-comment">; must return state</span>

(<span class="org-keyword">defn</span> <span class="org-function-name">operate!</span> []
  (<span class="org-builtin">let</span> [surgn (rand-nth all-surgeons)
        [p1 p2] (select-patients)]
    (<span class="org-variable-name">send</span> surgn transplant! p1 p2)))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-variable-name">println</span> <span class="org-string">"Introducing Agents:"</span>)
  (<span class="org-builtin">let</span> [audit (auditor)]
    (<span class="org-builtin">dotimes</span> [_ 10000] (operate!))
    (<span class="org-variable-name">apply</span> await all-surgeons)
    (<span class="org-variable-name">deref</span> audit)))
</pre>
</div>

<p>
The number of simultaneous operations depends on your definition of "simultaneous." The size of the Agent thread pool is bounded by the number of available CPU cores plus two (a common rule-of-thumb). So on a four-core system, there are up to six threads performing operations. But there are still only four cores to do the work, and we have that <code>future</code> running in the background on its own thread. So how many operations can happen at once? Theoretically, up to four, but we'll never really know. At this point we have given up control and must put our trust in Clojure, the Java Virtual Machine, the operating system, and our hardware, all of which have been optimized to make efficient use of computational resources.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Names and Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-6">
</div>

<div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1">What is a Namespace?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li>Conceptual Version
<ul class="org-ul">
<li>A way to disambiguate names
</li>
</ul>
</li>

<li>Concrete Version
<ul class="org-ul">
<li>Mappings from <i>symbols</i> to
<ul class="org-ul">
<li>Vars
</li>
<li>Java classes
</li>
<li>Aliases to other namespaces
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-2-6-1-1" class="outline-5">
<h5 id="sec-2-6-1-1">What is a Var?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-1-1">
<ul class="org-ul">
<li>An association between a <i>symbol</i> and a <i>value</i>
</li>
<li><code>def</code>
<ul class="org-ul">
<li>Creates a new Var in the current namespace
</li>
<li>Optionally creates <i>root binding</i> to a value
</li>
</ul>
</li>
<li><code>defn</code>
<ul class="org-ul">
<li>Shortcut for <code>def</code> + <code>fn</code>
</li>
<li>Creates a new Var whose value is a function
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-1-2" class="outline-5">
<h5 id="sec-2-6-1-2">What is a Symbol?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-1-2">
<ul class="org-ul">
<li>Just a label
<ul class="org-ul">
<li>A name <i>string</i>
</li>
<li>With an optional namespace <i>string</i>
</li>
</ul>
</li>
<li>Has no value
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">foo       <span class="org-comment">; Unqualified symbol</span>
bar/foo   <span class="org-comment">; Namespace-qualified symbol</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2">Creating Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-6-2">
</div><div id="outline-container-sec-2-6-2-1" class="outline-5">
<h5 id="sec-2-6-2-1"><code>ns</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-2-1">
<ul class="org-ul">
<li>At the top of every source file
</li>
<li>Creates a namespace
</li>
<li>Automatically refers all of <code>clojure.core</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> com.some-example.my-app)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-2-2" class="outline-5">
<h5 id="sec-2-6-2-2">Names into Files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-2-2">
<ul class="org-ul">
<li>Dots become directory separators
</li>
<li>Hyphens become underscores
</li>
<li>Add <code>.clj</code> on the end
</li>
<li>Find on the CLASSPATH
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">in file $CLASSPATH/com/some_example/my_app.clj</span>
(<span class="org-builtin">ns</span> com.some-example.my-app)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-2-3" class="outline-5">
<h5 id="sec-2-6-2-3">The JVM Classpath&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-2-3">
<ul class="org-ul">
<li>Where to find code to load
</li>
<li>List of directories and JAR files
</li>
<li>Specified when launching the JVM
<ul class="org-ul">
<li>Cannot be changed (normally)
</li>
</ul>
</li>
<li>Managed by tools such as Leiningen
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Show the classpath</span>
(<span class="org-preprocessor">System/getProperty</span> <span class="org-string">"java.class.path"</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-3" class="outline-4">
<h4 id="sec-2-6-3">Namespace Operations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-6-3">
<ul class="org-ul">
<li>Load <i>(require)</i>
</li>
<li>Copy <i>(refer)</i> symbol→Var mappings
</li>
<li>Make a shortcut <i>(alias)</i>
</li>
</ul>
</div>

<div id="outline-container-sec-2-6-3-1" class="outline-5">
<h5 id="sec-2-6-3-1"><code>ns :require</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-3-1">
<ul class="org-ul">
<li>Loads a namespace
</li>
<li>Optionally
<ul class="org-ul">
<li>Provides an alias
</li>
<li>Refers some symbols
</li>
</ul>
</li>
<li>Never loads the same code twice
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-3-2" class="outline-5">
<h5 id="sec-2-6-3-2"><code>ns :require</code> Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-3-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> com.some-example.my-app
  (<span class="org-constant">:require</span> clojure.string
            [clojure.set <span class="org-constant">:as</span> set]
            [clojure.java.io <span class="org-constant">:refer</span> (file reader)]))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-3-3" class="outline-5">
<h5 id="sec-2-6-3-3"><code>ns :require</code> Bare&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-3-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> ... (<span class="org-constant">:require</span> clojure.string ...))
</pre>
</div>

<ul class="org-ul">
<li>Element inside <code>(:require ...)</code> is a symbol
</li>
<li>Just load the code
</li>
<li>Vars available as fully-qualified symbols
<ul class="org-ul">
<li>e.g. <code>clojure.string/replace</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-3-4" class="outline-5">
<h5 id="sec-2-6-3-4"><code>ns :require :as</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-3-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> ... (<span class="org-constant">:require</span> [clojure.set <span class="org-constant">:as</span> set] ...))
</pre>
</div>

<ul class="org-ul">
<li>Element inside <code>(:require ...)</code> is a vector
<ul class="org-ul">
<li>Like <code>[<i style='font-family:serif'>name</i> :as <i style='font-family:serif'>alias</i>]</code>
</li>
</ul>
</li>
<li>Load code and create an alias
</li>
<li>Vars available under shorter alias
<ul class="org-ul">
<li>e.g. <code>set/union</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-3-5" class="outline-5">
<h5 id="sec-2-6-3-5"><code>ns :require :refer</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-3-5">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> ... (<span class="org-constant">:require</span> [clojure.java.io <span class="org-constant">:refer</span> (file reader)] ...))
</pre>
</div>

<ul class="org-ul">
<li>Element inside <code>(:require ...)</code> is a vector
<ul class="org-ul">
<li>Like <code>[<i style='font-family:serif'>name</i> :refer (<i style='font-family:serif'>symbols+</i>)]</code>
</li>
</ul>
</li>
<li>Load code and copy symbol→Var bindings
</li>
<li>Vars available without namespace qualification
<ul class="org-ul">
<li>e.g. <code>reader</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-3-6" class="outline-5">
<h5 id="sec-2-6-3-6"><code>ns :use :only</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-3-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> ... (<span class="org-constant">:use</span> [clojure.java.io <span class="org-constant">:only</span> (file reader)] ...))
</pre>
</div>

<ul class="org-ul">
<li>Older (pre-1.4) form of <code>:require :refer</code>
</li>
<li><code>(:use ...)</code> instead of <code>(:require ...)</code>
</li>
<li>Element inside <code>(:use ...)</code> is a vector
<ul class="org-ul">
<li>Like <code>[<i style='font-family:serif'>name</i> :only (<i style='font-family:serif'>symbols+</i>)]</code>
</li>
</ul>
</li>
<li>Vars available without namespace qualification
<ul class="org-ul">
<li>e.g. <code>reader</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-3-7" class="outline-5">
<h5 id="sec-2-6-3-7"><code>ns :import</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-3-7">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> com.some-example.my-app
  (<span class="org-constant">:import</span> <span class="org-preprocessor">java.io.File</span>
           (java.util <span class="org-preprocessor">Map</span> <span class="org-preprocessor">List</span> <span class="org-preprocessor">Map$Entry</span>)))
</pre>
</div>

<ul class="org-ul">
<li>Element inside <code>(:import ...)</code> is
<ul class="org-ul">
<li>A package-qualified class name
</li>
<li>Or a list like <code>(<i style='font-family:serif'>package</i> <i style='font-family:serif'>classes+</i>)</code>
</li>
</ul>
</li>
<li>Java "inner classes" are named <code>Outer$Inner</code>
</li>
<li>Every namespace automatically imports <code>java.lang</code>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-4" class="outline-4">
<h4 id="sec-2-6-4">Namespaces at the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-6-4">
</div><div id="outline-container-sec-2-6-4-1" class="outline-5">
<h5 id="sec-2-6-4-1">Where am I?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-4-1">
<ul class="org-ul">
<li><code>*ns*</code> is the current namespace
</li>
<li><code>in-ns</code> switches namespaces
<ul class="org-ul">
<li>Takes a <i>symbol</i> (quoted)
</li>
<li>Creates namespace if it doesn't exist
</li>
<li>Does <i>not</i> automatically refer <code>clojure.core</code> like <code>ns</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-4-2" class="outline-5">
<h5 id="sec-2-6-4-2"><code>in-ns</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-4-2">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-builtin">in-ns</span> 'never-before-seen)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #&lt;Namespace never-before-seen&gt;</span>

never-before-seen=&gt; (<span class="org-variable-name">println</span> <span class="org-string">"This won't work"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">CompilerException java.lang.RuntimeException:</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Unable to resolve symbol: println in this context</span>

never-before-seen=&gt; (clojure.core/<span class="org-variable-name">println</span> <span class="org-string">"This will"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">This will</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-4-3" class="outline-5">
<h5 id="sec-2-6-4-3"><code>require</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-4-3">
<ul class="org-ul">
<li><code>require</code> is also a function
</li>
<li>Same syntax as in <code>(ns ... (:require ...))</code>
<ul class="org-ul">
<li>But <code>require</code> is not a keyword
</li>
<li>Arguments must be <i>quoted</i> to prevent evaluation
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-variable-name">require</span> clojure.set)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; CompilerException java.lang.ClassNotFoundException: clojure.set</span>
user=&gt; (<span class="org-variable-name">require</span> '[clojure.set <span class="org-constant">:as</span> set])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
user=&gt; (set/<span class="org-type">union</span> #{1 3} #{2 4})
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #{1 4 2 3}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-4-4" class="outline-5">
<h5 id="sec-2-6-4-4"><code>require :reload</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-4-4">
<ul class="org-ul">
<li><code>require</code> never loads the same file twice
</li>
<li>To get new definitions, add <code>:reload</code> flag
</li>
<li><code>:reload-all</code> will recursively reload dependencies
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> 'com.example <span class="org-constant">:reload</span>)
(<span class="org-variable-name">require</span> 'com.example.myapp <span class="org-constant">:reload-all</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-4-5" class="outline-5">
<h5 id="sec-2-6-4-5"><code>import</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-4-5">
<ul class="org-ul">
<li><code>import</code> is also a macro
</li>
<li>Same syntax as in <code>(ns ... (:import ...))</code>
<ul class="org-ul">
<li>But <code>import</code> is not a keyword
</li>
<li>Arguments do <i>not</i> need to be quoted
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-builtin">import</span> (java.util <span class="org-preprocessor">Random</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; java.util.Random</span>
user=&gt; (<span class="org-preprocessor">.nextInt</span> (<span class="org-preprocessor">Random.</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; -1547790708</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-4-6" class="outline-5">
<h5 id="sec-2-6-4-6">Namespace Concepts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-4-6">
<p>Click on the image to view full-size in a new window (in browsers that support SVG).</p>
<a href="slide-assets/namespaces-total.svg" target="_blank">
  <img src="slide-assets/namespaces-total.svg" width="967" height="215" />
</a>
</div>
</div>
<div id="outline-container-sec-2-6-4-7" class="outline-5">
<h5 id="sec-2-6-4-7">File vs REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-4-7">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In a source file                  ;; At the REPL</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">------------------------------    ;; -------------------</span>
(<span class="org-builtin">ns</span> foo)                             (<span class="org-builtin">in-ns</span> 'foo)

(<span class="org-builtin">ns</span> foo (<span class="org-constant">:require</span> bar))              (<span class="org-variable-name">require</span> 'bar)
(<span class="org-builtin">ns</span> foo (<span class="org-constant">:require</span> [bar <span class="org-constant">:as</span> b]))      (<span class="org-variable-name">require</span> '[bar <span class="org-constant">:as</span> b])

(<span class="org-builtin">ns</span> foo (<span class="org-constant">:import</span> (java.io <span class="org-preprocessor">File</span>)))    (<span class="org-builtin">import</span> (java.io <span class="org-preprocessor">File</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-5" class="outline-4">
<h4 id="sec-2-6-5">Examining Symbols &amp; Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-6-5">
</div><div id="outline-container-sec-2-6-5-1" class="outline-5">
<h5 id="sec-2-6-5-1">Examining &amp; Creating Symbols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">name</span> 'com.example/foo)       <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "foo"</span>
(<span class="org-variable-name">namespace</span> 'com.example/foo)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "com.example"</span>
(<span class="org-variable-name">namespace</span> 'foo)              <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>

(<span class="org-variable-name">symbol</span> <span class="org-string">"foo"</span>)                <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; foo</span>
(<span class="org-variable-name">symbol</span> <span class="org-string">"com.example"</span> <span class="org-string">"foo"</span>)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; com.example/foo</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-5-2" class="outline-5">
<h5 id="sec-2-6-5-2">Finding Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-5-2">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Doesn't work:</span>
user=&gt; clojure.set
<span class="org-comment-delimiter">;; </span><span class="org-comment">CompilerException java.lang.ClassNotFoundException: clojure.set</span>

user=&gt; (<span class="org-variable-name">find-ns</span> 'clojure.set)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #&lt;Namespace clojure.set&gt;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-5-3" class="outline-5">
<h5 id="sec-2-6-5-3">Viewing Namespace Mappings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-5-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Function</th>
<th scope="col" class="left">Returns map of symbols to &#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">&nbsp; <code>ns-map</code></td>
<td class="left">all Vars and classes</td>
</tr>

<tr>
<td class="left">&nbsp; → <code>ns-interns</code></td>
<td class="left">all Vars created in this namespace</td>
</tr>

<tr>
<td class="left">&nbsp; → → <code>ns-publics</code></td>
<td class="left">all <b>public</b> Vars in this namespace</td>
</tr>

<tr>
<td class="left">&nbsp; → <code>ns-refers</code></td>
<td class="left"><b>referred</b> Vars from other namespaces</td>
</tr>

<tr>
<td class="left">&nbsp; → <code>ns-imports</code></td>
<td class="left">Java classes</td>
</tr>

<tr>
<td class="left">&nbsp; <code>ns-aliases</code></td>
<td class="left">aliased namespaces</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-2-6-5-4" class="outline-5">
<h5 id="sec-2-6-5-4">Viewing Namespace Mappings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-5-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">ns-map</span> 'user)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {Runtime java.lang.Runtime</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">keep    #'clojure.core/keep</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">...}</span>

(<span class="org-variable-name">ns-aliases</span> 'user)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {set #&lt;Namespace clojure.set&gt;}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-6-6" class="outline-4">
<h4 id="sec-2-6-6">Private Vars&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-2-6-6">
<ul class="org-ul">
<li>Add <code>^:private</code> metadata to def'd symbol
<ul class="org-ul">
<li><code>defn-</code> is shortcut for private fn
</li>
</ul>
</li>
<li>Prevents accidental refer
</li>
<li>Prevents accidental use by qualified symbol
</li>
<li>Not truly hidden, can expose by deref'ing Var
</li>
</ul>
</div>

<div id="outline-container-sec-2-6-6-1" class="outline-5">
<h5 id="sec-2-6-6-1">Private Vars Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-6-6-1">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-keyword">def</span> <span class="org-constant">^:private</span> <span class="org-function-name">secret</span> <span class="org-string">"trustno1"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/secret</span>

user=&gt; (<span class="org-builtin">in-ns</span> 'foo.bar)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>

foo.bar=&gt; user/secret
<span class="org-comment-delimiter">;; </span><span class="org-comment">CompilerException: user/secret is not public</span>

foo.bar=&gt; @#'user/secret   <span class="org-comment">; deref the Var</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "trustno1"</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">LAB: Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-7">
</div>

<div id="outline-container-sec-2-7-1" class="outline-4">
<h4 id="sec-2-7-1">Entering a namespace</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
At the REPL, use <code>in-ns</code> to enter a new namespace <code>alpha</code>.
</p>
</div>

<div id="outline-container-sec-2-7-1-1" class="outline-5">
<h5 id="sec-2-7-1-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-7-1-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">in-ns</span> 'alpha)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-7-2" class="outline-4">
<h4 id="sec-2-7-2">An empty namespace</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
In the <code>alpha</code> namespace, try to call a common function like <code>println</code>. Why doesn't it work?
</p>
</div>

<div id="outline-container-sec-2-7-2-1" class="outline-5">
<h5 id="sec-2-7-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-7-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">println</span> <span class="org-string">"Hello, World!"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">RuntimeException Unable to resolve</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">symbol: println in this context</span>
</pre>
</div>

<p>
The <code>println</code> function is defined in the <code>clojure.core</code> namespace, which is not automatically referred into new namespaces by <code>in-ns</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-7-3" class="outline-4">
<h4 id="sec-2-7-3">Getting to the core</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
In the <code>alpha</code> namespace, call the <code>println</code> function correctly.
</p>
</div>

<div id="outline-container-sec-2-7-3-1" class="outline-5">
<h5 id="sec-2-7-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-7-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(clojure.core/<span class="org-variable-name">println</span> <span class="org-string">"Hello, World!"</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-7-4" class="outline-4">
<h4 id="sec-2-7-4">A less empty namespace</h4>
<div class="outline-text-4" id="text-2-7-4">
<p>
Create a new namespace <code>beta</code> using <code>ns</code>. Try calling a common function like <code>println</code>. Why does it work now?
</p>
</div>

<div id="outline-container-sec-2-7-4-1" class="outline-5">
<h5 id="sec-2-7-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-7-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> beta)

(<span class="org-variable-name">println</span> <span class="org-string">"Hello, World!"</span>)
</pre>
</div>

<p>
<code>ns</code> automatically refers all symbols from <code>clojure.core</code> into the new namespace.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-7-5" class="outline-4">
<h4 id="sec-2-7-5">File it away</h4>
<div class="outline-text-4" id="text-2-7-5">
<p>
Create a new Clojure source file for the namespace <code>student.dialect</code>, with the appropriate <code>ns</code> declaration.
</p>

<p>
In this file, define a function <code>canadianize</code> that takes a string and appends ", eh?"
</p>
</div>

<div id="outline-container-sec-2-7-5-1" class="outline-5">
<h5 id="sec-2-7-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-7-5-1">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">in $CLASSPATH/student/dialect.clj</span>
(<span class="org-builtin">ns</span> student.dialect)

(<span class="org-keyword">defn</span> <span class="org-function-name">canadianize</span> [sentence]
  (<span class="org-variable-name">str</span> sentence <span class="org-string">", eh?"</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-7-6" class="outline-4">
<h4 id="sec-2-7-6">Loading from files</h4>
<div class="outline-text-4" id="text-2-7-6">
<p>
In the REPL, load your new namespace and call the <code>canadianize</code> function.
</p>
</div>

<div id="outline-container-sec-2-7-6-1" class="outline-5">
<h5 id="sec-2-7-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-7-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> 'student.dialect)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(student.dialect/canadianize <span class="org-string">"Nice weather today."</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "Nice weather today., eh?"
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-7-7" class="outline-4">
<h4 id="sec-2-7-7">Modifying sources</h4>
<div class="outline-text-4" id="text-2-7-7">
<p>
Modify your source file to make the <code>clojure.string</code> namespace available under the alias <code>str</code> in the <code>student.dialect</code> namespace.
</p>

<p>
Modify the <code>canadianize</code> function to strip a trailing period off its input.  Use <code>clojure.string/replace</code>. 
</p>
</div>

<div id="outline-container-sec-2-7-7-1" class="outline-5">
<h5 id="sec-2-7-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-7-7-1">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">in $CLASSPATH/student/dialect.clj</span>
(<span class="org-builtin">ns</span> student.dialect
  (<span class="org-constant">:require</span> [clojure.string <span class="org-constant">:as</span> str]))

(<span class="org-keyword">defn</span> <span class="org-function-name">canadianize</span>
  [sentence]
  (str/<span class="org-type">replace</span> sentence #<span class="org-string">"\.$"</span> <span class="org-string">", eh?"</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-7-8" class="outline-4">
<h4 id="sec-2-7-8">Reloading</h4>
<div class="outline-text-4" id="text-2-7-8">
<p>
In the REPL, reload your source file and call the improved <code>canadianize</code> function.
</p>
</div>

<div id="outline-container-sec-2-7-8-1" class="outline-5">
<h5 id="sec-2-7-8-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-7-8-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> 'student.dialect <span class="org-constant">:reload</span>)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(student.dialect/canadianize <span class="org-string">"Nice weather today."</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "Nice weather today, eh?"
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-8">
</div>

<div id="outline-container-sec-2-8-1" class="outline-4">
<h4 id="sec-2-8-1">Overview</h4>
<div class="outline-text-4" id="text-2-8-1">
</div><div id="outline-container-sec-2-8-1-1" class="outline-5">
<h5 id="sec-2-8-1-1">Clojure Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-1-1">

<div class="figure">
<p><img src="slide-assets/macro-evaluation.svg" alt="macro-evaluation.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-1-2" class="outline-5">
<h5 id="sec-2-8-1-2">Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-1-2">
<ul class="org-ul">
<li>Pure functions
</li>
<li>Code as input, code as output
</li>
<li>Called during <b>compilation</b>
</li>
<li>Do not exist at runtime
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8-1-3" class="outline-5">
<h5 id="sec-2-8-1-3">Normal Compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-1-3">
<div class="org-src-container">

<pre class="src src-clojure">(foo bar baz)
</pre>
</div>

<ul class="org-ul">
<li>If <code>foo</code> is not a macro, emit bytecode to:
<ul class="org-ul">
<li>Evaluate <code>bar</code> and <code>baz</code>
</li>
<li>Cast <code>foo</code> to IFn
</li>
<li>Invoke <code>foo</code> on values of <code>bar baz</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8-1-4" class="outline-5">
<h5 id="sec-2-8-1-4">Macro Compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-1-4">
<div class="org-src-container">

<pre class="src src-clojure">(foo bar baz)
</pre>
</div>

<ul class="org-ul">
<li>If <code>foo</code> is a macro:
<ul class="org-ul">
<li>Do not evaluate <code>bar baz</code>
</li>
<li>Call <code>foo</code> with literal <code>bar baz</code> as arguments
</li>
<li>Replace <code>(foo bar baz)</code> with returned code
</li>
<li>Continue compiling
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2" class="outline-4">
<h4 id="sec-2-8-2">Writing Macros</h4>
<div class="outline-text-4" id="text-2-8-2">
</div><div id="outline-container-sec-2-8-2-1" class="outline-5">
<h5 id="sec-2-8-2-1">How to Write a Macro&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-1">
<ul class="org-ul">
<li>Think of what you want to type
</li>
<li>Think of what you want it to become
</li>
<li>Write macro as a function that transforms the former into the latter
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8-2-2" class="outline-5">
<h5 id="sec-2-8-2-2">Example: when&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-2">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">We want to write</span>
(<span class="org-builtin">when</span> condition
  (foo)
  (bar))

<span class="org-comment-delimiter">;; </span><span class="org-comment">And have it become</span>
(<span class="org-builtin">if</span> condition
  (<span class="org-builtin">do</span> (foo)
      (bar)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-3" class="outline-5">
<h5 id="sec-2-8-2-3">Example: when&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-3">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">And have it become</span>
(<span class="org-builtin">if</span> condition
  (<span class="org-builtin">do</span> (foo)
      (bar)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Write a macro:</span>
(<span class="org-keyword">defmacro</span> <span class="org-function-name">when</span> [test &amp; body]
  (<span class="org-variable-name">list</span> 'if test (<span class="org-variable-name">cons</span> 'do body)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-4" class="outline-5">
<h5 id="sec-2-8-2-4">Macroexpansion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-4">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Write a macro:</span>
(<span class="org-keyword">defmacro</span> <span class="org-function-name">when</span> [test &amp; body]
  (<span class="org-variable-name">list</span> 'if test (<span class="org-variable-name">cons</span> 'do body)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Test with macroexpand:</span>
(<span class="org-variable-name">macroexpand-1</span> '(<span class="org-builtin">when</span> condition (foo) (bar)))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (if condition (do (foo) (bar)))</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-5" class="outline-5">
<h5 id="sec-2-8-2-5">Syntax-Quote (<code>`</code>)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-5">
<ul class="org-ul">
<li>A template that looks like the expansion
</li>
<li>Easier than constructing code manually
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">when</span> [test &amp; body]
  (<span class="org-variable-name">list</span> 'if test (<span class="org-variable-name">cons</span> 'do body)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">same thing with syntax-quote</span>
(<span class="org-keyword">defmacro</span> <span class="org-function-name">when2</span> [test &amp; body]
  `(<span class="org-builtin">if</span> ~test (<span class="org-builtin">do</span> ~@body)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-6" class="outline-5">
<h5 id="sec-2-8-2-6">Syntax-Quote on Symbols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-6">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Qualified symbols left as-is</span>
`clojure.core/list  <span class="org-comment">;=&gt; clojure.core/list</span>
`<span class="org-preprocessor">java.util.List</span>     <span class="org-comment">;=&gt; java.util.List</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Special forms left as-is</span>
`do    <span class="org-comment">;=&gt; do</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Unqualified symbols resolved in namespace</span>
`foo   <span class="org-comment">;=&gt; user/foo</span>
`<span class="org-preprocessor">List</span>  <span class="org-comment">;=&gt; user/List</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-7" class="outline-5">
<h5 id="sec-2-8-2-7">Syntax-Quote on Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-7">
<div class="org-src-container">

<pre class="src src-clojure">`(1 2 3)  <span class="org-comment">;=&gt; (1 2 3)</span>

`(a b)    <span class="org-comment">;=&gt; (user/a user/b)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-8" class="outline-5">
<h5 id="sec-2-8-2-8">Unquote (<code>~</code>)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-8">
<ul class="org-ul">
<li>Only valid inside syntax-quote
</li>
<li>Turns off syntax-quote for next form
</li>
<li>Unquote-splicing (<code>~@</code>)
<ul class="org-ul">
<li>"Splices" in a sequence of values
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8-2-9" class="outline-5">
<h5 id="sec-2-8-2-9">Unquote Examples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-9">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In the 'user' namespace:</span>

(<span class="org-keyword">def</span> <span class="org-function-name">x</span> 42)       <span class="org-comment">;=&gt; #'user/x</span>

`(x ~x)          <span class="org-comment">;=&gt; (user/x 42)</span>


(<span class="org-keyword">def</span> <span class="org-function-name">y</span> [1 2 3])  <span class="org-comment">;=&gt; #'user/y</span>

`(y ~@y ~y)      <span class="org-comment">;=&gt; (user/y 1 2 3 [1 2 3])</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-10" class="outline-5">
<h5 id="sec-2-8-2-10">Auto-Gensym&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-10">
<ul class="org-ul">
<li>Within syntax-quote
</li>
<li>Symbols ending with <code>#</code> get unique, generated names
</li>
<li>All uses within one syntax-quote are the same
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8-2-11" class="outline-5">
<h5 id="sec-2-8-2-11">Auto-Gensym Examples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-11">
<ul class="org-ul">
<li>Each syntax-quote produces new unique gemsyms
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">`(x x# x#)  <span class="org-comment">;=&gt; (user/x x__10 x__10)</span>

`(x x# x#)  <span class="org-comment">;=&gt; (user/x x__13 x__13)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-12" class="outline-5">
<h5 id="sec-2-8-2-12">Example: <code>or</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-12">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">We want to write:</span>
(<span class="org-builtin">or</span> a b c)

<span class="org-comment-delimiter">;; </span><span class="org-comment">And have it become:</span>
(<span class="org-builtin">let</span> [or__42 a]
  (<span class="org-builtin">if</span> or__42
    or__42
    (<span class="org-builtin">or</span> b c))) <span class="org-comment">; note "recursion"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-2-13" class="outline-5">
<h5 id="sec-2-8-2-13">Example: <code>or</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-2-13">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Write a macro:</span>
(<span class="org-keyword">defmacro</span> <span class="org-function-name">or</span>
  ([] nil)
  ([x] x)
  ([x &amp; next]
    `(<span class="org-builtin">let</span> [or# ~x]
       (<span class="org-builtin">if</span> or# or# (<span class="org-builtin">or</span> ~@next)))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-3" class="outline-4">
<h4 id="sec-2-8-3">Encapsulating Patterns</h4>
<div class="outline-text-4" id="text-2-8-3">
</div><div id="outline-container-sec-2-8-3-1" class="outline-5">
<h5 id="sec-2-8-3-1">Encapsulating Patterns&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-3-1">
<ul class="org-ul">
<li>Macros often used to implement patterns in code
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">with-open</span> [bindings &amp; body]
  `(<span class="org-builtin">let</span> ~bindings
     (<span class="org-builtin">try</span> ~@body
          (<span class="org-builtin">finally</span>
           (<span class="org-preprocessor">.close</span> ~(<span class="org-variable-name">first</span> bindings))))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-4" class="outline-4">
<h4 id="sec-2-8-4">Common Macros</h4>
<div class="outline-text-4" id="text-2-8-4">
</div><div id="outline-container-sec-2-8-4-1" class="outline-5">
<h5 id="sec-2-8-4-1">Common Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-4-1">
<ul class="org-ul">
<li>Branching
<ul class="org-ul">
<li><code>and or when when-not when-let</code>
</li>
<li><code>if-not if-let cond condp</code>
</li>
</ul>
</li>
<li>Looping
<ul class="org-ul">
<li><code>for doseq dotimes while</code>
</li>
</ul>
</li>
<li>Definitions
<ul class="org-ul">
<li><code>ns declare defn defmacro</code>
</li>
</ul>
</li>
<li>Some other examples&#x2026;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8-4-2" class="outline-5">
<h5 id="sec-2-8-4-2">Threading Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-4-2">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Thread-first:</span>
(<span class="org-builtin">-&gt;</span> x
    (foo 1 2)
    (bar 3 4))   <span class="org-comment">;=&gt; (bar (foo x 1 2) 3 4)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Thread-last:</span>
(<span class="org-builtin">-&gt;&gt;</span> x
     (foo 1 2)
     (bar 3 4))  <span class="org-comment">;=&gt; (bar 3 4 (foo 1 2 x))</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-4-3" class="outline-5">
<h5 id="sec-2-8-4-3"><code>doto</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-4-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doto</span> (<span class="org-preprocessor">ClassName.</span>)
  (<span class="org-preprocessor">.setFoo</span> 1)
  (<span class="org-preprocessor">.setBar</span> 2))

<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt;</span>
(<span class="org-builtin">let</span> [x# (<span class="org-preprocessor">ClassName.</span>)]
  (<span class="org-preprocessor">.setFoo</span> x# 1)
  (<span class="org-preprocessor">.setBar</span> x# 2)
  x#)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-8-5" class="outline-4">
<h4 id="sec-2-8-5">Motivation</h4>
<div class="outline-text-4" id="text-2-8-5">
</div><div id="outline-container-sec-2-8-5-1" class="outline-5">
<h5 id="sec-2-8-5-1">When to Use Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-2-8-5-1">
<ul class="org-ul">
<li>Only for things functions can't do
<ul class="org-ul">
<li>Transform / generate / rearrange code
</li>
<li>Prevent evaluation of some things
<ul class="org-ul">
<li>e.g. <code>and</code>, <code>or</code> can't be functions
</li>
</ul>
</li>
</ul>
</li>
<li>Must be pure functions, code to code
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">LAB: Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-2-9">
</div>

<div id="outline-container-sec-2-9-1" class="outline-4">
<h4 id="sec-2-9-1">Introduction</h4>
<div class="outline-text-4" id="text-2-9-1">
<p>
Macros are often useful for metaprogramming tasks like testing and debugging. In this lab we will develop the <code>transcript</code> macro, which will print a series of expressions and their return values as if we had typed them at the REPL.
</p>
</div>
</div>
<div id="outline-container-sec-2-9-2" class="outline-4">
<h4 id="sec-2-9-2">The do-nothing macro</h4>
<div class="outline-text-4" id="text-2-9-2">
<p>
Define a macro <code>just-do-it</code> which takes a body of expressions and expands to code which evaluates the expressions in order.
</p>
</div>

<div id="outline-container-sec-2-9-2-1" class="outline-5">
<h5 id="sec-2-9-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-9-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">just-do-it</span> [&amp; body]
  `(<span class="org-builtin">do</span> ~@body))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-9-3" class="outline-4">
<h4 id="sec-2-9-3">Do one thing at a time</h4>
<div class="outline-text-4" id="text-2-9-3">
<p>
Define a macro <code>execute</code> which takes <b>one</b> expression and expands to code which first prints the expression, then evaluates it and prints the result.
</p>

<p>
Hint: to print the expression itself, you will need to quote it.
</p>
</div>

<div id="outline-container-sec-2-9-3-1" class="outline-5">
<h5 id="sec-2-9-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-9-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">execute</span> [expr]
  `(<span class="org-builtin">do</span> (<span class="org-variable-name">println</span> (quote ~expr))  <span class="org-comment">; could be written '~expr</span>
       (<span class="org-variable-name">println</span> ~expr)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-9-4" class="outline-4">
<h4 id="sec-2-9-4">Make it pretty</h4>
<div class="outline-text-4" id="text-2-9-4">
<p>
Modify the <code>execute</code> macro to use <code>clojure.pprint/pprint</code> to pretty-print both the expression and the result.
</p>
</div>

<div id="outline-container-sec-2-9-4-1" class="outline-5">
<h5 id="sec-2-9-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-9-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.pprint <span class="org-constant">:refer</span> (pprint)])
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">execute</span> [expr]
  `(<span class="org-builtin">do</span> (pprint '~expr)
       (pprint ~expr)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-9-5" class="outline-4">
<h4 id="sec-2-9-5">Make it safe</h4>
<div class="outline-text-4" id="text-2-9-5">
<p>
Modify the <code>execute</code> macro to catch and print any exceptions thrown by the expression. Use <code>clojure.repl/pst</code> (print stack trace) to print exceptions.
</p>

<p>
Hint: Catch <code>java.lang.Throwable</code>, not <code>java.lang.Exception</code>. You will need to use a gensym name (like <code>foo#</code>) for the exception object in the <code>catch</code> clause.
</p>
</div>

<div id="outline-container-sec-2-9-5-1" class="outline-5">
<h5 id="sec-2-9-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-9-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">use</span> '[clojure.repl <span class="org-constant">:only</span> (pst)])
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">execute</span> [expr]
  `(<span class="org-builtin">do</span> (pprint '~expr)
       (<span class="org-builtin">try</span> (pprint ~expr)
            (<span class="org-builtin">catch</span> <span class="org-preprocessor">Throwable</span> t#
              (pst t#)))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-9-6" class="outline-4">
<h4 id="sec-2-9-6">Do more than one thing</h4>
<div class="outline-text-4" id="text-2-9-6">
<p>
Define a macro <code>transcript</code> that takes a body of multiple expressions and causes each one to be wrapped in <code>execute</code>.
</p>
</div>

<div id="outline-container-sec-2-9-6-1" class="outline-5">
<h5 id="sec-2-9-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-9-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">transcript</span> [&amp; body]
  (<span class="org-builtin">when</span> (<span class="org-variable-name">seq</span> body)
    `(<span class="org-builtin">do</span> (execute ~(<span class="org-variable-name">first</span> body))
         (transcript ~@(<span class="org-variable-name">rest</span> body)))))
</pre>
</div>

<p>
There are several ways to implement this macro. This solution shows a classic "recursive" macro technique, meaning that the expansion of <code>transcript</code> contains another "call" to <code>transcript</code>. It is not the same as a recursive function, because <code>transcript</code> does not actually call itself. Instead, it returns code which will evaluate the first expression and then expand <code>transcript</code> again on the remaining expressions. When there are no more expressions left (when <code>(seq body)</code> returns <code>nil</code>) the "recursion" terminates.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-9-7" class="outline-4">
<h4 id="sec-2-9-7">Bonus: Reuse intermediate results</h4>
<div class="outline-text-4" id="text-2-9-7">
<p>
The Clojure REPL sets the Var <code>*1</code> to the result of the last expression. Redefine <code>transcript</code> to do something similar: make the result of the previous expression available as a local binding to the symbol <code>that</code>. 
</p>

<p>
This is known as an <a href="http://en.wikipedia.org/wiki/Anaphoric_macro">anaphoric macro</a> because <code>that</code> is never explicitly defined and appears "magically" within the body of the macro. Anaphoric macros are generally considered bad style in Clojure code, although Clojure itself has one (the <code>proxy</code> macro binds <code>this</code> within method bodies).
</p>

<p>
Hint: You will not be able to reuse the <code>execute</code> macro because it does not return a value. Instead, the <code>transcript</code> macro will do all the work. To capture the symbol <code>that</code> inside a syntax-quote, you will need to unquote-quote it, like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">`(<span class="org-builtin">let</span> [~'that ...]
   ...)
</pre>
</div>
</div>

<div id="outline-container-sec-2-9-7-1" class="outline-5">
<h5 id="sec-2-9-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-2-9-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">transcript</span> [&amp; body]
  (<span class="org-builtin">when</span> (<span class="org-variable-name">seq</span> body)
    `(<span class="org-builtin">do</span> (pprint '~(<span class="org-variable-name">first</span> body))
         (<span class="org-builtin">try</span> (<span class="org-builtin">let</span> [~'that ~(<span class="org-variable-name">first</span> body)]
                (pprint ~'that)
                (transcript ~@(<span class="org-variable-name">rest</span> body)))
              (<span class="org-builtin">catch</span> <span class="org-preprocessor">Throwable</span> t#
                (pst t#))))))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Optional Topics</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Testing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-3-1">
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">clojure.test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In project at test/com/example/my_app_tests.clj</span>
(<span class="org-builtin">ns</span> com.example.my-app-tests
  (<span class="org-constant">:require</span> [clojure.test <span class="org-constant">:refer</span> (<span class="org-keyword">deftest</span> <span class="org-function-name">is</span>)]))

(<span class="org-keyword">deftest</span> <span class="org-function-name">t-addition</span>         <span class="org-comment">; define a test</span>
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> 7 (<span class="org-variable-name">+</span> 3 4)))        <span class="org-comment">; make assertions</span>
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> 5 (<span class="org-variable-name">+</span> 2 2))))
</pre>
</div>

<ul class="org-ul">
<li>Included with Clojure
</li>
<li>Similar to xUnit frameworks in other languages
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">Assertions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-type">is</span> expression message?)

<span class="org-comment-delimiter">;; </span><span class="org-comment">use optional message to clarify</span>
(<span class="org-type">is</span> (<span class="org-variable-name">not</span> (face-up? (<span class="org-variable-name">get</span> hand 1)))
    (<span class="org-variable-name">str</span> <span class="org-string">"Expected 2nd card to be face down because it's Tuesday."</span>))

<span class="org-comment-delimiter">;; </span><span class="org-comment">optional message not necessary most of the time</span>
(<span class="org-type">is</span> (<span class="org-variable-name">pos?</span> x))
<span class="org-comment-delimiter">;; </span><span class="org-comment">expected: (pos? x)</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">actual: (not (pos? -2))</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Checking exception cases</span>
(<span class="org-type">is</span> (thrown? <span class="org-preprocessor">ClassCastException</span> (<span class="org-variable-name">+</span> 1 false)))
(<span class="org-type">is</span> (thrown-with-msg? <span class="org-preprocessor">ClassCastException</span>
                      #<span class="org-string">"cannot be cast"</span>
                      (<span class="org-variable-name">+</span> 1 false)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Always fail / pass</span>
(<span class="org-type">is</span> nil)
(<span class="org-type">is</span> true)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3">Data-driven tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-type">are</span> [expected a b] (<span class="org-variable-name">=</span> expected (<span class="org-variable-name">+</span> a b))
      3        1 2
      0       -1 1)
</pre>
</div>

<ul class="org-ul">
<li>Each partition of inputs is a separate case 
</li>
<li>Drawbacks
<ul class="org-ul">
<li>The <code>are</code> macro can't specify per-case failure strings
</li>
<li>Error reporting of line numbers will always be the <code>are</code> expression
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4">lein test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-4">
<pre class="example">
$ lein test

lein test com.example.my-app-tests

FAIL in (t-addition) (my_app_tests.clj:6)
expected: (= 5 (+ 2 2))
  actual: (not (= 5 4))

Ran 1 tests containing 2 assertions.
1 failures, 0 errors.
Tests failed.
</pre>
</div>
</div>
<div id="outline-container-sec-3-1-5" class="outline-4">
<h4 id="sec-3-1-5">Example- vs property-based tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-5">
<ul class="org-ul">
<li>Example-based tests
<ul class="org-ul">
<li>Persist REPL-based tests
</li>
<li>Give representative examples of use
</li>
<li>Check specific boundary cases 
</li>
</ul>
</li>
<li>Property-based tests
<ul class="org-ul">
<li>Thorough coverage
</li>
<li>Clarifies constraints in your code
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-6" class="outline-4">
<h4 id="sec-3-1-6">test.check&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-6">
<ul class="org-ul">
<li>Based on Haskell QuickCheck library
</li>
<li>Define generators to create test examples 
</li>
<li>Specify properties that must hold for each example
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In project.clj</span>
(defproject testing <span class="org-string">"0.1.0-SNAPSHOT"</span>
  <span class="org-constant">:dependencies</span> [[org.clojure/clojure <span class="org-string">"1.8.0"</span>]
                 [org.clojure/test.check <span class="org-string">"0.9.0"</span>]])

<span class="org-comment-delimiter">;; </span><span class="org-comment">In tests</span>
(<span class="org-variable-name">require</span> '[clojure.test.check <span class="org-constant">:as</span> tc])
(<span class="org-variable-name">require</span> '[clojure.test.check.generators <span class="org-constant">:as</span> gen])
(<span class="org-variable-name">require</span> '[clojure.test.check.properties <span class="org-constant">:as</span> prop])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-7" class="outline-4">
<h4 id="sec-3-1-7">Basic generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-7">
<ul class="org-ul">
<li>Generators used to generate random instances
</li>
<li>Basic generators
<ul class="org-ul">
<li><code>gen/boolean</code>, <code>gen/byte</code>, <code>gen/ratio</code>
</li>
<li><code>gen/bytes</code> - random byte-arrays
</li>
<li><code>gen/char</code>, <code>gen/char-alpha-numeric</code>, <code>gen/char-ascii</code>
</li>
<li><code>gen/int</code>, <code>gen/nat</code>, <code>gen/pos-int</code>, etc - integers
</li>
<li><code>gen/choose</code> - numbers in a range with min and max
</li>
<li><code>gen/keyword</code> - Clojure keywords
</li>
<li><code>gen/string</code>, <code>gen/string-alpha-numeric</code>, <code>gen/string-ascii</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-8" class="outline-4">
<h4 id="sec-3-1-8">Sampling generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-8">
<p>
Use <code>gen/sample</code> to get some samples from a generator:
</p>

<pre class="example">
(gen/sample gen/int)
;; =&gt; (0 -1 0 3 -3 -1 5 -5 -6 -7)

(gen/sample gen/string-alpha-numeric)
;; =&gt; ("" "o" "ca" "1" "7l0d" "0xY4Q" "4" "Pu5k9Uf" "4A022" "g")
</pre>
</div>
</div>
<div id="outline-container-sec-3-1-9" class="outline-4">
<h4 id="sec-3-1-9">Other generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-9">
<ul class="org-ul">
<li>Create a generator collection with an element generator
<ul class="org-ul">
<li><code>gen/vector</code>, <code>gen/list</code>, <code>gen/hash-map</code> 
</li>
</ul>
</li>
<li>Create tuples
<ul class="org-ul">
<li><code>gen/tuple</code> 
</li>
</ul>
</li>
<li>Combine generators
<ul class="org-ul">
<li><code>gen/one-of</code>, <code>gen/frequency</code>
</li>
</ul>
</li>
<li>Filter generated values to those matching a predicate
<ul class="org-ul">
<li><code>gen/such-that</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-10" class="outline-4">
<h4 id="sec-3-1-10">Combining generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-10">
<p>
Create random maps:
</p>

<pre class="example">
(gen/sample
  (gen/hash-map :name gen/string-alpha-numeric
                :age gen/nat))
;; =&gt; ({:age 0, :name ""} {:age 1, :name ""} {:age 0, :name "TF"}
;;     {:age 1, :name "8"} {:age 2, :name "2"} {:age 1, :name "rT"})
</pre>
</div>
</div>
<div id="outline-container-sec-3-1-11" class="outline-4">
<h4 id="sec-3-1-11">Specifying properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-11">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">prop-no-42</span>
  (prop/for-all [v (gen/vector gen/int)]
    (<span class="org-variable-name">not</span> (<span class="org-variable-name">some</span> #{42} v))))

(tc/quick-check 100 prop-no-42)
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; {:result false,</span>
       <span class="org-constant">:failing-size</span> 45,
       <span class="org-constant">:num-tests</span> 46,
       <span class="org-constant">:fail</span> [[10 1 28 40 11 -33 42 -42 39 -13 13 -44 -36 11 27 -42 4 21 -39]],
       <span class="org-constant">:shrunk</span> {<span class="org-constant">:total-nodes-visited</span> 38,
                <span class="org-constant">:depth</span> 18,
                <span class="org-constant">:result</span> false,
                <span class="org-constant">:smallest</span> [[42]]}}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-12" class="outline-4">
<h4 id="sec-3-1-12">Specifying properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-12">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">addition-is-associative</span>
  (prop/for-all [a gen/int
                 b gen/int
                 c gen/int]
    (<span class="org-variable-name">=</span> (<span class="org-variable-name">+</span> (<span class="org-variable-name">+</span> a b) c) (<span class="org-variable-name">+</span> a (<span class="org-variable-name">+</span> b c)))))

(tc/quick-check 1000 addition-is-associative)
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; {:result true, :num-tests 1000, :seed 1400277173531}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-13" class="outline-4">
<h4 id="sec-3-1-13">Integrating with clojure.test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-1-13">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.test.check.clojure-test <span class="org-constant">:refer</span> (defspec)])

(defspec addition-is-associative 1000
  (prop/for-all [a gen/int
                 b gen/int
                 c gen/int]
    (<span class="org-variable-name">=</span> (<span class="org-variable-name">+</span> (<span class="org-variable-name">+</span> a b) c) (<span class="org-variable-name">+</span> a (<span class="org-variable-name">+</span> b c)))))
</pre>
</div>

<ul class="org-ul">
<li>Then use <code>lein test</code> or other runners as usual
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">LAB: Testing</h3>
<div class="outline-text-3" id="text-3-2">
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Introduction</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
In this lab we'll be practicing writing tests against the <code>range</code>
function.
</p>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Testing range</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Write a test that verifies the outputs for these example inputs to
range with the single argument "end". The default start value is 0
and step value is 1. Use <code>is</code> to verify each assertion.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">End</th>
<th scope="col" class="left">Expected output</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">0</td>
<td class="left">'()</td>
</tr>

<tr>
<td class="right">1</td>
<td class="left">'(0)</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">'(0 1)</td>
</tr>

<tr>
<td class="right">-1</td>
<td class="left">'()</td>
</tr>
</tbody>
</table>

<p>
Before defining your test, you will need to require the clojure.test
namespace:  <code>(require '[clojure.test :refer :all])</code>
</p>

<p>
You can run your test by just running it as a no-argument function.
</p>
</div>

<div id="outline-container-sec-3-2-2-1" class="outline-5">
<h5 id="sec-3-2-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-2-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.test <span class="org-constant">:refer</span> <span class="org-constant">:all</span>])

(<span class="org-keyword">deftest</span> <span class="org-function-name">test-range</span>
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> '() (<span class="org-variable-name">range</span> 0)))
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> '(0) (<span class="org-variable-name">range</span> 1)))
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> '(0 1) (<span class="org-variable-name">range</span> 2)))
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> '() (<span class="org-variable-name">range</span> -1))))

(test-range)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>

<p>
If you modify your test so it fails, what do you see?
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">Driving with data</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Rewrite the previous test to use <code>are</code> instead of is and provide many
examples at once.
</p>
</div>

<div id="outline-container-sec-3-2-3-1" class="outline-5">
<h5 id="sec-3-2-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-2-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">deftest</span> <span class="org-function-name">test-range</span>
  (<span class="org-type">are</span> [end expected] (<span class="org-variable-name">=</span> expected (<span class="org-variable-name">range</span> end))
    0 '()
    1 '(0)
    2 '(0 1)
    -1 '()))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4">Checking exceptions</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
Calling range with something other than a number will result in an error.
Verify that <code>(range "abc")</code> throws a ClassCastException.
</p>
</div>

<div id="outline-container-sec-3-2-4-1" class="outline-5">
<h5 id="sec-3-2-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-2-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">deftest</span> <span class="org-function-name">test-range-err</span>
  (<span class="org-type">is</span> (thrown? <span class="org-preprocessor">ClassCastException</span> (<span class="org-variable-name">range</span> <span class="org-string">"abc"</span>))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-5" class="outline-4">
<h4 id="sec-3-2-5">Checking exception messages</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
Rewrite the test to verify that the class name of the input
(java.lang.String) is included in the error message.
</p>
</div>

<div id="outline-container-sec-3-2-5-1" class="outline-5">
<h5 id="sec-3-2-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-2-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">deftest</span> <span class="org-function-name">test-range-err-msg</span>
  (<span class="org-type">is</span> (thrown-with-msg? <span class="org-preprocessor">ClassCastException</span> #<span class="org-string">"java.lang.String"</span> 
        (<span class="org-variable-name">range</span> <span class="org-string">"abc"</span>))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-6" class="outline-4">
<h4 id="sec-3-2-6">Specifying properties</h4>
<div class="outline-text-4" id="text-3-2-6">
<p>
We will next create a test.check test for <code>range</code>. 
</p>

<p>
Start with some requires to load the right namespaces:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.test.check <span class="org-constant">:as</span> tc])
(<span class="org-variable-name">require</span> '[clojure.test.check.generators <span class="org-constant">:as</span> gen])
(<span class="org-variable-name">require</span> '[clojure.test.check.properties <span class="org-constant">:as</span> prop])
</pre>
</div>

<p>
What property can we assert about <code>count</code> when used with the
single-argument arity of range?
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span> 5)
<span class="org-comment-delimiter">;; </span><span class="org-comment">(0 1 2 3 4)</span>
(<span class="org-variable-name">count</span> (<span class="org-variable-name">range</span> 5))
<span class="org-comment-delimiter">;; </span><span class="org-comment">5</span>
</pre>
</div>

<p>
Write a generative property that creates ranges of random positive
size and checks their count is correct. Run the test for 100
iterations.
</p>

<p>
See the test.check.generators api doc for generator functions:
<a href="https://clojure.github.io/test.check/clojure.test.check.generators.html">https://clojure.github.io/test.check/clojure.test.check.generators.html</a>
</p>
</div>

<div id="outline-container-sec-3-2-6-1" class="outline-5">
<h5 id="sec-3-2-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-2-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">range-count-eq-n</span> 
  (prop/for-all [n gen/pos-int]
    (<span class="org-variable-name">=</span> n (<span class="org-variable-name">count</span> (<span class="org-variable-name">range</span> n)))))

(tc/quick-check 100 range-count-eq-n)
</pre>
</div>

<p>
Note the use of <code>gen/pos-int</code> to constrain the range input values to
positive integers. What happens if you use gen/int instead? Why?
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Life on the JVM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-3-3">
</div>

<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">JVM Overview&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>Clojure is tightly integrated with the JVM
</li>
<li>Can manipulate Java primitives, arrays, and generate classes
<ul class="org-ul">
<li>Allows Clojure to both consume and implement Java APIs
</li>
</ul>
</li>
<li>As fast as Java if written correctly
</li>
<li>Clojure can be incrementally added to a Java project, or vice versa
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">Passing Data to/from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-3-2">
</div><div id="outline-container-sec-3-3-2-1" class="outline-5">
<h5 id="sec-3-3-2-1">Arrays&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-2-1">
<ul class="org-ul">
<li>Used in Clojure for interop, performance
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">nums</span> (<span class="org-variable-name">int-array</span> 10))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/nums</span>

(<span class="org-variable-name">aset</span> nums 4 1000)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1000</span>

(<span class="org-variable-name">aget</span> nums 4)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1000</span>

(<span class="org-variable-name">seq</span> nums)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 0 0 0 1000 0 0 0 0 0)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2-2" class="outline-5">
<h5 id="sec-3-3-2-2">Arrays from Seqs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-2-2">
<ul class="org-ul">
<li>Prefer Clojure collections
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">nums</span> (<span class="org-variable-name">range</span> 3))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/nums</span>

(<span class="org-variable-name">class</span> (<span class="org-variable-name">to-array</span> nums))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; [Ljava.lang.Object;   ; Java array of Object</span>

(<span class="org-variable-name">class</span> (<span class="org-variable-name">into-array</span> nums))  <span class="org-comment">; infer type from first</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; [Ljava.lang.Long;</span>

(<span class="org-variable-name">class</span> (<span class="org-variable-name">into-array</span> <span class="org-preprocessor">Comparable</span> nums))  <span class="org-comment">; specify type</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; [Ljava.lang.Comparable;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2-3" class="outline-5">
<h5 id="sec-3-3-2-3">Varargs in Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-2-3">
<div class="org-src-container">

<pre class="src src-fundamental">// Java
public class String {
  static String format(String format, Object... args) { //...
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Clojure</span>
(<span class="org-preprocessor">String/format</span> <span class="org-string">"Qty: %d   Total: $%.2f"</span> (object-array [5 23.5]))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Qty: 5   Total: $23.50"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2-4" class="outline-5">
<h5 id="sec-3-3-2-4">Clojure Types are Java Types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-2-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Clojure Type</th>
<th scope="col" class="left">Java Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Long</td>
<td class="left">java.lang.Long</td>
</tr>

<tr>
<td class="left">Double</td>
<td class="left">java.lang.Double</td>
</tr>

<tr>
<td class="left">Boolean</td>
<td class="left">java.lang.Boolean</td>
</tr>

<tr>
<td class="left">String</td>
<td class="left">java.lang.String</td>
</tr>

<tr>
<td class="left">Regex</td>
<td class="left">java.util.regex.Pattern</td>
</tr>

<tr>
<td class="left">BigDecimal</td>
<td class="left">java.lang.BigDecimal</td>
</tr>

<tr>
<td class="left">Ratio</td>
<td class="left">clojure.lang.Ratio</td>
</tr>

<tr>
<td class="left">BigInt</td>
<td class="left">clojure.lang.BigInt*</td>
</tr>
</tbody>
</table>

<p>
*Wraps java.lang.BigInteger or long
</p>
</div>
</div>
<div id="outline-container-sec-3-3-2-5" class="outline-5">
<h5 id="sec-3-3-2-5">Clojure Types / Java Interfaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-2-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Clojure Type</th>
<th scope="col" class="left">Implements</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Vector</td>
<td class="left">java.util.List*</td>
</tr>

<tr>
<td class="left">List</td>
<td class="left">java.util.List*</td>
</tr>

<tr>
<td class="left">Map</td>
<td class="left">java.util.Map*</td>
</tr>

<tr>
<td class="left">Set</td>
<td class="left">java.util.Set*</td>
</tr>

<tr>
<td class="left">Function</td>
<td class="left">java.lang.Runnable, j.u.concurrent.Callable</td>
</tr>
</tbody>
</table>

<p>
*Immutable portion only
</p>
</div>
</div>
<div id="outline-container-sec-3-3-2-6" class="outline-5">
<h5 id="sec-3-3-2-6">Generics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-2-6">
<ul class="org-ul">
<li>Java is statically typed
</li>
<li>Clojure is dynamically typed
</li>
</ul>

<div class="org-src-container">

<pre class="src src-fundamental">// a List of Objects which happen to be Strings
java.util.List&lt;String&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">a Vector of Objects which happen to be Strings</span>
[<span class="org-string">"one"</span> <span class="org-string">"two"</span> <span class="org-string">"three"</span>]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">Performance Tuning&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-3-3">
</div><div id="outline-container-sec-3-3-3-1" class="outline-5">
<h5 id="sec-3-3-3-1">Reflection&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-1">
<ul class="org-ul">
<li>Clojure finds Java methods that match arg types
</li>
<li>Uses reflection where necessary
</li>
<li>Can add type hints to improve performance
<ul class="org-ul">
<li>Only do this when there's evidence of a problem&#x2026;
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-3-2" class="outline-5">
<h5 id="sec-3-3-3-2">Reflection Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">capitalize</span> [s]
  (<span class="org-builtin">if</span> (<span class="org-preprocessor">.isEmpty</span> s)
    s
    (<span class="org-builtin">let</span> [up (<span class="org-preprocessor">.toUpperCase</span> (<span class="org-preprocessor">.substring</span> s 0 1))
          down (<span class="org-preprocessor">.toLowerCase</span> (<span class="org-preprocessor">.substring</span> s 1))]
      (<span class="org-preprocessor">.concat</span> up down))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3-3" class="outline-5">
<h5 id="sec-3-3-3-3">Micro-Benchmarking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">time</span> (capitalize <span class="org-string">"CLoJuRe"</span>))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 0.061 msecs"</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Clojure"</span>

(<span class="org-variable-name">time</span> (<span class="org-builtin">dotimes</span> [i 10000] (capitalize <span class="org-string">"CLoJuRe"</span>)))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 212.713 msecs"</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Clojure"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3-4" class="outline-5">
<h5 id="sec-3-3-3-4">JVM Micro-Benchmarking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">dotimes</span> [j 5]
  (<span class="org-variable-name">time</span>
   (<span class="org-builtin">dotimes</span> [i 10000]
     (capitalize <span class="org-string">"CLoJuRe"</span>))))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 184.384 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 182.298 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 168.98 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 173.844 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 173.053 msecs"</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3-5" class="outline-5">
<h5 id="sec-3-3-3-5"><code>*warn-on-reflection*</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-5">
<div class="org-src-container">

<pre class="src src-clojure">(set! *warn-on-reflection* true)

(<span class="org-keyword">defn</span> <span class="org-function-name">capitalize</span> ... )
<span class="org-comment-delimiter">;; </span><span class="org-comment">Reflection warning, NO_SOURCE_FILE:1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">- reference to field isEmpty can't be resolved.</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Reflection warning, NO_SOURCE_FILE:1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">- call to substring can't be resolved.</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Reflection warning, NO_SOURCE_FILE:1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">- call to toUpperCase can't be resolved.</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">...</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3-6" class="outline-5">
<h5 id="sec-3-3-3-6">Add Type Hint Metadata&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">capitalize</span> [<span class="org-type">^String</span> s]  <span class="org-comment">; type hint</span>
  (<span class="org-builtin">if</span> (<span class="org-preprocessor">.isEmpty</span> s)
    s
    (<span class="org-builtin">let</span> [up (<span class="org-preprocessor">.toUpperCase</span> (<span class="org-preprocessor">.substring</span> s 0 1))
          down (<span class="org-preprocessor">.toLowerCase</span> (<span class="org-preprocessor">.substring</span> s 1))]
      (<span class="org-preprocessor">.concat</span> up down))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3-7" class="outline-5">
<h5 id="sec-3-3-3-7">Type-Hinted Performance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-7">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">dotimes</span> [j 5]
  (<span class="org-variable-name">time</span>
   (<span class="org-builtin">dotimes</span> [i 10000]
     (capitalize <span class="org-string">"CLoJuRe"</span>))))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 7.121 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 11.745 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 2.883 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 2.514 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 4.282 msecs"</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3-8" class="outline-5">
<h5 id="sec-3-3-3-8">Type Hint Summary&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-8">
<ul class="org-ul">
<li>Use only when necessary
</li>
<li>Always check with <code>*warn-on-reflection*</code>
</li>
<li><i>Not</i> a static type check or runtime coercion
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-3-9" class="outline-5">
<h5 id="sec-3-3-3-9">Primitive Math&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-9">
<ul class="org-ul">
<li>By default, Clojure numbers are <i>boxed</i> in objects
<ul class="org-ul">
<li><code>java.lang.Long</code>,  <code>java.lang.Double</code>, etc.
</li>
<li>Limits arithmetic performance
</li>
</ul>
</li>
<li>Java has <i>primitive</i> (non-object) types for fast math
<ul class="org-ul">
<li><code>byte</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, etc.
</li>
<li>Cannot be stored in collections (except arrays)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-3-10" class="outline-5">
<h5 id="sec-3-3-3-10">Primitive Math&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-10">
<ul class="org-ul">
<li>Clojure supports primitive <code>long</code> and <code>double</code> only
</li>
<li>Add type hints to fn arguments and return values
</li>
<li>All basic math operations support primitives
</li>
<li>Calling non-primitive fn reverts to boxed numbers
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-3-11" class="outline-5">
<h5 id="sec-3-3-3-11">Primitive Math&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-3-11">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">fib</span> [n]
  (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;=</span> n 1)
    1
    (<span class="org-variable-name">+</span> (fib (<span class="org-variable-name">dec</span> n)) (fib (<span class="org-variable-name">-</span> n 2)))))

(<span class="org-variable-name">time</span> (fib 38))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 3565.579 msecs"</span>

(<span class="org-keyword">defn</span> <span class="org-function-name">fib</span> <span class="org-type">^long</span> [<span class="org-type">^long</span> n]   <span class="org-comment">; hint arg and return</span>
  (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;=</span> n 1)
    1
    (<span class="org-variable-name">+</span> (fib (<span class="org-variable-name">dec</span> n)) (fib (<span class="org-variable-name">-</span> n 2)))))

(<span class="org-variable-name">time</span> (fib 38))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 395.365 msecs"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4">AOT Compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-3-4">
</div><div id="outline-container-sec-3-3-4-1" class="outline-5">
<h5 id="sec-3-3-4-1">AOT Compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-4-1">
<ul class="org-ul">
<li>Clojure is always compiled
<ul class="org-ul">
<li>Usually on-the-fly, while loading code 
</li>
</ul>
</li>
<li>Ahead-of-time (AOT) compilation
<ul class="org-ul">
<li>Write bytecode (.class) files to disk
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-4-2" class="outline-5">
<h5 id="sec-3-3-4-2">Reasons to AOT-compile&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-4-2">
<ul class="org-ul">
<li>Ship without source
</li>
<li>Provide static references for Java code
</li>
<li>Avoid compilation cost on startup
</li>
<li>Special deployment targets, e.g. Android
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-4-3" class="outline-5">
<h5 id="sec-3-3-4-3"><code>compile</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-4-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">compile</span> 'your.namespace)
</pre>
</div>

<ul class="org-ul">
<li>Loads <code>your.namespace</code> with <code>require</code>
</li>
<li>Writes .class files to <code>*clojure-compile-path*</code>
<ul class="org-ul">
<li>Default is <code>classes/</code>
</li>
<li>Both this and source must be on classpath!
</li>
</ul>
</li>
<li>Usually handled by build tools
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-4-4" class="outline-5">
<h5 id="sec-3-3-4-4">Leiningen AOT-compile&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-4-4">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In project.clj</span>
(defproject myproject <span class="org-string">"0.1.0-SNAPSHOT"</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">...</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">AOT-compile these namespaces:</span>
  <span class="org-constant">:aot</span> [com.example.one com.example.two])
</pre>
</div>

<p>
Then in a shell:
</p>

<pre class="example">
lein compile
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-5" class="outline-4">
<h4 id="sec-3-3-5">Mixing Clojure and Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-3-5">
</div><div id="outline-container-sec-3-3-5-1" class="outline-5">
<h5 id="sec-3-3-5-1">Mixing Clojure and Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-1">
<ul class="org-ul">
<li>Two basic models
<ul class="org-ul">
<li>Clojure consuming Java library
</li>
<li>Java consuming Clojure library
</li>
</ul>
</li>
<li>Order of Compilation
<ul class="org-ul">
<li>Clojure compiler is not integrated with <code>javac</code>
</li>
<li>Cannot have circular dependencies in the same compilation unit
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-5-2" class="outline-5">
<h5 id="sec-3-3-5-2">Consuming Java from Clojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-2">
<ul class="org-ul">
<li>Excellent support for calling Java from Clojure
<ul class="org-ul">
<li>Native data types
</li>
<li>Simple interop forms
</li>
</ul>
</li>
<li>What about invoking Java code that needs to callback?
<ul class="org-ul">
<li>E.g., a thread function, async response handler, etc.
</li>
</ul>
</li>
<li>Can implement callbacks a number of ways&#x2026;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-5-3" class="outline-5">
<h5 id="sec-3-3-5-3">Clojure Function Interfaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-3">
<ul class="org-ul">
<li>Functions implement <code>java.lang.Runnable</code> and <code>java.util.concurrent.Callable</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">java.lang.Thread takes a Runnable</span>
(<span class="org-preprocessor">.start</span> (<span class="org-preprocessor">Thread.</span> #(<span class="org-variable-name">println</span> <span class="org-string">"Hello, World!"</span>)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-5-4" class="outline-5">
<h5 id="sec-3-3-5-4">Implementing Other Java Interfaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-4">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">import</span> (some.package <span class="org-preprocessor">IFoo</span>))

(<span class="org-keyword">deftype</span> <span class="org-function-name">Bar</span> [a b]
  <span class="org-preprocessor">IFoo</span>    <span class="org-comment">; class Bar implements IFoo</span>
  (foo [this arg] ...))

(<span class="org-keyword">defrecord</span> <span class="org-function-name">Rab</span> [a b]
  <span class="org-preprocessor">IFoo</span>    <span class="org-comment">; class Rab implements IFoo</span>
  (foo [this arg] ...))

(<span class="org-variable-name">reify</span>    <span class="org-comment">; instance of anonymous class </span>
  <span class="org-preprocessor">IFoo</span>    <span class="org-comment">; which implements IFoo</span>
  (foo [this arg] ...))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-5-5" class="outline-5">
<h5 id="sec-3-3-5-5"><code>proxy</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-5">
<ul class="org-ul">
<li>Can extend classes
<ul class="org-ul">
<li>Provide arguments to base class constructor  
</li>
</ul>
</li>
<li>Can access super (via reflection)
</li>
<li>For interop only
</li>
<li>Prefer <code>reify</code> when you only need interfaces
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">proxy</span> [class-and-interfaces*]
    [constructor-arguments*]
  (method [args*] ...))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-5-6" class="outline-5">
<h5 id="sec-3-3-5-6"><code>proxy</code> Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">proxy</span> [<span class="org-preprocessor">JTable</span>]  <span class="org-comment">; extend JTable</span>
    []   <span class="org-comment">; base class constructor arguments</span>
  (<span class="org-preprocessor">prepareRenderer</span> [renderer row col]  <span class="org-comment">; override method</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">invoke superclass method:</span>
    (<span class="org-builtin">doto</span> (<span class="org-variable-name">proxy-super</span> <span class="org-preprocessor">prepareRenderer</span> renderer row col)
      (<span class="org-preprocessor">.setBackground</span> (<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> row)
                        <span class="org-preprocessor">Color/lightGray</span>
                        <span class="org-preprocessor">Color/white</span>)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-5-7" class="outline-5">
<h5 id="sec-3-3-5-7">Consuming Clojure from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-7">
<ul class="org-ul">
<li>Two approaches
<ul class="org-ul">
<li>Bind and invoke functions
</li>
<li>Instantiate records/types and invoke protocol methods
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-5-8" class="outline-5">
<h5 id="sec-3-3-5-8">Clojure Functions from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-8">
<ul class="org-ul">
<li>Clojure 1.6.0 added a Clojure Java API
<ul class="org-ul">
<li><code>clojure.java.api.Clojure</code>
</li>
<li><a href="http://clojure.github.io/clojure/javadoc/">http://clojure.github.io/clojure/javadoc/</a>
</li>
</ul>
</li>
<li>Two methods to invoke anything in Clojure
<ul class="org-ul">
<li><code>Clojure.var</code> gets an IFn by name
</li>
<li><code>IFn.invoke</code> calls function bound to the Var
</li>
</ul>
</li>
<li>Easy to wrap in a Java facade class
</li>
</ul>

<div class="org-src-container">

<pre class="src src-fundamental">import clojure.java.api.Clojure;
import clojure.lang.IFn;

IFn PRINTLN = Clojure.var(<span class="org-string">"clojure.core"</span>, <span class="org-string">"println"</span>);
PRINTLN.invoke(<span class="org-string">"Hello, world!"</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-5-9" class="outline-5">
<h5 id="sec-3-3-5-9">Clojure Types from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-9">
<ul class="org-ul">
<li>AOT-compile a namespace containing deftype/defrecord
<ul class="org-ul">
<li>Type will be accessible by name in Java code
</li>
<li>Constructor takes type fields in order 
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-5-10" class="outline-5">
<h5 id="sec-3-3-5-10">Clojure Types from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-10">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Clojure</span>
(<span class="org-builtin">ns</span> com.example.my-project)

(<span class="org-keyword">deftype</span> <span class="org-function-name">Foo</span> [a b])
</pre>
</div>

<div class="org-src-container">

<pre class="src src-fundamental">// Java
import com.example.my_project.Foo;

Foo f = new Foo(1, 2);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-5-11" class="outline-5">
<h5 id="sec-3-3-5-11">Clojure Protocols from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-11">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Clojure</span>
(<span class="org-builtin">ns</span> com.example.my-app)

(<span class="org-keyword">defprotocol</span> <span class="org-function-name">IFoo</span>
  (do-stuff [this a b] <span class="org-string">"Do stuff"</span>))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-fundamental">// Java
import com.example.my_app.IFoo;

public class Bar implements IFoo {
    public Object do_stuff(Object a, Object b) {
        ...
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-5-12" class="outline-5">
<h5 id="sec-3-3-5-12"><code>gen-class</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-12">
<ul class="org-ul">
<li>Does nothing unless AOT-compiling
</li>
<li>Generates Java class
<ul class="org-ul">
<li>Can extend/implement classes/interfaces
</li>
<li>Methods dispatch to Clojure functions 
</li>
<li>Can produce Java <code>main</code> method
</li>
</ul>
</li>
<li>For Java interop only
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-5-13" class="outline-5">
<h5 id="sec-3-3-5-13"><code>gen-class</code> Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-3-3-5-13">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> com.example.my-app
  (<span class="org-constant">:gen-class</span>))

(<span class="org-keyword">defn</span> <span class="org-function-name">-main</span>
  [&amp; greetees]
  (<span class="org-builtin">doseq</span> [name greetees]
    (<span class="org-variable-name">println</span> (<span class="org-variable-name">str</span> <span class="org-string">"Hi "</span> name <span class="org-string">"!"</span>))))
</pre>
</div>

<pre class="example">
java -cp .:clojure.jar com.example.my_app Bob Sally

Hi Bob!
Hi Sally!
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">LAB: Type Hints and Primitive Arithmetic&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-3-4">
</div>

<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">Description</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
In this lab, we will do some simple image processing as a way to
explore some of the optimizations built into the Clojure compiler.
Both image processing and optimization are complex topics, so you
should focus on simply becoming familiar with the available
techniques; the performance effects they have here will <b>not</b> be the
same in your projects.
</p>

<p>
You may find the documentation for the <a href="http://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferedImage.html">BufferedImage</a> class helpful for this lab.
</p>
</div>
</div>
<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">Setup</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
You will need an image to work with in this lab. You can use anything
you like, but if you don't have one, feel free to use this one of John
McCarthy, the creator of Lisp:
</p>


<div class="figure">
<p><img src="slide-assets/john-mccarthy.jpg" alt="john-mccarthy.jpg" />
</p>
</div>

<p>
Whatever image you choose, save it to your hard drive and note the
location. Then evaluate the following code:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">import</span> (javax.swing <span class="org-preprocessor">JButton</span> <span class="org-preprocessor">JPanel</span> <span class="org-preprocessor">JFrame</span>)
        <span class="org-preprocessor">java.awt.event.ActionListener</span>
        <span class="org-preprocessor">javax.imageio.ImageIO</span>
        <span class="org-preprocessor">java.awt.Color</span>
        <span class="org-preprocessor">java.awt.image.BufferedImage</span>)

<span class="org-comment-delimiter">;; </span><span class="org-comment">TODO: Change the path to point to the image you want to use</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Supported file types may vary by system, but likely include</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">BMP, JPG, PNG, and GIF. JPG is a safe choice</span>
(<span class="org-keyword">def</span> <span class="org-function-name">image</span> (<span class="org-variable-name">atom</span> (<span class="org-preprocessor">ImageIO/read</span> (<span class="org-preprocessor">java.io.File.</span> <span class="org-string">"/path/to/image.jpg"</span>))))
</pre>
</div>

<p>
Now we need to write a basic Swing app that will display an image and
allow us to transform it. Copy the following code into the REPL and
evaluate it:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">paint</span> [g]
  (<span class="org-builtin">let</span> [bounds (<span class="org-preprocessor">.getClipBounds</span> g)
        width (<span class="org-preprocessor">.getWidth</span> bounds)
        height (<span class="org-preprocessor">.getHeight</span> bounds)]
    (<span class="org-preprocessor">.drawImage</span> g @image 0 0 width height <span class="org-preprocessor">Color/black</span> nil)))

(<span class="org-keyword">defn</span> <span class="org-function-name">transform</span> [image]
  (<span class="org-builtin">let</span> [width (<span class="org-preprocessor">.getWidth</span> image)
        height (<span class="org-preprocessor">.getHeight</span> image)
        <span class="org-preprocessor">newImage</span> (<span class="org-preprocessor">BufferedImage.</span> width height (<span class="org-preprocessor">.getType</span> image))]
    (<span class="org-builtin">doseq</span> [x (<span class="org-variable-name">range</span> 0 width)
            y (<span class="org-variable-name">range</span> 0 height)]
      (<span class="org-preprocessor">.setRGB</span> <span class="org-preprocessor">newImage</span> x (<span class="org-variable-name">-</span> height y 1) (<span class="org-preprocessor">.getRGB</span> image x y)))
    <span class="org-preprocessor">newImage</span>))

(<span class="org-keyword">defn</span> <span class="org-function-name">sample-app</span> []
  (<span class="org-builtin">let</span> [frame (<span class="org-preprocessor">JFrame.</span> <span class="org-string">"Sample Application"</span>)
        panel (<span class="org-variable-name">proxy</span> [<span class="org-preprocessor">JPanel</span> <span class="org-preprocessor">ActionListener</span>] []
                (<span class="org-preprocessor">getPreferredSize</span> [] nil)
                (<span class="org-preprocessor">paintComponent</span> [g]
                  (<span class="org-variable-name">proxy-super</span> <span class="org-preprocessor">paintComponent</span> g)
                  (paint g))
                (<span class="org-preprocessor">actionPerformed</span> [e]
                  (<span class="org-variable-name">println</span> <span class="org-string">"Transforming image"</span>)
                  (<span class="org-variable-name">time</span> (<span class="org-variable-name">swap!</span> image transform))
                  (<span class="org-preprocessor">.repaint</span> this)))
        button (<span class="org-preprocessor">JButton.</span> <span class="org-string">"Transform!"</span>)]
    (<span class="org-preprocessor">.setOpaque</span> panel true)
    (<span class="org-preprocessor">.addActionListener</span> button panel)
    (<span class="org-preprocessor">.add</span> panel button)
    (<span class="org-preprocessor">.setContentPane</span> frame panel)
    (<span class="org-preprocessor">.setSize</span> frame 500 600)
    (<span class="org-preprocessor">.setLocationByPlatform</span> frame true)
    (<span class="org-preprocessor">.setLocation</span> frame 50 50)
    (<span class="org-preprocessor">.setVisible</span> frame true)
    panel))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3">Run the application</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
At this point, you have a simple application that will display an
image. You can run the app by evaluating the following statement:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(sample-app)
</pre>
</div>

<p>
Clicking the "Transform!" button will flip the image top-to-bottom.
You will see the amount of time the computation took printed at the
REPL. Make sure you run it more than once, since the run times may be
different on invocations other than the first.
</p>

<p>
Depending on the image you chose and the capabilities of your
computer, this computation may be quite lengthy. We'll attempt to
change that in the next step.
</p>
</div>
</div>
<div id="outline-container-sec-3-4-4" class="outline-4">
<h4 id="sec-3-4-4">Add type hints</h4>
<div class="outline-text-4" id="text-3-4-4">
<p>
Add type hints to <code>transform</code> so that the compiler no longer needs to
use reflection to call the <code>getRGB</code> and <code>setRGB</code> methods. Evaluate
your new version and click the "Transform!" button (there should be no
need to restart the application). Make sure you click "Transform!"
several times to give the JVM an opportunity to perform runtime
optimizations.
</p>

<p>
Did the computation get any faster? Why or why not?
</p>
</div>

<div id="outline-container-sec-3-4-4-1" class="outline-5">
<h5 id="sec-3-4-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-4-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transform</span> [<span class="org-type">^BufferedImage</span> image]
  (<span class="org-builtin">let</span> [width (<span class="org-preprocessor">.getWidth</span> image)
       height (<span class="org-preprocessor">.getHeight</span> image)
       <span class="org-type">^BufferedImage</span> <span class="org-preprocessor">newImage</span> (<span class="org-preprocessor">BufferedImage.</span> width height (<span class="org-preprocessor">.getType</span> image))]
   (<span class="org-builtin">doseq</span> [x (<span class="org-variable-name">range</span> 0 width)
           y (<span class="org-variable-name">range</span> 0 height)]
     (<span class="org-preprocessor">.setRGB</span> <span class="org-preprocessor">newImage</span> x (<span class="org-variable-name">-</span> height y 1) (<span class="org-preprocessor">.getRGB</span> image x y)))
   <span class="org-preprocessor">newImage</span>))
</pre>
</div>

<p>
On the author's machine, this version of the algorithm runs
approximately 10 times faster than the un-hinted version, due to the
removal of the need to do reflection.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-4-5" class="outline-4">
<h4 id="sec-3-4-5">Use primitive arithmetic</h4>
<div class="outline-text-4" id="text-3-4-5">
<p>
Now update <code>transform</code> so that it uses primitive rather than boxed
numbers in its calculations. (<b>Hint</b>: you will need to use <code>loop</code> and
<code>recur</code> rather than <code>doseq</code>.) Make sure you click "Transform!" several
times to give the JVM an opportunity to perform runtime optimizations.
</p>

<p>
Did the computation get any faster? Why or why not?
</p>
</div>

<div id="outline-container-sec-3-4-5-1" class="outline-5">
<h5 id="sec-3-4-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-4-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transform</span> [<span class="org-type">^BufferedImage</span> image]
  (<span class="org-builtin">let</span> [width (<span class="org-preprocessor">.getWidth</span> image)
        height (<span class="org-preprocessor">.getHeight</span> image)
        <span class="org-type">^BufferedImage</span> <span class="org-preprocessor">newImage</span> (<span class="org-preprocessor">BufferedImage.</span> width height (<span class="org-preprocessor">.getType</span> image))]
    (<span class="org-builtin">loop</span> [x 0 y 0]
      (<span class="org-builtin">when-not</span> (<span class="org-variable-name">=</span> y height)
        (<span class="org-preprocessor">.setRGB</span> <span class="org-preprocessor">newImage</span> x (<span class="org-variable-name">-</span> height y 1) (<span class="org-preprocessor">.getRGB</span> image x y))
        (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> x (<span class="org-variable-name">-</span> width 1))
          (<span class="org-builtin">recur</span> 0 (<span class="org-variable-name">inc</span> y))
          (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> x) y))))
    <span class="org-preprocessor">newImage</span>))
</pre>
</div>

<p>
On the author's machine, this version of the algorithm runs
approximately 50% faster than the type-hinted version, due to the
removal of boxing and unboxing of integers.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-4-6" class="outline-4">
<h4 id="sec-3-4-6">Use array manipulation (optional)</h4>
<div class="outline-text-4" id="text-3-4-6">
<p>
Our approach of using individual method calls to get at each element
of the image data seems like it can't possibly be the best way.
Instead, let's retrieve the data into a Java array and operate
directly on that.
</p>

<p>
Redefine <code>transform</code> so that it gets the data from the input image
into a primitive Java array, manipulates it there, and creates a new
image from the generated data. Make sure you click "Transform!"
several times to give the JVM an opportunity to perform runtime
optimizations.
</p>

<p>
Did the computation get any faster? Why or why not?
</p>
</div>

<div id="outline-container-sec-3-4-6-1" class="outline-5">
<h5 id="sec-3-4-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-4-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transform</span> [<span class="org-type">^BufferedImage</span> image]
  (<span class="org-builtin">let</span> [width (<span class="org-variable-name">int</span> (<span class="org-preprocessor">.getWidth</span> image))
        height (<span class="org-variable-name">int</span> (<span class="org-preprocessor">.getHeight</span> image))
        <span class="org-preprocessor">newImage</span> (<span class="org-preprocessor">BufferedImage.</span> width height (<span class="org-preprocessor">.getType</span> image))
        <span class="org-type">^ints</span> <span class="org-preprocessor">oldData</span> (<span class="org-preprocessor">.getRGB</span> image 0 0 width height nil 0 width)
        <span class="org-type">^ints</span> <span class="org-preprocessor">newData</span> (<span class="org-variable-name">int-array</span> (<span class="org-variable-name">*</span> width height))]
    (<span class="org-builtin">loop</span> [x 0 y 0]
      (<span class="org-builtin">when-not</span> (<span class="org-variable-name">=</span> y height)
        (<span class="org-variable-name">aset</span> <span class="org-preprocessor">newData</span> (<span class="org-variable-name">+</span> x (<span class="org-variable-name">*</span> y width)) (<span class="org-variable-name">aget</span> <span class="org-preprocessor">oldData</span> (<span class="org-variable-name">+</span> x (<span class="org-variable-name">*</span> width (<span class="org-variable-name">-</span> height y 1)))))
        (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> x (<span class="org-variable-name">-</span> width 1))
          (<span class="org-builtin">recur</span> 0 (<span class="org-variable-name">inc</span> y))
          (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> x) y))))
    (<span class="org-preprocessor">.setRGB</span> <span class="org-preprocessor">newImage</span> 0 0 width height <span class="org-preprocessor">newData</span> 0 width)
    <span class="org-preprocessor">newImage</span>))
</pre>
</div>

<p>
On the author's machine, this version of the algorithm is no faster
than the version that uses primitive arithmetic. This may be somewhat
surprising to you. The truth is that the JVM does a lot of clever
optimizations, and modern machine architectures are quite complicated,
making for a complex relationship between the structure of your code
and its performance.
</p>

<p>
This points out that you should always use a measurement-based
approach to selecting appropriate optimizations.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">core.async&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-3-5">
</div>

<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">Motivations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>Avoiding "callback hell"
</li>
<li>Programming with processes and queues
</li>
<li>Efficient use of threads (in JVM)
</li>
<li>Enabling use of queues without threads (in JS)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2">Channels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>A means of conveying values, like queues
</li>
<li>Multiple readers, multiple writers
</li>
<li>Enduring relationship
</li>
<li>First class, pass them around
</li>
<li>select/alt - wait for many channel ops
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3">Blocking / parking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>Channels are NEVER unbounded length
<ul class="org-ul">
<li>Unbounded channels are future scaling problems
</li>
<li>Bounded channels create backpressure
</li>
<li>You must decide on a buffering policy
</li>
</ul>
</li>
<li>Producer blocks/parks if channel full
</li>
<li>Consumer blocks/parks if channel empty
</li>
<li>Provided buffers - fixed, dropping, sliding
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-4" class="outline-4">
<h4 id="sec-3-5-4">Creating channels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-4">
<div class="org-src-container">

<pre class="src src-clojure">(chan)                      <span class="org-comment">; new channel, capacity=0</span>

(chan 10)                   <span class="org-comment">; new channel, capacity=10</span>

(chan buffer)               <span class="org-comment">; new channel with custom buffer</span>

(chan (dropping-buffer 10)) <span class="org-comment">; on full, drop newest values</span>

(chan (sliding-buffer 10))  <span class="org-comment">; on full, drop oldest values</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-5" class="outline-4">
<h4 id="sec-3-5-5">Process types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-5">
<ul class="org-ul">
<li>go blocks - JVM or JS
<ul class="org-ul">
<li>"Lightweight" processes
</li>
<li>Not bound to threads
</li>
<li>Channel ops DO NOT block threads
</li>
</ul>
</li>

<li>Threads - JVM only
<ul class="org-ul">
<li>Normal threads
</li>
<li>Channel ops DO block threads
</li>
</ul>
</li>

<li>Channels work in either world and between them
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-6" class="outline-4">
<h4 id="sec-3-5-6">Channel put&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-6">
<ul class="org-ul">
<li>Put - place a value on a channel
<ul class="org-ul">
<li>Note: nil is not allowed as a message
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Parking put (go blocks)</span>
(&gt;! ch msg)

<span class="org-comment-delimiter">;; </span><span class="org-comment">Blocking put (threads)</span>
(&gt;!! ch msg)

<span class="org-comment-delimiter">;; </span><span class="org-comment">Async put (either) - outside callbacks</span>
(put! ch msg callback on-caller?)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-7" class="outline-4">
<h4 id="sec-3-5-7">Channel take&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-7">
<ul class="org-ul">
<li>Take - take a value from a channel
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Parking take (go blocks)</span>
(&lt;! ch)

<span class="org-comment-delimiter">;; </span><span class="org-comment">Blocking take (threads)</span>
(&lt;!! ch)

<span class="org-comment-delimiter">;; </span><span class="org-comment">Async take (either) - outside callbacks</span>
(take! ch fn on-caller?)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-8" class="outline-4">
<h4 id="sec-3-5-8">Channel close&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-8">
<ul class="org-ul">
<li>Close - accept no further inputs
<ul class="org-ul">
<li>Puts are ignored
</li>
<li>Data in the channel remains available
</li>
<li>When data is gone, takes return nil
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Close a channel</span>
(close! ch)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-9" class="outline-4">
<h4 id="sec-3-5-9">Putting collections on channel&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-9">
<ul class="org-ul">
<li><code>to-chan</code> - makes a channel from a collection
</li>
<li><code>onto-chan</code> - put contents of coll onto chan (optional close)
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [ch (chan 1)]
  (onto-chan ch (<span class="org-variable-name">range</span> 10))  <span class="org-comment-delimiter">;; </span><span class="org-comment">then close ch</span>
  (<span class="org-variable-name">println</span> (&lt;!! ch)))        <span class="org-comment-delimiter">;; </span><span class="org-comment">0</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-10" class="outline-4">
<h4 id="sec-3-5-10">Pulling collection from channel</h4>
<div class="outline-text-4" id="text-3-5-10">
<ul class="org-ul">
<li><code>into</code> - returns chan containing coll drained from a chan
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(&lt;!! (<span class="org-variable-name">into</span> [] (to-chan (<span class="org-variable-name">range</span> 5))))
<span class="org-comment-delimiter">;; </span><span class="org-comment">[0 1 2 3 4]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-11" class="outline-4">
<h4 id="sec-3-5-11">Thread helpers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-11">
<ul class="org-ul">
<li><code>thread</code> - like <code>future</code>
<ul class="org-ul">
<li>executes body immediately in another thread
</li>
<li>returns a channel which gets the result of body
</li>
</ul>
</li>

<li><code>thread-call</code> - like <code>future-call</code>
<ul class="org-ul">
<li>runs f immediately in another thread 
</li>
<li>returns a channel which gets the result of invoking f
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-12" class="outline-4">
<h4 id="sec-3-5-12">go blocks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-12">
<ul class="org-ul">
<li>Executes body asynchronously 
</li>
<li>Returns channel which will contain body's result
</li>
<li>Calls to <code>&gt;!</code>, <code>&lt;!</code>, <code>alt!</code>, <code>alts!</code> "park", not block
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">sink</span> [out-chan]
  (go 
    (<span class="org-builtin">loop</span> []
      (<span class="org-variable-name">println</span> (&lt;! out-chan))
      (<span class="org-builtin">recur</span>))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-13" class="outline-4">
<h4 id="sec-3-5-13">go-loop&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-13">
<ul class="org-ul">
<li>Helper <code>go-loop</code> macro captures this common pattern
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">sink</span> [out-chan]
  (go-loop [] 
    (<span class="org-variable-name">println</span> (&lt;! out-chan))
    (<span class="org-builtin">recur</span>)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-14" class="outline-4">
<h4 id="sec-3-5-14">alts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-14">
<ul class="org-ul">
<li>Wait for the first of several channel ops to return
</li>
<li>On success, exactly one op has completed
</li>
</ul>


<div class="figure">
<p><img src="slide-assets/async-alts.svg" alt="async-alts.svg" />
</p>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">price</span> [symbol]
  (<span class="org-builtin">let</span> [chs [(lookup-google symbol) 
             (lookup-yahoo symbol)]]
    (go
      (<span class="org-builtin">let</span> [[result ch] (alts! chs)]
        result))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-15" class="outline-4">
<h4 id="sec-3-5-15">timeout&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-15">
<ul class="org-ul">
<li><code>timeout</code> is just a channel that waits then closes
</li>
<li>Commonly used with <code>alts</code> to allow operations to time out
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">price</span> [symbol ms]
  (go
    (<span class="org-builtin">let</span> [t (timeout ms)
          q (lookup-google symbol)
          [result ch] (alts! [t q])]
      result)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-16" class="outline-4">
<h4 id="sec-3-5-16">alt&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-16">
<ul class="org-ul">
<li><code>alt!</code>, <code>alt!!</code> - combines <code>alts</code> + a cond
</li>
<li>On matched response, perform an action 
</li>
<li>If multiple ops ready - can do random or in-order
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">info</span> [symbol ms]
  (go 
    (<span class="org-builtin">let</span> [t (timeout ms)
          n (news-search symbol)
          q (price symbol)]
      (alt! 
        t ([_]       {<span class="org-constant">:timeout</span> true}) 
        n ([article] {<span class="org-constant">:news</span> article})
        q ([price]   {<span class="org-constant">:price</span> price})))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-17" class="outline-4">
<h4 id="sec-3-5-17">Channel transducer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-17">
<ul class="org-ul">
<li>Transforming channel using a transducer
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [xf (<span class="org-variable-name">comp</span> (<span class="org-variable-name">filter</span> odd?) (<span class="org-variable-name">map</span> inc))
      ch (chan 1 xf)]
  (onto-chan ch (<span class="org-variable-name">range</span> 10))
  (<span class="org-variable-name">into</span> [] ch)) <span class="org-comment-delimiter">;; </span><span class="org-comment">[2 4 6 8 10]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-18" class="outline-4">
<h4 id="sec-3-5-18">Channel pipe&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-18">
<ul class="org-ul">
<li><code>pipe</code> - connects two channels together using a <code>go</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [from (chan 1)
      to   (chan 1)]
  (pipe from to)     <span class="org-comment-delimiter">;; </span><span class="org-comment">returns "to" channel</span>
  (&gt;!! from <span class="org-string">"hi"</span>)
  (<span class="org-variable-name">println</span> (&lt;!! to)) <span class="org-comment-delimiter">;; </span><span class="org-comment">"hi"</span>
  (close! from))     <span class="org-comment-delimiter">;; </span><span class="org-comment">pipe will close "to"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-19" class="outline-4">
<h4 id="sec-3-5-19">Channel pipeline&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-19">
<ul class="org-ul">
<li><code>pipeline</code> <code>pipeline-blocking</code> <code>pipeline-async</code>
</li>
<li>Pipelines connect one channel to another like pipe
</li>
<li>But execute a transformation in parallel in the process
</li>
<li>Requires Clojure 1.7.0 for transducers
</li>
<li>Execute (map inc) in 4 parallel threads on from chan:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [from (to-chan (<span class="org-variable-name">range</span> 1000))
      to   (chan 10)]
  (pipeline 4 to (<span class="org-variable-name">map</span> inc) from))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-20" class="outline-4">
<h4 id="sec-3-5-20">Other channel functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-20">
<ul class="org-ul">
<li><code>merge</code> <code>split</code> - merge or split channels
</li>
<li><code>take</code> - returns channel that takes n messages from a channel
</li>
<li><code>reduce</code> - reduce over a channel
</li>
<li><code>map</code> - map a function over multiple input channels
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-21" class="outline-4">
<h4 id="sec-3-5-21">Mult&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-21">
<ul class="org-ul">
<li>Broadcast data from one channel to multiple receivers
<ul class="org-ul">
<li>All taps must accept in parallel
</li>
<li>Puts are dropped while no taps are connected
</li>
<li>Taps are dropped if they throw an exception
</li>
<li>By default, taps close when the input channel closes
</li>
</ul>
</li>
</ul>


<div class="figure">
<p><img src="slide-assets/async-mult.svg" alt="async-mult.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-22" class="outline-4">
<h4 id="sec-3-5-22">Mult API&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-22">
<ul class="org-ul">
<li><code>mult</code> - Creates a multiple of a channel
</li>
<li><code>tap</code> - Attach a channel to the mult
</li>
<li><code>untap</code>, <code>untap-all</code> - detach tapped channels from the mult
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-23" class="outline-4">
<h4 id="sec-3-5-23">Pub/sub&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-23">
<ul class="org-ul">
<li>Publish/subscribe with topics
</li>
</ul>


<div class="figure">
<p><img src="slide-assets/async-pub.svg" alt="async-pub.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-24" class="outline-4">
<h4 id="sec-3-5-24">Pub/sub API&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-24">
<ul class="org-ul">
<li><code>pub</code> - Create a publication of a channel for a topic fn
<ul class="org-ul">
<li>Topic fn applied to each value to create a topic 
</li>
<li>Published values are dropped if no subscribers
</li>
<li>All subs receive a topic value in parallel
</li>
</ul>
</li>
<li><code>sub</code> - Subscribe to a topic
<ul class="org-ul">
<li>By default, subs close when pub closes
</li>
</ul>
</li>
<li><code>unsub</code>, <code>unsub-all</code> - Unsubscribe from a topic
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-25" class="outline-4">
<h4 id="sec-3-5-25">Mixer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-25">
<ul class="org-ul">
<li>Many inputs to a mixed output
</li>
<li>Mixes support soloing, muting, and pausing inputs
</li>
</ul>


<div class="figure">
<p><img src="slide-assets/async-mix.svg" alt="async-mix.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-5-26" class="outline-4">
<h4 id="sec-3-5-26">Mixer API&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-5-26">
<ul class="org-ul">
<li><code>mix</code> - Creates a mix of input channels supplied to an output
</li>
<li><code>admix</code> - Add channel to mix
</li>
<li><code>unmix</code>, <code>unmix-all</code> - Remove channel from mix
</li>
<li><code>toggle</code> - Atomically change input channel modes in mix
</li>
<li><code>solo-mode</code> - Change solo-mode of mix to :mute or :pause
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">LAB: core.async&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-3-6">
</div>

<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1">Introduction</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
In this lab, we will write a few simple programs to exercise
core.async. The goal is mainly to start thinking in terms of
processes and channels, not to fully explore the API.
</p>
</div>
</div>
<div id="outline-container-sec-3-6-2" class="outline-4">
<h4 id="sec-3-6-2">Channel basics</h4>
<div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>Create a channel with fixed buffer size 1
</li>
<li>Put a message to this channel (use blocking put)
</li>
<li>Take the message out of the channel (use blocking take)
</li>
<li>Close the channel
</li>
</ul>

<p>
You will need to require the clojure.core.async namespace to access 
its functions:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.core.async 
  <span class="org-constant">:refer</span> (chan &gt;!! &lt;!! &gt;! &lt;! close! go go-loop timeout alt! alt!! alts! alts!!)])
</pre>
</div>
</div>

<div id="outline-container-sec-3-6-2-1" class="outline-5">
<h5 id="sec-3-6-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-6-2-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">c</span> (chan 1))
(&gt;!! c <span class="org-string">"hello"</span>)
(&lt;!! c)
(close! c)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-6-3" class="outline-4">
<h4 id="sec-3-6-3">go blocks</h4>
<div class="outline-text-4" id="text-3-6-3">
<p>
Create a <code>go</code> block that takes an input channel. The <code>go</code> block should
loop, taking messages from the input channel and printing the
message. If the input channel is closed, the go block should exit the loop.
</p>

<p>
Test it by sending some messages on the input channel.
What happens if you pass false as a message?
</p>
</div>

<div id="outline-container-sec-3-6-3-1" class="outline-5">
<h5 id="sec-3-6-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-6-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">c</span> (chan 1))
(go-loop []
  (<span class="org-builtin">let</span> [v (&lt;! c)]
    (<span class="org-builtin">when</span> (<span class="org-variable-name">not</span> (<span class="org-variable-name">nil?</span> v))
      (<span class="org-variable-name">println</span> <span class="org-string">"Message:"</span> v)
      (<span class="org-builtin">recur</span>))))

(&gt;!! c <span class="org-string">"hi"</span>)
(&gt;!! c false)
(close! c)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-6-4" class="outline-4">
<h4 id="sec-3-6-4">Timeouts</h4>
<div class="outline-text-4" id="text-3-6-4">
<p>
Create a process that uses alts! to wait 10 seconds to receive one
message, then exits. If a message is received, print it. If timeout
occurs, print a message to that effect.
</p>
</div>

<div id="outline-container-sec-3-6-4-1" class="outline-5">
<h5 id="sec-3-6-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-6-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">c</span> (chan 1))
(go
  (<span class="org-builtin">let</span> [t (timeout (<span class="org-variable-name">*</span> 10 1000))
        [v ch] (alts! [t c])]
    (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> ch t)
      (<span class="org-variable-name">println</span> <span class="org-string">"Timeout occurred!"</span>)
      (<span class="org-variable-name">println</span> <span class="org-string">"Received:"</span> v))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-6-5" class="outline-4">
<h4 id="sec-3-6-5">alt conditions</h4>
<div class="outline-text-4" id="text-3-6-5">
<p>
Rework the last example using alt!.
</p>
</div>

<div id="outline-container-sec-3-6-5-1" class="outline-5">
<h5 id="sec-3-6-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-6-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">c</span> (chan 1))
(go
  (alt!
    (timeout (<span class="org-variable-name">*</span> 10 1000)) (<span class="org-variable-name">println</span> <span class="org-string">"Timeout occurred!"</span>)
    c                     ([v] (<span class="org-variable-name">println</span> <span class="org-string">"Received:"</span> v))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-6-6" class="outline-4">
<h4 id="sec-3-6-6">Forward</h4>
<div class="outline-text-4" id="text-3-6-6">
<p>
Define a function <code>forward</code> that creates a process taking an input
channel, an output channel, and a number n. The process should read
a message from the input channel, print the message, and write the
message to the output channel. After n messages have been received,
it should close the output channel. You may find it useful to print
the remaining message count with the value.
</p>
</div>

<div id="outline-container-sec-3-6-6-1" class="outline-5">
<h5 id="sec-3-6-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-6-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">forward</span> [input output n]
  (go-loop [remaining n]
           (<span class="org-builtin">if</span> (zero? remaining)
             (close! output)
             (<span class="org-builtin">let</span> [v (&lt;! input)]
               (<span class="org-variable-name">println</span> remaining v)
               (&gt;! output v)
               (<span class="org-builtin">recur</span> (<span class="org-variable-name">dec</span> remaining))))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-6-7" class="outline-4">
<h4 id="sec-3-6-7">Ping-pong</h4>
<div class="outline-text-4" id="text-3-6-7">
<p>
Define a <code>ping-pong</code> function that creates two channels and two
processes that will forward a message back and forth 5 times. You
can use the forward function to achieve this.
</p>
</div>

<div id="outline-container-sec-3-6-7-1" class="outline-5">
<h5 id="sec-3-6-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-6-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">ping-pong</span> []
  (<span class="org-builtin">let</span> [c1 (chan 1)
        c2 (chan 1)]
    (forward c1 c2 5)
    (forward c2 c1 5)
    (&gt;!! c1 <span class="org-string">"hello"</span>)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">Web Development&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-3-7">
</div>

<div id="outline-container-sec-3-7-1" class="outline-4">
<h4 id="sec-3-7-1">Philosophy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-1">
<ul class="org-ul">
<li>Libraries not frameworks
</li>
<li>Focus on data representation
</li>
<li>Maximize use of pure functions
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-2" class="outline-4">
<h4 id="sec-3-7-2">Ring flow&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-2">
<ul class="org-ul">
<li>Adapters (connect web server to Ring)
</li>
<li>Middleware (transform requests and responses)
</li>
<li>Handlers (termination of the flow)
</li>
</ul>


<div class="figure">
<p><img src="slide-assets/ring.svg" alt="ring.svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-7-3" class="outline-4">
<h4 id="sec-3-7-3">Ring adapter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-3">
<ul class="org-ul">
<li>Implements HTTP and connects a server to Ring
</li>
<li>By default, Ring uses ring-jetty-adapter
</li>
<li>Many other adapters exist
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-4" class="outline-4">
<h4 id="sec-3-7-4">Ring handler&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-4">
<ul class="org-ul">
<li>Accepts a Ring request map
</li>
<li>Returns a Ring response map
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">handler</span> [request] 
  {<span class="org-constant">:status</span> 200 
   <span class="org-constant">:headers</span> {<span class="org-string">"Content-Type"</span> <span class="org-string">"text/html"</span>}
   <span class="org-constant">:body</span> <span class="org-string">"&lt;html&gt;&lt;body&gt;Hello Ring!&lt;/body&gt;&lt;/html&gt;"</span>})
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-7-5" class="outline-4">
<h4 id="sec-3-7-5">Ring middleware&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-5">
<ul class="org-ul">
<li>Transforms requests, responses, or both
</li>
<li>Middleware available to handle many things:
<ul class="org-ul">
<li>Form and query parameter extraction
</li>
<li>Authentication
</li>
<li>Sessions and cookies
</li>
<li>Parsing and emitting content types (JSON, etc)
</li>
<li>Compression (gzip)
</li>
<li>Exception handling and logging
</li>
<li>lots more
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-6" class="outline-4">
<h4 id="sec-3-7-6">Middleware example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-6">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">noisy-middleware</span> [handler]
  (<span class="org-variable-name">fn</span> [request]
    (<span class="org-variable-name">println</span> <span class="org-string">"\nRequest:"</span>)
    (clojure.pprint/pprint request)
    (handler request)))

(run-jetty (noisy-middleware handler) {<span class="org-constant">:port</span> 3001})
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-7-7" class="outline-4">
<h4 id="sec-3-7-7">Ring requests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-7">
<ul class="org-ul">
<li>Map of well-known contents
<ul class="org-ul">
<li><code>:server-port</code> - incoming port
</li>
<li><code>:server-name</code> - incoming resolved server name
</li>
<li><code>:remote-addr</code> - IP address of client
</li>
<li><code>:uri</code> - request path (after domain name)
</li>
<li><code>:query-string</code> - if present
</li>
<li><code>:schema</code> - <code>:http</code> or <code>:https</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-8" class="outline-4">
<h4 id="sec-3-7-8">Ring requests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-8">
<ul class="org-ul">
<li>More keys&#x2026;.
<ul class="org-ul">
<li><code>:request-method</code> - <code>:get</code>, <code>:head</code>, <code>:options</code>, <code>:put</code>, <code>:post</code>,
    <code>:delete</code>
</li>
<li><code>:content-type</code> - MIME type of request, if known
</li>
<li><code>:content-length</code> - bytes in request body, if known 
</li>
<li><code>:character-encoding</code> - body encoding, if known
</li>
<li><code>:headers</code> - map of HTTP headers (string to string)
</li>
<li><code>:body</code> - InputStream of body
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-9" class="outline-4">
<h4 id="sec-3-7-9">Ring responses&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-9">
<ul class="org-ul">
<li>Well-known keys:
<ul class="org-ul">
<li><code>:status</code> - HTTP status code - 200, 404, etc
</li>
<li><code>:headers</code> - map of HTTP response headers
</li>
<li><code>:body</code> - String, ISeq, File, or InputStream
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-10" class="outline-4">
<h4 id="sec-3-7-10">Compojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-10">
<ul class="org-ul">
<li>Compojure is a DSL for defining URL routes
</li>
<li>Generates Ring handlers
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(defroutes my-app
  (GET <span class="org-string">"/"</span> [] (home-page))
  (route/resources <span class="org-string">"/"</span>)
  (route/not-found <span class="org-string">"Page not found"</span>))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-7-11" class="outline-4">
<h4 id="sec-3-7-11">Routes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-11">
<ul class="org-ul">
<li>Syntax for each route
<ul class="org-ul">
<li><code>( http-method uri destructure body )</code>
</li>
<li>http-method - GET, POST, PUT, &#x2026;, ANY
</li>
<li>uri
<ul class="org-ul">
<li>"/about" - fixed path 
</li>
<li>"<i>user</i>:id" - variable with :id variable
</li>
<li>["<i>user</i>:id/:sub" :id #"[a-z]+" :sub #"[0-9]+"]
<ul class="org-ul">
<li>two variables with specified formats
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-12" class="outline-4">
<h4 id="sec-3-7-12">Routes (continued)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-12">
<ul class="org-ul">
<li>Route syntax (continued)
<ul class="org-ul">
<li>destructure
<ul class="org-ul">
<li><code>[id sub]</code> - vector of vars to destructure from params
</li>
<li><code>[id &amp; others]</code> - others is map of all remaining params
</li>
<li><code>[id :as r]</code> - bind r to entire request map
</li>
<li><code>{{id :id} :params}</code> - arbitrary destructuring from request 
</li>
</ul>
</li>
<li>body
<ul class="org-ul">
<li>sequence of expressions, as with typical bodies
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-13" class="outline-4">
<h4 id="sec-3-7-13">HTML with Hiccup&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-13">
<ul class="org-ul">
<li>Use Clojure data structures to represent HTML
</li>
<li>Vector - represent an HTML tag
<ul class="org-ul">
<li>First element is keyword defining the tag <code>:body</code>
</li>
<li>Second optional element is map of attributes
</li>
<li>Remaining sequence are child tags
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">[<span class="org-constant">:html</span> [<span class="org-constant">:body</span> [<span class="org-constant">:title</span> <span class="org-string">"Welcome!"</span>]]]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-7-14" class="outline-4">
<h4 id="sec-3-7-14"><code>html</code> function&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-3-7-14">
<ul class="org-ul">
<li>Use <code>html</code> function to convert a data structure to HTML text
</li>
<li>Special shortcut for CSS id/class attributes:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(html [<span class="org-constant">:div#foo.bar</span> <span class="org-string">"hi"</span>])
<span class="org-comment-delimiter">;; </span><span class="org-comment">"&lt;div id=\"foo\" class=\"bar\"&gt;hi&lt;/div&gt;"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8">LAB: Web Development&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-3-8">
</div>

<div id="outline-container-sec-3-8-1" class="outline-4">
<h4 id="sec-3-8-1">Introduction</h4>
<div class="outline-text-4" id="text-3-8-1">
<p>
In this lab, we will develop a very simple Clojure web application
using Ring, Compojure, and Hiccup.
</p>

<p>
To get started create a new Compojure-based project:
</p>

<pre class="example">
$ lein new compojure helloweb
</pre>

<p>
Modify the <code>project.clj</code> to add the following dependency:
<code>[hiccup "1.0.4"]</code>
</p>
</div>
</div>
<div id="outline-container-sec-3-8-2" class="outline-4">
<h4 id="sec-3-8-2">Run the server</h4>
<div class="outline-text-4" id="text-3-8-2">
<p>
Start the Ring server:
</p>

<pre class="example">
cd helloweb
lein ring server
</pre>
</div>
</div>
<div id="outline-container-sec-3-8-3" class="outline-4">
<h4 id="sec-3-8-3">Create a new route</h4>
<div class="outline-text-4" id="text-3-8-3">
<p>
Modify the web application so that <a href="http://localhost:3000/hello/">http://localhost:3000/hello/</a>&lt;name&gt;
for any &lt;name&gt; returns a page that says "Hello &lt;name&gt;".
</p>

<p>
Note: The Ring setup will automatically reload changes to your code.
</p>
</div>

<div id="outline-container-sec-3-8-3-1" class="outline-5">
<h5 id="sec-3-8-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-8-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(defroutes app-routes
  (GET <span class="org-string">"/"</span> [] <span class="org-string">"Hello World"</span>)
  (GET <span class="org-string">"/hello/:id"</span> [id] (<span class="org-variable-name">str</span> <span class="org-string">"Hello "</span> id))   <span class="org-comment-delimiter">;; </span><span class="org-comment">NEW</span>
  (route/resources <span class="org-string">"/"</span>)
  (route/not-found <span class="org-string">"Not Found"</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-8-4" class="outline-4">
<h4 id="sec-3-8-4">Create some middleware</h4>
<div class="outline-text-4" id="text-3-8-4">
<p>
Create and install Ring middleware that prints the incoming url path
to the console.
</p>
</div>

<div id="outline-container-sec-3-8-4-1" class="outline-5">
<h5 id="sec-3-8-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-8-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">log-url-handler</span> [handler]
  (<span class="org-variable-name">fn</span> [request]
    (<span class="org-variable-name">println</span> <span class="org-string">"Request URL: "</span> (<span class="org-constant">:uri</span> request))
    (handler request)))

(<span class="org-keyword">def</span> <span class="org-function-name">app</span>
  (log-url-handler
    (wrap-defaults app-routes site-defaults)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-8-5" class="outline-4">
<h4 id="sec-3-8-5">Use Hiccup to create a list</h4>
<div class="outline-text-4" id="text-3-8-5">
<p>
Add an atom to your helloweb.handler namespace:
<code>(def things (atom ["foo" "bar" "baz"]))</code>
</p>

<p>
Create a new route <a href="http://localhost:3000/list">http://localhost:3000/list</a> that lists the things.
Use hiccup to create the list content.
</p>

<p>
You will need to require <code>[hiccup.core :as hiccup]</code>.
</p>
</div>

<div id="outline-container-sec-3-8-5-1" class="outline-5">
<h5 id="sec-3-8-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-8-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">things</span> (<span class="org-variable-name">atom</span> [<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>]))

(<span class="org-keyword">defn</span> <span class="org-function-name">list-page</span> []
  (hiccup/html
   [<span class="org-constant">:body</span> [<span class="org-constant">:ol</span> (<span class="org-variable-name">map</span> #(<span class="org-variable-name">vector</span> <span class="org-constant">:li</span> %) @things)]]))

<span class="org-comment-delimiter">;; </span><span class="org-comment">add new route:</span>
  (GET <span class="org-string">"/list"</span> [] (list-page))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-8-6" class="outline-4">
<h4 id="sec-3-8-6">Create form to add new thing</h4>
<div class="outline-text-4" id="text-3-8-6">
<p>
At the end of the <a href="http://localhost:3000/list">http://localhost:3000/list</a> add a form with a single
text box and submit button. The form should submit to
<a href="http://localhost:3000/add">http://localhost:3000/add</a>.
</p>

<p>
You should require <code>[hiccup.form :as form]</code> and use the <code>form-to</code>,
<code>text-field</code>, and <code>submit-button</code> functions in that ns.
</p>

<p>
The default Ring middleware now contains support for anti-forgery 
tokens by default when posting forms. To make our web app work with these,
you need to require <code>[ring.util.anti-forgery :as af]</code> and include a hidden
field inside your hiccup <code>form-to</code> with <code>(af/anti-forgery-field)</code>.
</p>
</div>

<div id="outline-container-sec-3-8-6-1" class="outline-5">
<h5 id="sec-3-8-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-8-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">list-page</span> []
  (hiccup/html
   [<span class="org-constant">:body</span>
    [<span class="org-constant">:ol</span> (<span class="org-variable-name">map</span> #(<span class="org-variable-name">vector</span> <span class="org-constant">:li</span> %) @things)]
    (form/form-to [<span class="org-constant">:post</span> <span class="org-string">"/add"</span>]
                  [<span class="org-constant">:p</span> <span class="org-string">"Add new item:"</span>]
                  (form/text-field <span class="org-string">"item"</span>)
                  (af/anti-forgery-field)
                  (form/submit-button <span class="org-string">"Submit"</span>))]))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-8-7" class="outline-4">
<h4 id="sec-3-8-7">Accept the form and update the list</h4>
<div class="outline-text-4" id="text-3-8-7">
<p>
Posting the form should add an item to the things list and display a
page that tells the user the item has been added with a link back to
the list.
</p>
</div>

<div id="outline-container-sec-3-8-7-1" class="outline-5">
<h5 id="sec-3-8-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-8-7-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-page</span> [item]
  (<span class="org-variable-name">swap!</span> things conj item)
  (<span class="org-variable-name">println</span> <span class="org-string">"New things"</span> @things)
  (hiccup/html
   [<span class="org-constant">:body</span>
    [<span class="org-constant">:p</span> <span class="org-string">"Added "</span> item <span class="org-string">" to list"</span>]
    [<span class="org-constant">:a</span> {<span class="org-constant">:href</span> <span class="org-string">"/list"</span>} <span class="org-string">"Back to list"</span>]]))

<span class="org-comment-delimiter">;; </span><span class="org-comment">New route:</span>
  (POST <span class="org-string">"/add"</span> [item] (add-page item))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-8-8" class="outline-4">
<h4 id="sec-3-8-8">Bonus ideas</h4>
<div class="outline-text-4" id="text-3-8-8">
<ul class="org-ul">
<li>If you have extra time, try exploring some of these ideas:
<ul class="org-ul">
<li>Add the ability to remove items from the list
</li>
<li>Improve the styling of your app
<ul class="org-ul">
<li>Static resources can be placed under <code>/resources/public</code>
</li>
</ul>
</li>
<li>Store the list of things in a file to make it persistent
</li>
<li>Use <a href="https://github.com/ring-clojure/ring/wiki/Sessions">session middleware</a>
to make the things list per-session instead
of global
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9">Bonus Lab: Poker</h3>
<div class="outline-text-3" id="text-3-9">
</div>

<div id="outline-container-sec-3-9-1" class="outline-4">
<h4 id="sec-3-9-1">Introduction</h4>
<div class="outline-text-4" id="text-3-9-1">
<p>
In this lab, we will create a rudimentary simulation to compare the relative strength and frequency of various poker hands. We will use data structures to represent playing cards and write functions to find different kinds of poker hands.
</p>

<p>
If you have never played poker, don't worry, we will explain the rules as we go.
</p>

<p>
Poker is played with a standard deck of 52 cards. Each card has a <i>suit</i> and a <i>rank</i>. The possible suits are Hearts, Spades, Clubs, and Diamonds. The possible ranks are the numbers 2 through 10, followed by the "face cards" Jack, Queen, King, and Ace.
</p>
</div>
</div>
<div id="outline-container-sec-3-9-2" class="outline-4">
<h4 id="sec-3-9-2">Namespace</h4>
<div class="outline-text-4" id="text-3-9-2">
<p>
Create a new file for the namespace <code>student.poker</code>, with an appropriate <code>ns</code> declaration.
</p>
</div>

<div id="outline-container-sec-3-9-2-1" class="outline-5">
<h5 id="sec-3-9-2-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-2-1">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">in $CLASSPATH/student/poker.clj</span>
(<span class="org-builtin">ns</span> student.poker)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-3" class="outline-4">
<h4 id="sec-3-9-3">Suits</h4>
<div class="outline-text-4" id="text-3-9-3">
<p>
Define a collection of keywords representing the available card suits: Hearts, Spades, Clubs, and Diamonds.
</p>
</div>

<div id="outline-container-sec-3-9-3-1" class="outline-5">
<h5 id="sec-3-9-3-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-3-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">suits</span> [<span class="org-constant">:hearts</span> <span class="org-constant">:spades</span> <span class="org-constant">:clubs</span> <span class="org-constant">:diamonds</span>])
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-4" class="outline-4">
<h4 id="sec-3-9-4">Ranks</h4>
<div class="outline-text-4" id="text-3-9-4">
<p>
Define a collection of numbers and keywords representing the available card ranks in order from lowest (2) to highest (Ace).
</p>
</div>

<div id="outline-container-sec-3-9-4-1" class="outline-5">
<h5 id="sec-3-9-4-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-4-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">ranks</span> (<span class="org-variable-name">concat</span> (<span class="org-variable-name">range</span> 2 11) [<span class="org-constant">:jack</span> <span class="org-constant">:queen</span> <span class="org-constant">:king</span> <span class="org-constant">:ace</span>]))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-4-2" class="outline-5">
<h5 id="sec-3-9-4-2">Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-4-2">
<div class="org-src-container">

<pre class="src src-clojure">ranks
</pre>
</div>

<pre class="example">
;;=&gt; (2 3 4 5 6 7 8 9 10 :jack :queen :king :ace)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-5" class="outline-4">
<h4 id="sec-3-9-5">Creating the deck</h4>
<div class="outline-text-4" id="text-3-9-5">
<p>
Given the definitions of <code>suits</code> and <code>ranks</code>, define a collection that contains all 52 cards. Each card should be a map with two keys, <code>:suit</code> and <code>:rank</code>.
</p>
</div>

<div id="outline-container-sec-3-9-5-1" class="outline-5">
<h5 id="sec-3-9-5-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-5-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">all-cards</span>
  (<span class="org-builtin">for</span> [suit suits
        rank ranks]
    {<span class="org-constant">:rank</span> rank <span class="org-constant">:suit</span> suit}))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-5-2" class="outline-5">
<h5 id="sec-3-9-5-2">Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-5-2">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">use</span> 'clojure.pprint)
(pprint all-cards)
<span class="org-comment-delimiter">;; </span><span class="org-comment">({:rank 2, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 3, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 4, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 5, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 6, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 7, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 8, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 9, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 10, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :jack, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :queen, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :king, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :ace, :suit :hearts}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 2, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 3, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 4, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 5, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 6, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 7, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 8, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 9, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 10, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :jack, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :queen, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :king, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :ace, :suit :spades}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 2, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 3, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 4, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 5, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 6, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 7, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 8, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 9, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 10, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :jack, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :queen, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :king, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :ace, :suit :clubs}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 2, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 3, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 4, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 5, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 6, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 7, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 8, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 9, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank 10, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :jack, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :queen, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :king, :suit :diamonds}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:rank :ace, :suit :diamonds})</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-6" class="outline-4">
<h4 id="sec-3-9-6">Comparing ranks</h4>
<div class="outline-text-4" id="text-3-9-6">
<p>
We will need a way to compare two cards by rank. The numeric ranks (2 through 10) are easy, but what about the face cards?
</p>

<p>
We already have an ordered collection of all the ranks, but it is a mixture of numbers and keywords. In order to compare ranks, we could write a function with lots of complicated if/else logic, but there's an easier way. We have no direct way to compare numbers with keywords, so let's write a function that converts numbers and keywords into something we can compare, such as numbers.
</p>

<p>
Define a function that takes a rank (either keyword or number) as its argument and returns a number that is the relative "value" of the rank when compared with other ranks. For example, the result of calling this function on <code>:ace</code> should be higher than the result of calling it on <code>:jack</code>.
</p>

<p>
Hint: Remember that Clojure data structures are functions.
</p>
</div>

<div id="outline-container-sec-3-9-6-1" class="outline-5">
<h5 id="sec-3-9-6-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-6-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">rank-level</span> (<span class="org-variable-name">zipmap</span> ranks (<span class="org-variable-name">range</span>)))
</pre>
</div>

<p>
This might take some explaining. We have used <code>zipmap</code> to construct a map that looks like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">use</span> 'clojure.pprint)
(pprint rank-level)
<span class="org-comment-delimiter">;; </span><span class="org-comment">{2 0,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">3 1,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">4 2,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">5 3,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">6 4,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">7 5,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">8 6,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">9 7,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">10 8,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">:jack 9,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">:queen 10,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">:king 11,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">:ace 12}</span>
</pre>
</div>

<p>
Recall that maps are invocable. Given any rank, we can call <code>rank-level</code> on it and get a number that we can use to compare it with another rank. For example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(rank-level <span class="org-constant">:queen</span>)
</pre>
</div>

<pre class="example">
;;=&gt; 10
</pre>

<p>
Now we can sort a collection of ranks. For example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sort-by</span> rank-level [4 <span class="org-constant">:ace</span> <span class="org-constant">:jack</span> 10 3])
</pre>
</div>

<pre class="example">
;;=&gt; (3 4 10 :jack :ace)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-7" class="outline-4">
<h4 id="sec-3-9-7">Using combinations</h4>
<div class="outline-text-4" id="text-3-9-7">
<p>
The simplest poker hand is a pair: two cards with the same rank. Given a hand of five cards, we will need to check all possible combinations of two cards to see if they form a pair.
</p>

<p>
The <code>math.combinatorics</code> contrib library will help us find all possible combinations of a set of items. Add the library <code>org.clojure/math.combinatorics</code> version 0.0.7 to your project.
</p>

<p>
Make the <code>combinations</code> function from the <code>clojure.math.combinatorics</code> namespace available in your <code>student.poker</code> namespace, find its documentation, and use it to find every combination of 2 elements taken from a set of 5 elements.
</p>
</div>

<div id="outline-container-sec-3-9-7-1" class="outline-5">
<h5 id="sec-3-9-7-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-7-1">
<p>
In your <code>project.clj</code> file:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defproject <span class="org-comment-delimiter">;;</span><span class="org-comment">...</span>
  <span class="org-constant">:dependencies</span> [<span class="org-comment-delimiter">;;</span><span class="org-comment">...</span>
                 [org.clojure/math.combinatorics <span class="org-string">"0.0.7"</span>]])
</pre>
</div>

<p>
In your source file:
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">in $CLASSPATH/student/poker.clj</span>
(<span class="org-builtin">ns</span> student.poker
  (<span class="org-constant">:require</span> [clojure.math.combinatorics <span class="org-constant">:refer</span> (combinations)]))
</pre>
</div>

<p>
At the REPL:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> 'student.poker <span class="org-constant">:reload</span>)
(<span class="org-builtin">in-ns</span> 'student.poker)
(<span class="org-variable-name">use</span> 'clojure.repl)
(<span class="org-variable-name">doc</span> combinations)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(combinations [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span> <span class="org-constant">:d</span> <span class="org-constant">:e</span>] 2)
</pre>
</div>

<pre class="example">
;;=&gt; ((:a :b) (:a :c) (:a :d) (:a :e) (:b :c) (:b :d) (:b :e) (:c :d) (:c :e) (:d :e))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-8" class="outline-4">
<h4 id="sec-3-9-8">Checking pairs</h4>
<div class="outline-text-4" id="text-3-9-8">
<p>
Define a function that takes a collection of cards as its argument and returns logical true if those cards contain at least one pair, logical false if they do not.
</p>
</div>

<div id="outline-container-sec-3-9-8-1" class="outline-5">
<h5 id="sec-3-9-8-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-8-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">has-pair</span> [cards]
  (<span class="org-variable-name">some</span> (<span class="org-variable-name">fn</span> [[a b]] (<span class="org-variable-name">=</span> (<span class="org-constant">:rank</span> a) (<span class="org-constant">:rank</span> b)))
        (combinations cards 2)))
</pre>
</div>

<p>
There are many ways to write this function. Here, we have used sequential destructuring in the <code>fn</code> parameters to assign each card to a local variable before comparing their ranks.
</p>

<p>
Here is an alternative version that treats each two-card combination as a collection:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">has-pair</span> [cards]
  (<span class="org-variable-name">some</span> (<span class="org-variable-name">fn</span> [combo] (<span class="org-variable-name">apply</span> = (<span class="org-variable-name">map</span> <span class="org-constant">:rank</span> combo)))
        (combinations cards 2)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-9" class="outline-4">
<h4 id="sec-3-9-9">Checking 3-of-a-kind and 4-of-a-kind</h4>
<div class="outline-text-4" id="text-3-9-9">
<p>
Define two functions, each of which takes a collection of cards as its argument and returns logical true if the collection contains:
</p>

<ul class="org-ul">
<li>3-of-a-kind: 3 cards of the same rank
</li>
<li>4-of-a-kind: 4 cards of the same rank
</li>
</ul>
</div>

<div id="outline-container-sec-3-9-9-1" class="outline-5">
<h5 id="sec-3-9-9-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-9-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">has-3-of-a-kind</span> [cards]
  (<span class="org-variable-name">some</span> (<span class="org-variable-name">fn</span> [combo] (<span class="org-variable-name">apply</span> = (<span class="org-variable-name">map</span> <span class="org-constant">:rank</span> combo)))
        (combinations cards 3)))

(<span class="org-keyword">defn</span> <span class="org-function-name">has-4-of-a-kind</span> [cards]
  (<span class="org-variable-name">some</span> (<span class="org-variable-name">fn</span> [combo] (<span class="org-variable-name">apply</span> = (<span class="org-variable-name">map</span> <span class="org-constant">:rank</span> combo)))
        (combinations cards 4)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-10" class="outline-4">
<h4 id="sec-3-9-10">Refactoring for less repetition</h4>
<div class="outline-text-4" id="text-3-9-10">
<p>
Our functions <code>has-pair</code>, <code>has-3-of-a-kind</code>, and <code>has-4-of-a-kind</code> are all very similar. Rewrite them all in terms of one shared function.
</p>
</div>

<div id="outline-container-sec-3-9-10-1" class="outline-5">
<h5 id="sec-3-9-10-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-10-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">has-n-of-a-kind</span> [n cards]
  (<span class="org-variable-name">some</span> (<span class="org-variable-name">fn</span> [combo] (<span class="org-variable-name">apply</span> = (<span class="org-variable-name">map</span> <span class="org-constant">:rank</span> combo)))
        (combinations cards n)))

(<span class="org-keyword">def</span> <span class="org-function-name">has-pair</span> (<span class="org-variable-name">partial</span> has-n-of-a-kind 2))

(<span class="org-keyword">def</span> <span class="org-function-name">has-3-of-a-kind</span> (<span class="org-variable-name">partial</span> has-n-of-a-kind 3))

(<span class="org-keyword">def</span> <span class="org-function-name">has-4-of-a-kind</span> (<span class="org-variable-name">partial</span> has-n-of-a-kind 4))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-11" class="outline-4">
<h4 id="sec-3-9-11">Checking for a flush</h4>
<div class="outline-text-4" id="text-3-9-11">
<p>
Define a function that takes a collection of cards as its argument and returns logical true if they are a flush. A flush occurs when all cards have the same suit.
</p>
</div>

<div id="outline-container-sec-3-9-11-1" class="outline-5">
<h5 id="sec-3-9-11-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-11-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">flush?</span> [cards]
  (<span class="org-variable-name">apply</span> = (<span class="org-variable-name">map</span> <span class="org-constant">:suit</span> cards)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-12" class="outline-4">
<h4 id="sec-3-9-12">Checking for a straight</h4>
<div class="outline-text-4" id="text-3-9-12">
<p>
Define a function that takes a collection of cards as its argument and returns logical true if they are a straight. A straight occurs when all the cards can be arranged in order such that their ranks are consecutive.
</p>

<p>
For example, cards with the ranks <code>[8 9 10 :jack :queen]</code> would make a straight. Cards with the ranks <code>[3 4 5 :king :ace]</code> would <b>not</b> make a straight.
</p>
</div>

<div id="outline-container-sec-3-9-12-1" class="outline-5">
<h5 id="sec-3-9-12-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-12-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn-</span> <span class="org-function-name">card-levels</span> [cards]
  (<span class="org-variable-name">map</span> (<span class="org-variable-name">comp</span> rank-level <span class="org-constant">:rank</span>) cards))

(<span class="org-keyword">defn-</span> <span class="org-function-name">step-pairs</span> [levels]
  (<span class="org-variable-name">partition</span> 2 1 (<span class="org-variable-name">sort</span> levels)))

(<span class="org-keyword">defn-</span> <span class="org-function-name">deltas</span> [pairs]
  (<span class="org-builtin">for</span> [[a b] pairs] (<span class="org-variable-name">-</span> b a)))

(<span class="org-keyword">defn-</span> <span class="org-function-name">all-one?</span> [nums]
  (<span class="org-variable-name">apply</span> = 1 nums))

(<span class="org-keyword">defn</span> <span class="org-function-name">straight?</span> [cards]
  (all-one? (deltas (step-pairs (card-levels cards)))))
</pre>
</div>

<p>
This one is tricky. To prove that the cards have consecutive rank, we have to order them by rank and then check that all the cards are exactly one rank apart.
</p>

<p>
Here we break the problem down into several steps, using the output of one step as the input into the next step. The intermediate steps are defined as private functions (<code>defn-</code>) since we will never use them outside of this namespace.
</p>

<p>
First, the <code>card-levels</code> function takes a collection of cards and returns a sequence of their levels, which we can use to compare them by rank.
</p>

<p>
Second, the <code>step-pairs</code> function takes the sequence of levels, sorts it, and uses Clojure's <code>partition</code> function to get a sequence of pairs, showing the transition from one element to the next. For example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(step-pairs [7 8 9 2 3])
</pre>
</div>

<pre class="example">
;;=&gt; ((2 3) (3 7) (7 8) (8 9))
</pre>

<p>
Using those pairs, we can calculate the delta from one element to the next. That's what the <code>deltas</code> function does:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(deltas '((2 3) (3 7) (7 8) (8 9)))
</pre>
</div>

<pre class="example">
;;=&gt; (1 4 1 1)
</pre>

<p>
Fourth, we can easily check that all the deltas equal one:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(all-one? '(1 4 1 1))
</pre>
</div>

<pre class="example">
;;=&gt; false
</pre>

<p>
Finally, the <code>straight?</code> function ties everything together:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(straight? [{<span class="org-constant">:rank</span> <span class="org-constant">:jack</span> <span class="org-constant">:suit</span> <span class="org-constant">:diamonds</span>}
            {<span class="org-constant">:rank</span> <span class="org-constant">:queen</span> <span class="org-constant">:suit</span> <span class="org-constant">:spades</span>}
            {<span class="org-constant">:rank</span> 8 <span class="org-constant">:suit</span> <span class="org-constant">:hearts</span>}
            {<span class="org-constant">:rank</span> 9 <span class="org-constant">:suit</span> <span class="org-constant">:clubs</span>}
            {<span class="org-constant">:rank</span> 10 <span class="org-constant">:suit</span> <span class="org-constant">:hearts</span>}])
</pre>
</div>

<pre class="example">
;;=&gt; true
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(straight? [{<span class="org-constant">:rank</span> 8 <span class="org-constant">:suit</span> <span class="org-constant">:hearts</span>}
            {<span class="org-constant">:rank</span> 9 <span class="org-constant">:suit</span> <span class="org-constant">:clubs</span>}
            {<span class="org-constant">:rank</span> 10 <span class="org-constant">:suit</span> <span class="org-constant">:hearts</span>}
            {<span class="org-constant">:rank</span> <span class="org-constant">:jack</span> <span class="org-constant">:suit</span> <span class="org-constant">:diamonds</span>}
            {<span class="org-constant">:rank</span> 4 <span class="org-constant">:suit</span> <span class="org-constant">:diamonds</span>}])
</pre>
</div>

<pre class="example">
;;=&gt; false
</pre>
</div>
</div>
<div id="outline-container-sec-3-9-12-2" class="outline-5">
<h5 id="sec-3-9-12-2">A shorter solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-12-2">
<p>
The threading macros <code>-&gt;</code> and <code>-&gt;&gt;</code> can facilitate writing functions that work as a series of steps. For example, here is how a more-experienced Clojure programmer might write the <code>straight?</code> function:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">straight?</span> [cards]
  (<span class="org-builtin">-&gt;&gt;</span> cards
       (<span class="org-variable-name">map</span> (<span class="org-variable-name">comp</span> rank-level <span class="org-constant">:rank</span>))
       sort
       (<span class="org-variable-name">partition</span> 2 1)
       (<span class="org-variable-name">map</span> (<span class="org-variable-name">fn</span> [[a b]] (<span class="org-variable-name">-</span> b a)))
       (<span class="org-variable-name">apply</span> = 1)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-13" class="outline-4">
<h4 id="sec-3-9-13">Checking for a straight flush</h4>
<div class="outline-text-4" id="text-3-9-13">
<p>
Define a function that takes a collection of cards as its argument and returns logical true if they are a straight flush. A straight flush occurs when all the cards are of the same suit and have consecutive ranks.
</p>
</div>

<div id="outline-container-sec-3-9-13-1" class="outline-5">
<h5 id="sec-3-9-13-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-13-1">
<p>
A straight flush is any collection of cards that is both a straight and a flush.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">straight-flush?</span> [cards]
  (<span class="org-builtin">and</span> (straight? cards) (flush? cards)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-14" class="outline-4">
<h4 id="sec-3-9-14">Finding the best hand</h4>
<div class="outline-text-4" id="text-3-9-14">
<p>
Given the functions already defined in this lab, define a function which takes a collection of cards as its argument and returns a keyword naming the <b>best</b> poker hand that can be made from those cards.
</p>

<p>
The order of hands in poker, from best to worst, is:
</p>

<ol class="org-ol">
<li>royal flush (omitted from this lab)
</li>
<li>straight flush
</li>
<li>four-of-a-kind
</li>
<li>full house (omitted, see bonus)
</li>
<li>flush
</li>
<li>straight
</li>
<li>three-of-a-kind
</li>
<li>two pair (omitted, see bonus)
</li>
<li>pair
</li>
<li>high card (the default when there is no other hand)
</li>
</ol>
</div>

<div id="outline-container-sec-3-9-14-1" class="outline-5">
<h5 id="sec-3-9-14-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-14-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">best-hand</span> [cards]
  (<span class="org-builtin">cond</span>
   (straight-flush? cards) <span class="org-constant">:straight-flush</span>
   (has-4-of-a-kind cards) <span class="org-constant">:four-of-a-kind</span>
   (flush? cards) <span class="org-constant">:flush</span>
   (straight? cards) <span class="org-constant">:straight</span>
   (has-3-of-a-kind cards) <span class="org-constant">:three-of-a-kind</span>
   (has-pair cards) <span class="org-constant">:pair</span>
   <span class="org-constant">:else</span> <span class="org-constant">:high-card</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-15" class="outline-4">
<h4 id="sec-3-9-15">Comparing hands</h4>
<div class="outline-text-4" id="text-3-9-15">
<p>
Define a <i>comparator</i> function for two hands of cards. A comparator function takes two arguments <i>a</i> and <i>b</i> and returns:
</p>

<ul class="org-ul">
<li>A negative number if <i>a</i> is lesser than <i>b</i>
</li>
<li>A positive number if <i>a</i> is greater than <i>b</i>
</li>
<li>Zero if <i>a</i> is equal to <i>b</i>
</li>
</ul>

<p>
For the purposes of this lab, two hands of the same type (e.g. two straights) are considered equal, regardless of the rank of the cards they contain.
</p>
</div>

<div id="outline-container-sec-3-9-15-1" class="outline-5">
<h5 id="sec-3-9-15-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-15-1">
<p>
We can use the same map-to-numbers technique as before, along with Clojure's <code>compare</code> function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">hands</span> [<span class="org-constant">:high-card</span> <span class="org-constant">:pair</span> <span class="org-constant">:three-of-a-kind</span> <span class="org-constant">:straight</span>
            <span class="org-constant">:flush</span> <span class="org-constant">:four-of-a-kind</span> <span class="org-constant">:straight-flush</span>])

(<span class="org-keyword">def</span> <span class="org-function-name">hand-level</span> (<span class="org-variable-name">zipmap</span> hands (<span class="org-variable-name">range</span>)))

(<span class="org-keyword">defn</span> <span class="org-function-name">compare-hands</span> [a b]
  (<span class="org-variable-name">compare</span> (hand-level a) (hand-level b)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-16" class="outline-4">
<h4 id="sec-3-9-16">Play a trial game</h4>
<div class="outline-text-4" id="text-3-9-16">
<p>
Define a function which simulates a simplified two-player poker game. Take a shuffled deck of cards, deal five cards to each player, get the best hand for each, and compare them. Return the name of the winning hand, as a keyword. When both hands are equal, return the keyword <code>:tie</code>.
</p>
</div>

<div id="outline-container-sec-3-9-16-1" class="outline-5">
<h5 id="sec-3-9-16-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-16-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">trial-game</span> []
  (<span class="org-builtin">let</span> [deck (shuffle all-cards)
        hand-a (<span class="org-variable-name">take</span> 5 deck)
        hand-b (<span class="org-variable-name">take</span> 5 (<span class="org-variable-name">drop</span> 5 deck))
        best-a (best-hand hand-a)
        best-b (best-hand hand-b)]
    (<span class="org-builtin">case</span> (compare-hands best-a best-b)
      -1 best-b
      0 <span class="org-constant">:tie</span>
      1 best-a)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-17" class="outline-4">
<h4 id="sec-3-9-17">Play many games</h4>
<div class="outline-text-4" id="text-3-9-17">
<p>
Define a function which takes a number <i>n</i>, plays <i>n</i> trial games of poker, and returns a map showing the number of times that each hand was a winner, ignoring ties.
</p>
</div>

<div id="outline-container-sec-3-9-17-1" class="outline-5">
<h5 id="sec-3-9-17-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-17-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">count-wins</span> [n]
  (frequencies (<span class="org-variable-name">remove</span> #{<span class="org-constant">:tie</span>} (<span class="org-variable-name">repeatedly</span> n trial-game))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(count-wins 1000)
</pre>
</div>

<pre class="example">
;;=&gt; {:pair 450, :flush 3, :three-of-a-kind 34, :straight 5}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-18" class="outline-4">
<h4 id="sec-3-9-18">Bonus: Two pair</h4>
<div class="outline-text-4" id="text-3-9-18">
<p>
Define a function that takes a collection of cards as its argument and returns logical true if it contains two distinct pairs.
</p>
</div>

<div id="outline-container-sec-3-9-18-1" class="outline-5">
<h5 id="sec-3-9-18-1">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-3-9-18-1">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">has-two-pair</span> [cards]
  (<span class="org-variable-name">=</span> 2 (<span class="org-variable-name">count</span> (<span class="org-variable-name">filter</span> (<span class="org-variable-name">fn</span> [[a b]] (<span class="org-variable-name">=</span> (<span class="org-constant">:rank</span> a) (<span class="org-constant">:rank</span> b)))
                      (combinations cards 2)))))
</pre>
</div>

<p>
This is slightly more complicated than checking for just one pair. We need to find two <b>distinct</b> pairs. Normally when searching for distinct things we would need to be careful that they do not overlap, but that is not a problem here because two overlapping pairs would be 3-of-a-kind. So this is just a problem of counting how many unique pairs there are in a set of cards.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-9-19" class="outline-4">
<h4 id="sec-3-9-19">Bonus: Full house</h4>
<div class="outline-text-4" id="text-3-9-19">
<p>
A full house is a hand that contains both a pair and 3-of-a-kind. This is left as an exercise for the reader.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">The End</h2>
<div class="outline-text-2" id="text-4">
<p>
Produced with <a href="https://github.com/relevance/org-html-slideshow">org-html-slideshow</a>
</p>

<p>
#+COMMENT Bulleted lists start at outline level 5
</p>
<p>
#+COMMENT include results of evaluating Clojure source code in exported HTML
</p>
<p>
#+COMMENT org-html-slideshow
</p>
<script type="text/javascript" src="slide-assets/org-html-slideshow.js"></script>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Clojure/core</p>
<p class="date">Created: 2017-10-09 Mon 12:23</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.1.1)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
